# 贪心算法1

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250220231110398.png" alt="image-20250220231110398" width=700 /> 

 :one:这是一个严格的结论：令$\forall{n}\text{=}3m\text{+r}$，其中$r\text{=}n\text{ mod }{3}$

1. $r\text{=0}$是分解为$3m$
2. $r\text{=1}$是分解为$3(m–1)\text{+2+2}$
3. $r\text{=2}$是分解为$3m\text{+2}$

:two:贪心选择性质：算法每一步的局部最优，会带来最终的全局最优

1. 首先证明分解数不超过$4$：假设某一个数分解出现了$k\text{≥4}$，则乘积为$k\text{×}\text{Rest}$
   - 可以再将$k$变成$k\text{=}2\text{+}(k–2)$，则乘积变为了$2(k–2)\text{×}\text{Rest}$
   - $2(k–2)\text{×}\text{Rest}–k\text{×}\text{Rest}\text{=}(k–4)\text{×}\text{Rest}\text{≥}0$，所以消除$k$能使得乘积更大
2. 其次如果选择$1$也是不行的，比如$k\text{×}\text{Rest}\text{≥}1^k\text{×}\text{Rest}$
3. 所以==最优情况必须是划为$2$或$3$的总和==，接下来需要做的就是判断是以$2$为主还是以$3$为主
   - 假设选择更多的$2$为最优，以$6$为例，$2^3\text{＜}3^2$所以不成立
   - 所以应该分解为更多的$3$
4. 余数的处理
   - 余数为$0$，不处理
   - 余数为$1$，出现了$1$就不是最优了，最优的做法是借一个$3$将其分为$\text{2+2}$
   - 余数为$2$，不处理

# 贪心算法2

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221161430253.png" alt=" " width=700 />  

:zero:概念理解

1. $X$被$Y$覆盖：也就是$X$的每个子区间都必须被$Y$的某个子区间覆盖
2. 覆盖数：就是$Y$能覆盖$X$后$Y$有多少子区间
3. 注意有一个误区，就是$Y$必须是$X$的子集，不然一个从头到尾的大区间就覆盖掉了，不论中间有没有空隙

:one:贪心策略

1. 初始化：将$X$中第一个区间放入$Y$，作为当前区间
2. 更新：重复以下过程
   - 如果当前区间与其他区间有交集
     - 将选取右边界最大的有交集区间
     - 将当前区间与右边界最大的区间进行合并加入到$Y$，形成新的当前区间
   - 如果当前区间与其他区间没有交集
     - 选取离当前区间距离最小的区间
     - 将该区间加入到$Y$中，更新当前区间为该区间

:two:最优性证明：

1. 假设存在某个更优解，其必定在某一部需要选择一个右端点更小的区间
2. 从而导致相比原有做法，后续需要更多区间覆盖，不是最优
3. 所以矛盾，本方法最优

:three:复杂度：只需遍历一次，每个区间在每次遍历时只被处理一次，所以复杂度为$O(n)$ 

# 贪心算法3

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250221194300049.png" alt="image-20250221194300049" width=700 /> 

:one:首先讲所有小孩$/$饼干按照饥饿度$/$饼干大小排序

:two:用$i$指针遍历小孩数组，用$j$指针遍历饼干数组

1. 如果$C_i\text{>}B_j$，则执行$j\text{++}$
2. 如果$C_i\text{≤}B_j$，则执行$j\text{++}/i\text{++}/\text{Count++}$

:three:最终输出$\text{Count}$

# 贪心算法4

```txt
目前拥有1元、3元、9元、27元的纸币若干，请你设计一个算法使得花最少的张数凑得总金额m。

(a)假设m=35，请设计并写上一种贪心算法使得满足原问题的要求，并写出输出结果。
(b)请说明这个贪心算法得出来的解是最优解。
```

:one:先不断选择$27$，不足$27$时不断选$9$，不足$9$时不断选$3$，不足$3$时不断选$1$。所以是$\text{27×1+3×2+1×2}$

:two:最优性：

1. 现行策略：在剩余子问题规模一定时，优先选择面值更大的货币
2. 假设有更优的策略：面对子问题时选择面值更小的货币，这必将增大解决子问题所消耗的货币数
3. 所以现行策略是最优的



