# $\textbf{SQL (Structured Query Language)}$ 

# $\textbf{1. Relational Algebra}$ ​ 

> ## $\textbf{1.0. Overview}$ 
>
> > **1️⃣**关系操作：包括五个==$\text{Basic Operation}$== 
> >
> > |       $\textbf{Operations}$       |   符号    |       原关系        |                       操作(得到新关系)                       |
> > | :-------------------------------: | :-------: | :-----------------: | :----------------------------------------------------------: |
> > |      ==$\text{Projection}$==      |   $\pi$   |       原关系        | $\large\xrightarrow[2. 去除重复行]{1. 保留想要的列(竖直过滤)}$ |
> > |      ==$\text{Selection}$==       | $\sigma$  |       原关系        |        $\large\xrightarrow[]{保留想要的行(水平过滤)}$        |
> > |        ==$\text{Union}$==         |  $\cup$   | 原关系$1+$原关系$2$ | $\large\xrightarrow[2. 去除重复项]{1. 合并两表所有\text{Tuple}}$ |
> > |       $\text{Intersection}$       |  $\cap$   | 原关系$1+$原关系$2$ | $\large\xrightarrow[2. 去除重复项]{1. 提取两个表都出现的\text{Tuple}}$ |
> > | ==$\text{Set-difference/Minus}$== |    $-$    | 原关系$1+$原关系$2$ | $\large\xrightarrow[]{移除关系2所含\text{Tuple}(在关系1中)}$ |
> > |    ==$\text{Cross-product}$==     |    $×$    | 原关系$1+$原关系$2$ | $\large\xrightarrow[]{\text{Tuple}无条件互相组合(笛卡尔积)}$ |
> > |           $\text{Join}$           | $\bowtie$ | 原关系$1+$原关系$2$ | $\large\xrightarrow[2. 按条件\text{Selection}]{1.\text{Tuple}无条件互相组合}$ |
> >
> > **2️⃣**$\text{Condition Expressions:}$ 
> >
> > |              类型               |         符号          |
> > | :-----------------------------: | :-------------------: |
> > | $\text{Arithmetic Expressions}$ | `>, <, >=, <=, =, !=` |
> > |     $\text{AND/OR Clauses}$     |   `AND → Λ, OR → V`   |
> >
> > 1. 示例：$\sigma_{\text{rating}\geq{}9\text{ }\land{}\text{ age<50}}(\text{S}_2)$​​ 
> >
> >    ```sql
> >    SELECT * FROM S2 
> >    WHERE rating >= 9 AND age < 50;
> >    ```
> >
> > 2. 注意事项
> >
> >    - $\text{SQL}$与$\text{C++}$等不同，等于就是$\text{=/}$不是$\text{==}$ 
> >    - 不等于的两种表达：`!=`或者`<>`  
>
> ## $\textbf{1.1. Projection}(\pi{})\textbf{ \& Selection}(\sigma{})$  
>
> > **1️⃣**$\text{Projection}(\pi{})$ 
> >
> > 1. 操作：仅保留$\text{Projection List}$中的列$\to{}$去除重复的行
> >
> > 2. 特点：$\text{Projection is a costly operation, DB won't operate it by default.}$ 
> >
> > 3. 示例：注意$\text{SQL}$中可控制投影后去不去出重复项，但$\text{Relational Algebra}$里==默认去除==重复项
> >
> >    ```sql
> >    SELECT * FROM Student; -- 选中所有列(左表)
> >    SELECT age FROM Student; -- 选中年龄这一列，但是SQL操作中默认不去除重复项(中表)
> >    SELECT DISTINCT age FROM Student; -- 选中年龄这一列，删除重复项(右表)
> >    ```
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711891750690.jpg" alt="1711891750690" style="zoom:67%;" /> $\Large\xrightarrow{\pi_{\text{age}}(\text{S})}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401023305604.png" alt="image-20240401023305604" style="zoom:60%;" /> $\large\large \xrightarrow{\text{Removed duplicates}}$​<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401023545442.png" alt="image-20240401023545442" style="zoom: 57%;" /> 
> >
> > **2️⃣**$\text{Selection}(\sigma{})$ 
> >
> > 1. 操作：仅保留$\text{Selection}$条件的行，并且不会有任何重复行
> >
> > 2. 示例：在$\text{SQL}$​中体现在`WHERE`上
> >
> >    ```sql
> >    SELECT * FROM Student WHERE Student.rating >= 9;
> >    ```
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401025827011.png" alt="image-20240401025827011" style="zoom:40%;" /> $\Large\xrightarrow{\sigma_{\text{rating}\geq{}9}(\text{S})}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/39f6ffcb25a774de649e5fdbcbbf97c6.png" alt="39f6ffcb25a774de649e5fdbcbbf97c6" style="zoom:50%;" />     
> >
> > **3️⃣**$\text{Projection}(\pi{})\text{ \& Selection}(\sigma{})$​
> >
> > 1. 注意事项
> >    - 一般先$\text{Selection}$后$\text{Projection}$的$(\pi{_{\text{A}}}(\sigma{_{\text{B}}}))$结构，这是因为$\text{Selection}$不会改变表格结构
> >    - 
> >
> > ```sql
> > SELECT sname, rating FROM Student WHERE Student.rating >= 9;
> > ```
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401031241564.png" alt="image-20240401031241564" style="zoom:50%;" /> $\Large\xrightarrow{\pi_{\text{sname, rating}}(\sigma_{\text{rating}\geq{}9}(\text{S}))}$​​<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401031348650.png" alt="image-20240401031348650" style="zoom:50%;" />  
> >
> > 1. 
> > 2. 如果一定要用先$\text{Projection}$再$\text{Selection}$的$(\sigma{_{\text{A}}}(\pi{_{\text{B}}}))$结构，要确保$\text{A}\subseteq\text{B}$ 
>
> ## $\textbf{1.2. Union/Set-Difference/Intersection}$ 
>
> > ==对应的$\text{SQL}$操作叫做$\text{Set Operations}$== 
> >
> > **0️⃣**条件($\text{Union-Compatible}$​)：
> >
> > 1. 两表$\text{Column}$数一致，相应的列的$\text{Data Type}$​相同 
> >    - <span style="color:red;">两表属性名不一定要相同，$\text{SQL}$默认取上表的名</span>
> > 2. 该条件适用$\text{Union/Set Difference/Intersection}$三者
> >
> > **1️⃣**$\text{Union:}$ 
> >
> > 1. 操作：将两表==上下拼接==在一起，并在$\text{Relational Algebra}$​中默认消除重复项
> >
> > 2. 特性：对称性($\text{Symmetric}$)
> >
> > 3. 示例：在$\text{SQL}$代码中体现在`UNION`上(但不默认消除重复项)
> >
> >    ```sql
> >    SELECT sid, sname, rating, age FROM S1 -- 此操作去除重复行
> >    UNION
> >    SELECT sid, sname, rating, age FROM S2;
> >    SELECT sid, sname, rating, age FROM S1 -- 此操作保留重复行
> >    UNION ALL
> >    SELECT sid, sname, rating, age FROM S2;
> >    ```
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902909279.jpg" alt="1711902909279" style="zoom: 40%;" /> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902927676.jpg" alt="1711902927676" style="zoom: 40%;" /> $\large\xrightarrow[\text{or }\\ \text{S}_2\cup{\text{S}_1}]{\text{S}_1\cup{\text{S}_2}}$​​<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711903012794.jpg" alt="1711903012794" style="zoom: 40%;" />  
> >
> > **2️⃣**$\text{Set-Difference:}$ 
> >
> > 1. 操作：从一个关系中，删除另一个关系中存在的$\text{Tuple}$​ 
> >
> > 2. 特性：无对称性($\text{Asymmetric}$)
> >
> > 3. 示例：$\text{SQL}$中并==没有直接的求差集子句==，可以通过子查询变相实现
> >
> >    ```sql
> >    SELECT sid, sname, rating, age
> >    FROM S1
> >    WHERE (sid, sname, rating, age) NOT IN (
> >        SELECT sid, sname, rating, age
> >        FROM S2
> >    );
> >    ```
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902909279.jpg" alt="1711902909279" style="zoom: 40%;" /> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902927676.jpg" alt="1711902927676" style="zoom: 40%;" /> $\large\xrightarrow{\text{S}_1-{\text{S}_2}}$​ <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711903146343.jpg" style="zoom:40%;" />  
> >
> > **3️⃣**$\text{Intersection: Compound Operator}$   
> >
> > 1. 操作：找出两个关系中共存的$\text{Tuples}$，本质上是混合运算$\text{R}\cap{}\text{S}\equiv\text{R}-(\text{R}-\text{S})$ 
> >
> > 2. 示例：注意操作有对称性；同样也需要用$\text{SQL}$子查询变相实现
> >
> >    ```sql
> >    SELECT sid, sname, rating, age
> >    FROM S1
> >    WHERE (sid, sname, rating, age) IN (
> >        SELECT sid, sname, rating, age
> >        FROM S2
> >    );
> >    ```
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902909279.jpg" alt="1711902909279" style="zoom: 40%;" /> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902927676.jpg" alt="1711902927676" style="zoom: 40%;" /> $\large\xrightarrow[\text{or }\\ \text{S}_2\cap{\text{S}_1}]{\text{S}_1\cap{\text{S}_2}}$​<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908164999.jpg" alt="1711908164999" style="zoom:40%;" />  
>
> ## $\textbf{1.3. Cross product \& Joins}$ 
>
> > ==$\text{SQL Inter Table Operations}$== 
> >
> > ### $\textbf{1.3.1. Cross Product}(×)$ 
> >
> > > **1️⃣**操作：
> > >
> > > 1. 用一个表的每行，依次去扫描另一个表的每一行，输出组合
> > >
> > > 2. 结果会保留所有的列(即使重名了，也不要紧)
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902909279.jpg" alt="1711902909279" style="zoom: 40%;" /> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908857220.jpg" alt="1711908857220" style="zoom:35%;" /> $\large\xrightarrow{\text{R}×{\text{S}}}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908813683.jpg" alt="1711908813683" style="zoom:40%;" />   
> > >
> > > **2️⃣**重命名$\rho{}$：
> > >
> > > 1. 合并后的属性名称可能一样，由此需要重命名
> > >
> > > 2. 比如$\rho{(\text{C}(1\to{\text{sid1}},5\to{\text{sid2}}),\text{R}×\text{S}})$ 
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908813683.jpg" alt="1711908813683" style="zoom:40%;" /> $\longrightarrow{}$​​<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240519203220727.png" alt="image-20240519203220727" style="zoom:27%;" /> 
> > >    
> > >    - $1\to{\text{sid1}}$的意思是：第一列改成$\text{sid1}$ 
> > >
> > > **3️⃣**$\text{SQL}$代码
> > >
> > > ```sql
> > > SELECT * FROM R, S;	-- Cross product between R, S
> > > ```
> >
> > ### $\textbf{1.3.2. Inner Join}(\bowtie): \textbf{Conditional Cross-Product}$ 
> >
> > >  **1️⃣**$\text{Inner Join(AKA Condition Join):}$  $\text{R}\bowtie{_{\text{Condition}}}\text{S} = \sigma_{\text{Condition}}(\text{R×S})$ 
> > >
> > >  1. $\text{R}\bowtie_{\text{(S}\text{.sid<R}\text{.sid)}}\text{S}$中，先计算$\text{R}×\text{S}$  
> > >
> > >       <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902909279.jpg" alt="1711902909279" style="zoom: 35%;" /> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908857220.jpg" alt="1711908857220" style="zoom:35%;" /> $\large\xrightarrow{\text{R}×{\text{S}}}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908813683.jpg" alt="1711908813683" style="zoom:43%;" />   
> > >
> > >  2. 再筛选满足${\text{(R}\text{.sid<S}\text{.sid)}}\text{}$的行
> > >
> > >     <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908813683.jpg" alt="1711908813683" style="zoom:42%;" /> $\longrightarrow{}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711911148407.jpg" alt="1711911148407" style="zoom:35%;" /> 
> > >
> > >  3. $\text{SQL: }$⚠️⚠️⚠️当两表中有$\text{Column}$名撞了，应该在$\text{Column}$名前加上表名
> > >
> > >     ```sql
> > >     SELECT * FROM R INNER JOIN S ON R.sid < S.sid;
> > >     ```
> > >
> > >  **2️⃣**$\text{Natural Join(AKA Join):}$ 一种隐式的$\text{Inner Join}$​  
> > >
> > >  <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401231354398.png" alt="image-20240401231354398" style="zoom:50%;" /> 
> > >
> > >  1. 原理/计算步骤
> > >
> > >     - 先计算$\text{R}×\text{S}$，找到两组(一组一或多个)名字相同的$\text{Column}$(此处为$\text{sid}$)
> > >
> > >         <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902909279.jpg" alt="1711902909279" style="zoom: 38%;" /> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908857220.jpg" alt="1711908857220" style="zoom:35%;" /> $\large\xrightarrow{\text{R}×{\text{S}}}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908813683.jpg" alt="1711908813683" style="zoom:42%;" />   
> > >
> > >     - 筛选两同名列值相同的行，然后只保留其中一列。即为$\text{R}\bowtie{}\text{S}\equiv\text{R}\bowtie{_{\text{R.sid=S.sid}}}\text{S}$​ 
> > >
> > >         <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401054601363.png" alt="image-20240401054601363" style="zoom:46%;" /> $\large\xrightarrow{\text{R}\bowtie{\text{S}}}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711909823605.jpg" alt="1711909823605" style="zoom: 38%;" /> 
> > >
> > >  2. 注意事项：多个$\text{Column}$相同匹配时，`NATURAL JOIN`要多列相等
> > >
> > >     <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240616094428222.png" alt="image-20240616094428222" style="zoom: 25%;" /> 
> > >
> > >     即为$\text{R}\bowtie{}\text{S}\equiv\text{R}\bowtie{_{\text{R.sid=S.sid }\land{}\text{ R.bid=S.bid}}}\text{S}$ 
> > >
> > >  3. $\text{SQL: }$⚠️⚠️⚠️没有$\text{Column}$相同匹配时，`NATURAL JOIN`语句会被执行为$\text{Cross Product}$ 
> > >
> > >     ```sql
> > >     SELECT * FROM R NATURAL JOIN S
> > >     ```
> > >
> > >  **3️⃣**$\text{Equi Join:}$ 一种$\text{Inner Join}$的特殊情况，比如$\text{R}\bowtie_{\text{(S}_1\text{.sid=R}_2\text{.sid)}}\text{S}$​(条件是等式) 
> > >
> > >  <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401231354398.png" alt="image-20240401231354398" style="zoom:50%;" /> 
> > >
> > >  ```sql
> > >  SELECT * FROM R INNER JOIN S ON R.sid = S.sid;
> > >  ```
> >
> > ### $\textbf{1.3.3. Outer Join}: \textbf{Include Every Record}$ 
> >
> > > **1️⃣**概述
> > >
> > > |   $\textbf{Outer Join}$   | 操作                                                      |
> > > | :-----------------------: | :-------------------------------------------------------- |
> > > | $\text{Left Outer Join}$  | 保留左表中所有记录，右表中不匹配的用$\text{NULL}$代替     |
> > > | $\text{Right Outer Join}$ | 保留右表中所有记录，左表中不匹配的用$\text{NULL}$代替     |
> > > | $\text{Full Outer Join}$  | 保留左右两表中所有记录，两表中不匹配的用$\text{NULL}$代替 |
> > >
> > > **2️⃣**示意图：$\text{Left/Right/Full}$
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240519224425895.png" alt="image-20240519224425895" style="zoom:53%;" /> 
> > >
> > > **3️⃣**示例 
> > >
> > > | ==客户表==  | $\textbf{CID}$ | 属性$\textbf{1}$ | 属性$\textbf{2}$ | ==账户表==  | $\textbf{CID}$ | $\textbf{AID}$ | 属性$\textbf{3}$ |
> > > | :---------: | :------------: | :--------------: | :--------------: | :---------: | :------------: | :------------: | :--------------: |
> > > | $\text{\\}$ |   $\text{1}$   |   $\text{X1}$    |   $\text{Y1}$    | $\text{\\}$ |   $\text{1}$   |   $\text{1}$   |   $\text{Z1}$    |
> > > | $\text{\\}$ |   $\text{2}$   |   $\text{X2}$    |   $\text{Y2}$    | $\text{\\}$ |   $\text{1}$   |   $\text{2}$   |   $\text{Z2}$    |
> > > | $\text{\\}$ |   $\text{3}$   |   $\text{X3}$    |   $\text{Y3}$    | $\text{\\}$ |   $\text{2}$   |   $\text{3}$   |   $\text{Z3}$    |
> > > | $\text{\\}$ |  $\text{\\}$   |   $\text{\\}$    |   $\text{\\}$    | $\text{\\}$ |   $\text{4}$   |   $\text{4}$   |   $\text{Z4}$    |
> > >
> > > 1. $\text{Left Outer Join:}$ `Customer.CustomerID = 3`时有表无匹配，所以代之以$\text{NULL}$​​ 
> > >
> > >    ```sql
> > >     SELECT * FROM Customer LEFT OUTER JOIN Account
> > >    ON Customer.CustomerID = Account.CustomerID; -- 左外联，保留左表所有CustomerID
> > >    ```
> > > 
> > >    | $\textbf{CID}$ | 属性$\textbf{1}$ | 属性$\textbf{2}$ | $\textbf{AID}$ | 属性$\textbf{3}$ |
> > >    | :------------: | :--------------: | :--------------: | :------------: | :--------------: |
> > >    |   $\text{1}$   |   $\text{X1}$    |   $\text{Y1}$    |   $\text{1}$   |   $\text{Z1}$    |
> > >    |   $\text{1}$   |   $\text{X1}$    |   $\text{Y1}$    |   $\text{2}$   |   $\text{Z2}$    |
> > >    |   $\text{2}$   |   $\text{X2}$    |   $\text{Y2}$    |   $\text{3}$   |   $\text{Z3}$    |
> > >    |   $\text{3}$   |   $\text{X3}$    |   $\text{Y3}$    | $\text{NULL}$  |  $\text{NULL}$   |
> > > 
> > > 2. $\text{Right Outer Join:}$  `Account.CustomerID = 4`时有表无匹配，所以代之以$\text{NULL}$ 
> > >
> > >    ```sql
> > >     SELECT * FROM Customer RIGHT OUTER JOIN Account
> > >    ON Customer.CustomerID = Account.CustomerID; -- 右外联，保留右表所有CustomerID
> > >    ```
> > > 
> > >    | $\textbf{CID}$ | 属性$\textbf{1}$ | 属性$\textbf{2}$ | $\textbf{AID}$ | 属性$\textbf{3}$ |
> > >    | :------------: | :--------------: | :--------------: | :------------: | :--------------: |
> > >    |   $\text{1}$   |   $\text{X1}$    |   $\text{Y1}$    |   $\text{1}$   |   $\text{Z1}$    |
> > >    |   $\text{1}$   |   $\text{X1}$    |   $\text{Y1}$    |   $\text{2}$   |   $\text{Z2}$    |
> > >    |   $\text{2}$   |   $\text{X2}$    |   $\text{Y2}$    |   $\text{3}$   |   $\text{Z3}$    |
> > >    |   $\text{4}$   |  $\text{NULL}$   |  $\text{NULL}$   |   $\text{4}$   |   $\text{Z4}$    |
> > > 
> > > 3. $\text{Full Outer Join:}$ 也可以认为是$\text{Right Outer Join结果}\cup\text{Leftt Outer Join结果}$ 
> > >
> > >    ```sql
> > >     SELECT * FROM Customer FULL OUTER JOIN Account
> > >    ON Customer.CustomerID = Account.CustomerID; -- 全外联，保留两表所有CustomerID
> > >    ```
> > > 
> > >    | $\textbf{CID}$ | 属性$\textbf{1}$ | 属性$\textbf{2}$ | $\textbf{AID}$ | 属性$\textbf{3}$ |
> > >    | :------------: | :--------------: | :--------------: | :------------: | :--------------: |
> > >    |   $\text{1}$   |   $\text{X1}$    |   $\text{Y1}$    |   $\text{1}$   |   $\text{Z1}$    |
> > >    |   $\text{1}$   |   $\text{X1}$    |   $\text{Y1}$    |   $\text{2}$   |   $\text{Z2}$    |
> > >    |   $\text{2}$   |   $\text{X2}$    |   $\text{Y2}$    |   $\text{3}$   |   $\text{Z3}$    |
> > >    |   $\text{3}$   |   $\text{X3}$    |   $\text{Y3}$    | $\text{NULL}$  |  $\text{NULL}$   |
> > >    |   $\text{4}$   |  $\text{NULL}$   |  $\text{NULL}$   |   $\text{4}$   |   $\text{Z4}$    |
> >
> > ### $\textbf{1.3.4. }$复合$\textbf{Join}$ 
> >
> > > **1️⃣**示例的$\text{ABC}$表格
> > >
> > > | $\small\textbf{A}$ | $\small\textbf{AID}$ | $\small\textbf{AName}$ | $\small\textbf{B}$ | $\small\textbf{BID}$ | $\small\textbf{AID}$ | $\small\textbf{BName}$ | $\small\textbf{C}$ | $\small\textbf{CID}$ | $\small\textbf{CType}$ | $\small\textbf{BName}$ |
> > > | :----------------: | :------------------: | :--------------------: | :----------------: | :------------------: | :------------------: | :--------------------: | :----------------: | :------------------: | :--------------------: | :--------------------: |
> > > |    $\text{\\}$     |      $\text{1}$      |        `AName1`        |    $\text{\\}$     |     $\text{101}$     |      $\text{1}$      |        `BName1`        |    $\text{\\}$     |    $\text{1001}$     |        `CType1`        |        `BName2`        |
> > > |    $\text{\\}$     |      $\text{2}$      |        `AName2`        |    $\text{\\}$     |     $\text{102}$     |      $\text{1}$      |        `BName2`        |    $\text{\\}$     |    $\text{1002}$     |        `CType2`        |        `BName3`        |
> > > |    $\text{\\}$     |     $\text{\\}$      |      $\text{\\}$       |    $\text{\\}$     |     $\text{201}$     |      $\text{2}$      |        `BName3`        |    $\text{\\}$     |     $\text{\\}$      |      $\text{\\}$       |      $\text{\\}$       |
> > >
> > > **2️⃣**$\text{Inner Join}$ 
> > >
> > > ```sql
> > > A INNER JOIN B ON A.AID = B.AID
> > > ```
> > >
> > > | $\textbf{A.AID}$ | $\textbf{A.AName}$ | $\textbf{B.ID}$ | $\textbf{B.AID}$ | $\textbf{B.BName}$ |
> > > | :--------------: | :----------------: | :-------------: | :--------------: | :----------------: |
> > > |    $\text{1}$    |      `AName1`      |  $\text{101}$   |    $\text{1}$    |      `BName1`      |
> > > |    $\text{1}$    |      `AName1`      |  $\text{102}$   |    $\text{1}$    |      `BName2`      |
> > > |    $\text{2}$    |      `AName2`      |  $\text{201}$   |    $\text{2}$    |      `BName3`      |
> > >
> > > **2️⃣**复合$\text{Inner Join:}$ 拿上面那个$\text{Join}$的结果再去$\text{Join}$​ 
> > >
> > > ```sql
> > > A INNER JOIN B ON A.AID = B.AID INNER JOIN C ON B.BName = C.BName
> > > ```
> > >
> > > | $\small\textbf{A.AID}$ | $\small\textbf{A.AName}$ | $\small\textbf{B.ID}$ | $\small\textbf{B.AID}$ | $\small\textbf{B.BName}$ | $\small\textbf{C.CID}$ | $\small\textbf{C.CType}$ | $\small\textbf{C.BName}$ |
> > > | :--------------------: | :----------------------: | :-------------------: | :--------------------: | :----------------------: | :--------------------: | :----------------------: | :----------------------: |
> > > |       $\text{1}$       |         `AName1`         |     $\text{101}$      |       $\text{1}$       |         `BName2`         |     $\text{1001}$      |         `CType1`         |         `BName2`         |
> > > |       $\text{2}$       |         `AName2`         |     $\text{201}$      |       $\text{2}$       |         `BName3`         |     $\text{1002}$      |         `CType2`         |         `BName3`         |

# $\textbf{2. SQL Overview}$ 

> ## $\textbf{2.1. CRUD Commends}$ 
>
> > $\text{Create/Read/Update/Delete Commands}$ 
> >
> > | $\textbf{Command Type}$ |         功能          | $\textbf{Description}$                       |
> > | :---------------------: | :-------------------: | -------------------------------------------- |
> > |      $\text{DDL}$       |  $\text{Definition}$  | 定义并建立数据库                             |
> > |      $\text{DML}$       | $\text{Manipulation}$ | 维护并使用(查询)数据库，获取数据的价值与信息 |
> > |      $\text{DCL}$       |   $\text{Control}$    | 控制用户对数据的访问权                       |
> > |     $\text{Other}$      |     $\text{N/A}$      | 管理数据库                                   |
> >
> > ### $\textbf{2.1.1. DDL Commands: Set up DB}$​  
> >
> > > **1️⃣**创建表格操作`CREAT`，==其实也就是$\text{Implementation}$操作== 
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240520005817353.png" alt="image-20240520005817353" style="zoom:48%;" /> 
> > >
> > > ```sql
> > > -- 创建Customer表
> > > CREATE TABLE Customer (
> > >       CustomerID INT PRIMARY KEY,
> > >       CustFirstName VARCHAR(45)
> > > );
> > > -- 创建Account表
> > > CREATE TABLE Account (
> > >       -- 若表中现有最后一行ID是1001，插入的新ID自动变成1002
> > >       AccountID INT AUTO_INCREMENT PRIMARY KEY, 
> > >       -- 枚举数据类型，只允许账户号码为三者之一
> > >       AccountNumber ENUM('Num1', 'Num2', 'Num3');
> > >       Customer_CustomerID INT,
> > >       FOREIGN KEY (Customer_CustomerID) REFERENCES Customer(CustomerID)
> > > );
> > > ```
> > >
> > > 1. 关于$\text{Key}$
> > >    - 要用`PRIMARY KEY`指定哪个变量时主键
> > >    - 要用`FOREIGN KEY REFERENCES`指定$\text{Foreign Key}$引用的哪个变量，==否则会$\text{Syntax Error}$==
> > > 2. 补充事项
> > >    - `AUTO_INCREMENT`: 用来标记主键字段，插入一个记录后被标记字段自动$\text{+1}$​ 
> > >    - `ENUM`: 枚举数据类型类型，只允许属性为预设值
> > >
> > > **2️⃣**修改表格系列操作
> > >
> > > |                    操作                    | 关键字                                        |
> > > | :----------------------------------------: | :-------------------------------------------- |
> > > |       增加表格的$\text{Attributes}$        | `ALTER TABLE <表名> ADD <属性名> <属性类型> ` |
> > > |       减少表格的$\text{Attributes}$        | `ALTER TABLE <表名> DROP <属性名>`            |
> > > |                 表格重命名                 | `RENAME TABLE  <旧表名> TO <新表名>`          |
> > > | 快速清空表格记录($\text{Can't Roll Back}$) | `TRUNCATE TABLE <表名> `                      |
> > > |  慢速清空表格记录($\text{Can Roll Back}$)  | `DELETE * FROM <表名>`                        |
> > > |           彻底删除(杀死)一个表格           | `DROP * FROM <表名>`                          |
> > >
> > > ```sql
> > > -- 添加属性: 客户表中添加CustLastName属性
> > > ALTER TABLE Customer ADD CustLastName VARCHAR(45); 
> > > -- 减少属性: 账户表中删除AccountNumber属性
> > > ALTER TABLE Account DROP AccountNumber;   
> > > -- 重命名: 将Customer表重命名为NewCustomers
> > > RENAME TABLE Customer TO NewCustomers 
> > > -- 快速清空表记录: 清空所有客户的数据，不回退
> > > TRUNCATE TABLE Customer
> > > -- 慢速清空表记录: 清空所有客户的数据，可回退
> > > DELETE * FROM  Customer
> > > -- 彻底删除表格: 把客户表的数据/客户表都根除
> > > DROP TABLE Customer
> > > ```
> > >
> > > **3️⃣**查看表格操作: `VIEW` 视图，只是一种虚拟表(不存储在内存中)
> > >
> > > ```sql
> > > -- 创建虚拟表格CustomerAccountView视图
> > > CREATE VIEW CustomerAccountView AS
> > > SELECT Customer.CustomerID, Account.AccountNumber
> > > FROM Customer JOIN Account 
> > > ON Customer.CustomerID = Account.Customer_CustomerID;
> > > 
> > > -- 通过视图来查询数据，就像查询普通表格一样，简化了查询
> > > SELECT * FROM CustomerAccountView;
> > > ```
> >
> > ### $\textbf{2.1.2. DCL Commands:}$ 用户与权限
> >
> > > **1️⃣**创建/删除用户: `CREATE USER/DROP USER`
> > >
> > > ```sql
> > > -- 创建用户，初始密码为123
> > > CREATE USER 'john'@'localhost' IDENTIFIED BY '123';
> > > -- 删除john用户
> > > DROP USER 'john'@'localhost';
> > > ```
> > >
> > > **2️⃣**分配/撤销用户权限: `GRANT / REVOKE`
> > >
> > > ```sql
> > > -- 授予john在mydatabase数据库Table1表的SELECT和INSERT权限
> > > GRANT SELECT,INSERT ON mydatabase.Table1 TO 'john'@'localhost';
> > > -- 撤销john在mydatabase数据库Table1表的INSERT权限
> > > REVOKE INSERT ON mydatabase.Table1 FROM 'john'@'localhost';
> > > ```
> > >
> > > **3️⃣**设置密码: `SET PASSWORD`
> > >
> > > ```sql
> > > -- 设置新密码为0123
> > > SET PASSWORD FOR 'john'@'localhost' = PASSWORD('0123');
> > > ```
> >
> >
> > ### $\textbf{2.1.3. Other: Database Administration}$ 
> >
> > > **1️⃣**意外删除的恢复: `BACKUP TABLE/RESTORE TABLE`(二者其实并非标准$\text{SQL}$​命令)
> > >
> > > **2️⃣**展示表格模式($\text{Scheme}$): `DESCRIBE <表名>` 
> > >
> > > ```sql
> > > CREATE TABLE Customer (
> > >       CustomerID INT AUTO_INCREMENT PRIMARY KEY,
> > >       CustFirstName VARCHAR(45),
> > >       DateOfBirth DATE
> > > );
> > > -- 查看Customer表的结构，结果如下表
> > > DESCRIBE Customer
> > > ```
> > >
> > > |    $\textbf{Field}$    |   $\textbf{Type}$    | $\textbf{Null}$ | $\textbf{Key}$ | $\textbf{Default}$ |     $\textbf{Extra}$     |
> > > | :--------------------: | :------------------: | :-------------: | :------------: | :----------------: | :----------------------: |
> > > |  $\text{CustomerID}$   |     $\text{INT}$     |   $\text{NO}$   |  $\text{PRI}$  |   $\text{NULL}$    | $\text{auto\_increment}$ |
> > > | $\text{CustFirstName}$ | $\text{VARCHAR(45)}$ |  $\text{YES}$   |                |   $\text{NULL}$    |                          |
> > > |  $\text{DateOfBirth}$  |    $\text{DATE}$     |  $\text{YES}$   |                |   $\text{NULL}$    |                          |
> > >
> > > **3️⃣**`USE <db_name>`: 挑选进入哪个数据库来操作
>
> ## $\textbf{2.2. SQL}$ 语法特点(大小写问题)
>
> > **1️⃣**$\text{SQL}$​的属性名大小/关键词写不敏感($\text{Case Inseneitive}$)，但一般大写。如下两段查询含义相同
> >
> > ```sql
> > SELECT * FROM Furniture WHERE 
> > (Type = 'Chair' AND Colour = 'Black') OR (Type = 'Lamp' AND Colour = 'Black');
> > select * from furniture where 
> > (type = 'Chair' and colour = 'Black') or (type = 'Lamp' and colour = 'Black');
> > ```
> >
> > **3️⃣**$\text{SQL}$的表名区分大小写

# $\textbf{3. SQL Core: DML Commands}$  

> ## $\textbf{3.1. }$变更表中内容
>
> > ### $\textbf{3.1.1. Insert Data:}$ `Insert Into` 
> >
> > > **0️⃣**示例表格
> > >
> > > | $\textbf{CustID}$ | $\textbf{FirstName}$ | $\textbf{MiddleName}$ | $\textbf{LastName}$ | $\textbf{BusinessName}$ | $\textbf{CustType}$ |
> > > | :---------------: | :------------------: | :-------------------: | :-----------------: | :---------------------: | :-----------------: |
> > > |    $\text{1}$     |    $\text{Peter}$    |     $\text{NULL}$     |   $\text{Smith}$    |      $\text{NULL}$      |  $\text{Personal}$  |
> > > |    $\text{2}$     |    $\text{James}$    |     $\text{NULL}$     |   $\text{Jones}$    |       $\text{JJ}$       |  $\text{Company}$   |
> > > |    $\text{3}$     |    $\text{NULL}$     |     $\text{NULL}$     |   $\text{Smythe}$   |      $\text{NULL}$      |  $\text{Company}$   |
> > >
> > > **1️⃣**显式插入：指名要给哪几个属性插入数据
> > >
> > > ```sql
> > > -- 一次性可以插入一条数据
> > > INSERT INTO Customer (FirstName, LastName, CustType) VALUES 
> > > ("Peter", "Smith", 'Personal');
> > > 
> > > -- 也可以多条
> > > INSERT INTO Customer (FirstName, LastName, CustType) VALUES 
> > > ("Peter" , "Smith" , 'Personal'),
> > > ("Jamnes", "Jones" , 'Company' ),
> > > (""      , "Smythe", 'Company' );
> > > ```
> > >
> > > **2️⃣**隐式插入：省略具体的属性，将提供的值按顺序依次插入属性
> > >
> > > ```sql
> > > -- 插入第一条数据，DEFAULT子句会让CustID从0开始自动+1(此处+1后CustID=1)
> > > INSERT INTO Customer VALUES 
> > > (DEFAULT, "Peter", "", "Smith", "", 'Personal');
> > > 
> > > -- 一次性插入多条数据
> > > INSERT INTO Customer VALUES  
> > > (DEFAULT, "Peter", ""  , "Smith" , ""  , 'Personal');
> > > (DEFAULT, "James", NULL, "Jones" , "JJ", 'Company' );
> > > (DEFAULT, ""     , NULL, "Smythe", ""  , 'Company' );
> > > ```
> > >
> > > **3️⃣**从其他表格插入数据
> > >
> > > ```sql
> > > -- 将所有Customer中的记录，全部插入NewCustomer中
> > > INSERT INTO NewCustomer SELECT * FROM Customer;
> > > ```
> > >
> > > 👽`REPLACE`和`INSERT`功能几乎一致，区别仅仅在于，当待插入记录的$\text{PK}\xleftrightarrow[冲突]{相同}$已存在记录的$\text{PK}$ 
> > >
> > > 1. `INSERT`：操作费费，插入失败
> > > 2. `REPLACE`：操作合法，并且待插入记录覆盖冲突的已存在记录
> >
> > ### $\textbf{3.1.2. Changes Existing Data:}$ `UPDATESET` 结构
> >
> > > **1️⃣**`UPDATE` 示例
> > >
> > > ```sql
> > > -- Block1: 所有薪水小于100000的涨薪5%
> > > UPDATE Salaried SET AnnualSalary = AnnualSalary * 1.05
> > > WHERE AnnualSalary <= 100000;
> > > -- Block2: 所有薪水大于100000的涨薪10%
> > > UPDATE Salaried SET AnnualSalary = AnnualSalary * 1.10
> > > WHERE AnnualSalary > 100000;
> > > ```
> > >
> > > 1. 子句执行的顺序会影响结果
> > > 2. 没有`WHERE`子句时，更新会应用到表格的每一行
> > >
> > > **2️⃣**`CASE` $\text{Command}$​优化示例
> > >
> > > ```sql
> > > UPDATE Salaried SET AnnualSalary = 
> > > CASE 
> > >     WHEN AnnualSalary <= 100000 THEN AnnualSalary * 1.05
> > >     ELSE AnnualSalary * 1.10    
> > > END;
> > > ```
> > > 
> >
> > ### $\textbf{3.1.3. Deleting Existing Data:}$ `DELETE`
> >
> > > **1️⃣**简答例子
> > >
> > > ```sql
> > > -- 删除表中所有记录，危险操作
> > > DELETE FROM Employee
> > > -- 删除表中满足条件的操作
> > > DELETE FROM Employee WHERE Name = "Grace"
> > > ```
> > >
> > > **2️⃣**删除的外键约束
> > >
> > > |       约束子句       |         尝试操作         |                   执行操作                   |
> > > | :------------------: | :----------------------: | :------------------------------------------: |
> > > | `ON DELETE CASCADE ` | $\text{A}$表尝试删除一行 | 操作总被允许，引用该行的$\text{B}$表行都删除 |
> > > | `ON DELETE RESTRICT` | $\text{A}$表尝试删除一行 | 如果改行被$\text{B}$表引用，则删除操作被禁止 |
> > >
> > > ```sql
> > > CREATE TABLE B (
> > >       Bid INT PRIMARY KEY,
> > >       Bname VARCHAR(50),
> > >       Aid INT,
> > >       FOREIGN KEY (Aid) REFERENCES A(Aid) ON DELETE CASCADE
> > >       FOREIGN KEY (Aid) REFERENCES A(Aid) ON DELETE RESTRICT  -- 二选一
> > > );
> > > ```
>
> ## $\textbf{3.2. }$​查询表中内容: `SELECT FROM + XXX`
>
> > ### $\textbf{3.2.1. }$​`SELECT`有关结构
> >
> > > **1️⃣**最基本结构：
> > >
> > > 1. 投影，原理详见关系代数
> > >
> > >    ```sql
> > >    SELECT * FROM Student; -- 选中所有列, Heap Scan
> > >    SELECT age FROM Student; -- 选中年龄这一列，但是SQL操作中默认不去除重复项
> > >    ```
> > >
> > > 2. 关于`DISTINCT`，其后所有属性都要删除重复项
> > >
> > >    ```sql
> > >    SELECT DISTINCT age FROM Student; -- 选中年龄这一列，删除重复项
> > >    SELECT DISTINCT age,name FROM Student; -- 年龄+姓名的组合要DISTINCT,删除重复项
> > >    ```
> > >
> > > **2️⃣**聚合函数$\text{Aggregare Function}$​ 
> > >
> > > 1. 概述
> > >
> > >    | $\textbf{Function}$ |     $\textbf{Description}$      |
> > >    | :-----------------: | :-----------------------------: |
> > >    |       `AVG()`       |     $\text{Average Value}$      |
> > >    |       `MIN()`       |     $\text{Minimum Value}$      |
> > >    |       `MAX()`       |     $\text{Maximum Value}$      |
> > >    |      `COUNT()`      | $\text{Number of Values}$(行数) |
> > >    |       `SUM()`       |     $\text{Sum of Values}$      |
> > >
> > > 2. 示例
> > >
> > >    | $\textbf{CustomerID}$ | $\textbf{AccountID}$ | $\textbf{Balance}$ |
> > >    | :-------------------: | :------------------: | :----------------: |
> > >    |      $\text{1}$       |      $\text{1}$      |    $\text{200}$    |
> > >    |      $\text{1}$       |      $\text{2}$      |    $\text{100}$    |
> > >    |      $\text{2}$       |      $\text{1}$      |    $\text{400}$    |
> > >    |      $\text{3}$       |      $\text{1}$      |    $\text{300}$    |
> > >
> > >    - `COUNT`示例
> > >
> > >      ```sql
> > >      SELECT COUNT(*) FROM Customer; -- 表中有多少Tuples
> > >      SELECT COUNT(CustomerID) FROM Customer; -- 多少个CustomerID
> > >      SELECT COUNT(DISTINCT CustomerID) FROM Customer; -- 多少个Uniqe的ID
> > >      ```
> > >
> > >      | $\textbf{COUNT(CustomerID)}$ |  \   | $\textbf{COUNT(DISTINCT CustomerID)}$ |
> > >      | :--------------------------: | :--: | :-----------------------------------: |
> > >      |          $\text{4}$          |  \   |              $\text{3}$               |
> > >
> > >    - `AVG/MAX/MAX`示例   
> > >
> > >      ```sql
> > >      SELECT AVG(Balance) FROM Account; -- 所有账户余额的平均
> > >      SELECT MAX(Balance) FROM Account WHERE CustomerID=1; -- 用户1最高账户余额
> > >      SELECT SUM(Balance) FROM Account GROUP BY CustomerID; -- 各用户账户总余额
> > >      ```
> > >
> > >      | $\textbf{AVG(Balance)}$ | $\text{\\}$ | $\textbf{MAX(Balance)}$ | $\text{\\}$ | $\textbf{SUM(Balance)}$ |
> > >      | :---------------------: | :---------: | :---------------------: | :---------: | :---------------------: |
> > >      |      $\text{250}$       | $\text{\\}$ |      $\text{200}$       | $\text{\\}$ |      $\text{300}$       |
> > >      |       $\text{\\}$       | $\text{\\}$ |       $\text{\\}$       | $\text{\\}$ |      $\text{400}$       |
> > >      |       $\text{\\}$       | $\text{\\}$ |       $\text{\\}$       | $\text{\\}$ |      $\text{300}$       |
> > >
> > > 3. `SUM()`补充：
> > >
> > >    - 当用于数值类型属性时，会遍历每行求出并返回总和
> > >    - 当用于布尔类型属性时，会遍历每行(布尔真$\text{=1/}$布尔假$\text{=0}$)，返回总和
> > >
> > > **3️⃣**重命名子句`AS` $\text{Clause}$ 
> > >
> > > ```sql
> > > SELECT CustType, COUNT(CustomerID) FROM Customer -- 不重命名
> > > SELECT CustType, COUNT(CustomerID) AS Count FROM Customer -- 重命名为Count
> > > ```
> > >
> > > |  不重命名   | $\textbf{CustType}$ | $\textbf{Count(CustomerID)}$ |   重命名    | $\textbf{CustType}$ | $\textbf{Count}$ |
> > > | :---------: | :-----------------: | :--------------------------: | :---------: | :-----------------: | :--------------: |
> > > | $\text{\\}$ |   $\text{Type1}$    |          $\text{3}$          | $\text{\\}$ |   $\text{Type1}$    |    $\text{3}$    |
> > > | $\text{\\}$ |   $\text{Type2}$    |          $\text{6}$          | $\text{\\}$ |   $\text{Type2}$    |    $\text{6}$    |
> > >
> > > :four:合并列子句`CONCAT`: 将两个不同的列，合并为一列
> > >
> > > ```sql
> > > SELECT CONCAT(FirstName, LastName) AS FullName
> > > FROM Name
> > > ```
> >
> > ### $\textbf{3.2.2. }$`FROM`有关结构
> >
> > > **1️⃣**最基本功能：选定要操作的表格
> > >
> > > ```sql
> > > SELECT * FROM R
> > > ```
> > >
> > > **2️⃣**跨表格操作：$\text{Cross-Product/Join}$，==原理详见关系代数部分==
> > >
> > > 1. $\text{Cross-Product}$​ 
> > >
> > >    ```sql
> > >    SELECT * FROM R, S;	-- Cross product between R, S
> > >    ```
> > >
> > > 2. $\text{Join}$ 
> > >
> > >    ```sql
> > >    SELECT * FROM R NATURAL JOIN S -- Nature Join
> > >                                                                                                       
> > >    SELECT * FROM R INNER JOIN S ON R.sid < S.sid; -- Inner Join
> > >    SELECT * FROM R INNER JOIN S ON R.sid = S.sid; -- Equi Join
> > >                                                                                                       
> > >    SELECT * FROM R LEFT OUTER JOIN S ON R.sid = S.sid;  -- Left Outer Join 
> > >    SELECT * FROM R RIGHT OUTER JOIN S ON R.sid = S.sid; -- Right Outer Join 
> > >    SELECT * FROM R FULL OUTER JOIN S ON R.sid = S.sid;  -- Full Outer Join 
> > >    ```
> > >
> >
> > ### $\textbf{3.2.3. }$`+XXX`有关结构
> >
> > > #### $\textbf{3.2.3.1. }$`WHERE` 有关结构
> > >
> > > > **1️⃣**`WHERE` $\text{Clause:}$ 本是上是一种$\text{Selection}$​操作，过滤满足条件
> > > >
> > > > ```sql
> > > > SELECT * FROM Student WHERE Student.rating >= 9;
> > > > ```
> > > >
> > > > **2️⃣**`LIKE` $\text{Clause:}$​​ 与`WHERE`配合使用，实现字符串的匹配==(约等于)== 
> > > >
> > > > 1. 匹配的关键字
> > > >
> > > >    | $\textbf{1}$个不确定的字符 | $\textbf{0-M}$个不确定的字符 |
> > > >    | :------------------------: | :--------------------------: |
> > > >    |      ==$\text{\_}$==       |       ==$\text{\%}$==        |
> > > >
> > > > 2. 匹配子句示例
> > > >
> > > >    | $\textbf{Clause}$                 | `CustomerName` $\textbf{Maches}$ |    示例    |
> > > >    | :-------------------------------- | :------------------------------: | :--------: |
> > > >    | `WHERE CustomerName LIKE 'a%'`    |        以$\text{a}$开始的        |  `axxxxx`  |
> > > >    | `WHERE CustomerName LIKE '%a'`    |        以$\text{a}$结束的        |  `xxxxxa`  |
> > > >    | `WHERE CustomerName LIKE '%a%'`   |         包含$\text{a}$的         |  `xxaxxx`  |
> > > >    | `WHERE CustomerName LIKE '_a%'`   |       $\text{a}$在第二位的       |  `xaxxxx`  |
> > > >    | `WHERE CustomerName LIKE 'a_%_%'` |  以$\text{a}$开始，后至少两字符  | `axx/axxx` |
> > > >    | `WHERE CustomerName LIKE 'a%o'`   |  以$\text{a}$开始$\text{o}$结尾  |  `axxxxo`  |
> > > >
> > > > 3. $\text{SQL}$示例
> > > >
> > > >    ```sql
> > > >    SELECT CustLastName FROM Customer WHERE CustLastName LIKE "Sm%"
> > > >    -- 匹配的会有Smith/Smyth/Smize......
> > > >    ```
> > >
> > > #### $\textbf{3.2.3.2. }$`GROUP BY`有关结构
> > >
> > > > **1️⃣**`GROUP BY` $\text{Clause:}$​ 
> > > >
> > > > 1. 讲记录根据一个/多个属性，分为若干小组
> > > >
> > > > 2. 通常和聚合函数结合使用，为每个小组计算出独立结果
> > > >
> > > > 3. 示例
> > > >
> > > >    ```sql
> > > >    SELECT CustID, AVG(Balance) AS AveBalance
> > > >    FROM Account
> > > >    GROUP BY CustID;
> > > >    ```
> > > >
> > > >    | $\textbf{CustID}$ | $\textbf{Account}$ | $\textbf{Balance}$ | $\xrightarrow[查询]{结果}$ | $\textbf{CustID}$ | $\textbf{AveBalance}$ |
> > > >    | :---------------: | :----------------: | :----------------: | :------------------------: | :---------------: | :-------------------: |
> > > >    |    $\text{1}$     |    $\text{101}$    |    $\text{500}$    |        $\text{\\}$         |    $\text{1}$     |     $\text{325}$      |
> > > >    |    $\text{1}$     |    $\text{102}$    |    $\text{150}$    |        $\text{\\}$         |    $\text{2}$     |     $\text{250}$      |
> > > >    |    $\text{2}$     |    $\text{103}$    |    $\text{200}$    |        $\text{\\}$         |    $\text{3}$     |     $\text{450}$      |
> > > >    |    $\text{2}$     |    $\text{104}$    |    $\text{300}$    |        $\text{\\}$         |    $\text{\\}$    |      $\text{\\}$      |
> > > >    |    $\text{3}$     |    $\text{105}$    |    $\text{450}$    |        $\text{\\}$         |    $\text{\\}$    |      $\text{\\}$      |
> > > >
> > > > 4. 复杂一些的例子：`GROUP BY <复合属性>`  
> > > >
> > > >    ```sql
> > > >    SELECT Subject, Semester, COUNT(*) FROM Example_Table
> > > >    GROUP BY Subject, Semester; -- Subject, Semester都相同才能分为一类
> > > >    ```
> > > >
> > > >    | $\small\textbf{Subject}$ | $\small\textbf{Semester}$ | $\small\textbf{Attendee}$ | $\xrightarrow[查询]{结果}$ | $\small\textbf{Subject}$ | $\small\textbf{Semester}$ | $\small\textbf{COUNT(*)}$ |
> > > >    | :----------------------: | :-----------------------: | :-----------------------: | :------------------------: | :----------------------: | :-----------------------: | :-----------------------: |
> > > >    |  $\small\text{ITB001}$   |        $\text{1}$         |    $\small\text{John}$    |        $\text{\\}$         |  $\small\text{ITB001}$   |        $\text{1}$         |        $\text{3}$         |
> > > >    |  $\small\text{ITB001}$   |        $\text{1}$         |    $\small\text{Bob}$     |        $\text{\\}$         |  $\small\text{ITB001}$   |        $\text{2}$         |        $\text{2}$         |
> > > >    |  $\small\text{ITB001}$   |        $\text{1}$         |   $\small\text{Mickey}$   |        $\text{\\}$         |  $\small\text{IMK114}$   |        $\text{1}$         |        $\text{2}$         |
> > > >    |  $\small\text{ITB001}$   |        $\text{2}$         |   $\small\text{Jenny}$    |        $\text{\\}$         |       $\text{\\}$        |        $\text{\\}$        |        $\text{\\}$        |
> > > >    |  $\small\text{ITB001}$   |        $\text{2}$         |   $\small\text{James}$    |        $\text{\\}$         |       $\text{\\}$        |        $\text{\\}$        |        $\text{\\}$        |
> > > >    |  $\small\text{IMK114}$   |        $\text{1}$         |    $\small\text{John}$    |        $\text{\\}$         |       $\text{\\}$        |        $\text{\\}$        |        $\text{\\}$        |
> > > >    |  $\small\text{IMK114}$   |        $\text{1}$         |   $\small\text{Erica}$    |        $\text{\\}$         |       $\text{\\}$        |        $\text{\\}$        |        $\text{\\}$        |
> > > >
> > > > **2️⃣**`HAVING` $\text{Clause:}$ 适用于`GROUP BY`体质的`WHERE`，==只能和`GROUP BY`一起出现== 
> > > >
> > > > 1. 作用：作为聚合函数的补充，用于筛选`GROUP BY`出来的组
> > > >
> > > > 2. 对比：
> > > >
> > > >    |     `HAVING` $\textbf{Clause}$     |  `WHERE` $\textbf{Clause}$   |
> > > >    | :--------------------------------: | :--------------------------: |
> > > >    | 后接关系$\text{Attribute}$有关条件 | 后接聚合函数(数结)果有关条件 |
> > > >
> > > > 3. 示例：注意区分`WHERE`和`HAVING`
> > > >
> > > >    | $\textbf{CustID}$ | $\textbf{Account}$ | $\textbf{Balance}$ |
> > > >    | :---------------: | :----------------: | :----------------: |
> > > >    |    $\text{1}$     |    $\text{101}$    |    $\text{500}$    |
> > > >    |    $\text{1}$     |    $\text{102}$    |    $\text{150}$    |
> > > >    |    $\text{2}$     |    $\text{103}$    |    $\text{200}$    |
> > > >    |    $\text{2}$     |    $\text{104}$    |    $\text{300}$    |
> > > >    |    $\text{3}$     |    $\text{105}$    |    $\text{450}$    |
> > > >
> > > >    - `WHERE <条件表达式>`：直接过滤原始的数据(过滤数据)
> > > >
> > > >      ```sql
> > > >      SELECT CustID, Balance FROM Customer WHERE Balance > 400;
> > > >      ```
> > > >
> > > >    - `HAVING <条件表达式>`：对分组的结果进行过滤(过滤组)
> > > >
> > > >      |    查询     | $\small\textbf{CustID}$ | $\small\textbf{AveBalance}$ | `HAVING`后  | $\small\textbf{CustID}$ | $\small\textbf{AveBalance}$ |
> > > >      | :---------: | :---------------------: | :-------------------------: | :---------: | :---------------------: | :-------------------------: |
> > > >      | $\text{\\}$ |       $\text{1}$        |        $\text{325}$         | $\text{\\}$ |       $\text{1}$        |        $\text{325}$         |
> > > >      | $\text{\\}$ |       $\text{2}$        |        $\text{250}$         | $\text{\\}$ |       $\text{3}$        |        $\text{450}$         |
> > > >      | $\text{\\}$ |       $\text{3}$        |        $\text{450}$         | $\text{\\}$ |       $\text{\\}$       |         $\text{\\}$         |
> > > >
> > > >      ```sql
> > > >      SELECT CustID, AVG(Balance) AS AveBalance FROM Account
> > > >      GROUP BY CustID HAVING AveBalance > 300;
> > > >      ```
> > > >
> > >
> > > #### $\textbf{3.2.3.3. }$`ORDER BY` 有关结构
> > >
> > > > **1️⃣**`ORDER BY` $\text{Clause:}$ 
> > > >
> > > > 1. 将查询得到的结果按照某一属性排序
> > > >
> > > >    ```sql
> > > >    SELECT Name, Type FROM Customer ORDER BY Name; -- 按名字(字典序)默认升序
> > > >    SELECT Name, Type FROM Customer ORDER BY Name ASC;  -- 升序
> > > >    SELECT Name, Type FROM Customer ORDER BY Name DESC; -- 降序
> > > >    ```
> > > >
> > > > 2. 将查询得到的结果按照符合属性排序
> > > >
> > > >    ```sql
> > > >    SELECT Name, Type FROM Customer
> > > >    ORDER BY Name DESC, Type ASC;
> > > >     -- 先按Name降序排序
> > > >     -- 再对于Name相同的Tuple，按照Type升序排序
> > > >    ```
> > > >
> > > > **2️⃣**`LIMIT/OFFSET` $\text{Clause:}$​ 
> > > >
> > > > 1. 含义
> > > >
> > > >    | $\textbf{Clause}$  |                             功能                             |
> > > >    | :----------------: | :----------------------------------------------------------: |
> > > >    |     `LIMIT N`      | <span style="color: red;">选取排序结果的前$\text{N}$个</span> |
> > > >    |     `OFFSET M`     |                   跳过$\text{M}$个排序结果                   |
> > > >    | `LIMIT N OFFSET M` | <font color='grenn'>跳过排序结果的前$\text{M}$个，依次选取后面的$\text{N}$个</font> |
> > > >
> > > > 2. 示例：
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/40817826335.png" alt="40817826335" style="zoom:25%;" /> 
> > > >
> > > >    ```sql
> > > >    SELECT Name, Type FROM Customer ORDER BY Name LIMIT 5; -- 红色
> > > >    SELECT Name, Type FROM Customer ORDER BY Name LIMIT 5 OFFSET 3; -- 绿色
> > > >    ```
>
> ## $\textbf{3.3. }$查询表中内容: $\textbf{Sub/Nesting Query}$ 
>
> > ### $\textbf{3.3.1. Subquery}$结构
> >
> > > **0️⃣**概述
> > >
> > > 1. `SELECT`结构相当于一个查询，在一个`SELECT`中插入另一个`SELECT`，则后者就是前者子查询
> > > 2. 执行顺序：先执行子查询$\to{}$将子查询结果传给主查询$\to{}$​执行主查询
> > > 3. 相关子查询：子查询可以直接使用主(外层)查询的列/值
> > >
> > > **1️⃣**在`SELECT`字句中插入子查询，==一般使用`AS`重命名子查询返回的列==
> > >
> > > ```sql
> > > SELECT 
> > >     name,
> > >     (SELECT COUNT(*) FROM orders) AS order_count
> > > FROM customers;
> > > ```
> > >
> > > **2️⃣**在`FROM`字句中插入子查询，==子查询此时相当于一个临时表，所以<span style="color: red;">**必须**</span>使用`AS`重命名==
> > >
> > > ```sql
> > > SELECT tmp.average_sales
> > > FROM  (SELECT AVG(amount) AS average_sales FROM sales) AS tmp;
> > > ```
> > >
> > > **3️⃣**在`WHERE`子句中
> > >
> > > ```sql
> > > SELECT name, age
> > > FROM employees
> > > WHERE salary > (SELECT AVG(salary) FROM employees);
> > > ```
> > >
> > > **4️⃣**在`EXISTS`中，返回布尔值的特殊类子查询
> > >
> > > ```sql
> > > SELECT name
> > > FROM products
> > > WHERE EXISTS (SELECT 1 FROM inventory WHERE inventory.quantity > 0);
> > > ```
> >
> > ### $\textbf{3.3.2. Subquery}$有关子句
> >
> > > **0️⃣**示例表格
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240402032453333.png" alt="image-20240402032453333" style="zoom:33%;" /> 
> > >
> > > 1. $\text{Artefact/Seller/Buyer}$表
> > >
> > >    | $\small\textbf{AID}$ | $\small\textbf{Name}$ |       $描述$       | $\small\text{\\}$ | $\small\textbf{SID}$ | $\small\text{Name}$ | $\small\textbf{Phone}$ | $\small\text{\\}$ | $\small\textbf{BID}$ | $\small\textbf{Name}$ |       $电话$        |
> > >    | :------------------: | :-------------------: | :----------------: | :---------------: | :------------------: | :-----------------: | :--------------------: | :---------------: | :------------------: | :-------------------: | :-----------------: |
> > >    |   $\small\text{1}$   |  $\small\text{Vase}$  | $\small\text{Old}$ | $\small\text{\\}$ |   $\small\text{1}$   | $\small\text{Abby}$ |  $\small\text{0232}$   | $\small\text{\\}$ |   $\small\text{1}$   |  $\small\text{Magg}$  | $\small\text{0333}$ |
> > >    |   $\small\text{2}$   | $\small\text{Knife}$  | $\small\text{Old}$ | $\small\text{\\}$ |   $\small\text{2}$   | $\small\text{Ben}$  |  $\small\text{0311}$   | $\small\text{\\}$ |   $\small\text{2}$   | $\small\text{Nicole}$ | $\small\text{0444}$ |
> > >    |   $\small\text{3}$   |  $\small\text{Pot}$   | $\small\text{Old}$ | $\small\text{\\}$ |   $\small\text{3}$   | $\small\text{Carl}$ |  $\small\text{0333}$   | $\small\text{\\}$ |   $\small\text{3}$   |  $\small\text{Oleg}$  | $\small\text{0555}$ |
> > >
> > > 2. $\text{Offer}$表
> > >
> > >    | $\small\textbf{AID}$ | $\small\textbf{SID}$ | $\small\textbf{BID}$ |   $\small\textbf{Date}$   | $\small\textbf{Amount}$ | $\small\textbf{Acceptance}$ |
> > >    | :------------------: | :------------------: | :------------------: | :-----------------------: | :---------------------: | :-------------------------: |
> > >    |   $\small\text{1}$   |   $\small\text{1}$   |   $\small\text{1}$   | $\small\text{2012-06-20}$ | $\small\text{81223.23}$ |      $\small\text{N}$       |
> > >    |   $\small\text{1}$   |   $\small\text{1}$   |   $\small\text{2}$   | $\small\text{2012-06-20}$ | $\small\text{82223.23}$ |      $\small\text{N}$       |
> > >    |   $\small\text{1}$   |   $\small\text{2}$   |   $\small\text{1}$   | $\small\text{2012-06-20}$ |  $\small\text{19.95}$   |      $\small\text{N}$       |
> > >    |   $\small\text{2}$   |   $\small\text{2}$   |   $\small\text{2}$   | $\small\text{2012-06-20}$ |  $\small\text{23.00}$   |      $\small\text{N}$       |
> > >
> > > **1️⃣**`IN/NOT IN` $\text{Clause:}$​  记录是否在子查询的结果中
> > >
> > > ```sql
> > > SELECT * FROM Buyer
> > > WHERE BID IN (SELECT BID FROM Offer WHERE AID = 1)
> > > ```
> > >
> > > 1. 子查询结果：`BuyerID = 1/2`，主查询结果
> > >
> > >    | $\textbf{BID}$ |  $\textbf{Name}$  | $\textbf{Phone}$ |
> > >    | :----------: | :-------------: | :------------: |
> > >    |  $\text{1}$  |  $\text{Magg}$  | $\text{0333}$  |
> > >    |  $\text{2}$  | $\text{Nicole}$ | $\text{0444}$   |
> > >
> > > 2. 基于$\text{Join}$的优化：执行的效率会更高
> > >
> > >    ```sql
> > >    ELECT Buyer.*
> > >    FROM Buyer JOIN Offer ON Buyer.BID = Offer.BID
> > >    WHERE Offer.AID = 1;
> > >    ```
> > >
> > > **2️⃣**`ANY/ALL/EXISTS`
> > >
> > > 1. `ANY`：满足至少一个内部条件，==实际上可以把所有的`IN`改为`=ANY`(至少一个等于)==
> > >
> > >    ```sql
> > >    SELECT empno, sal FROM emp
> > >    WHERE sal > ANY (SELECT....返回:Tuple1, Tuple2, Tuple3);
> > >
> > >    -- equals to
> > >    SELECT empno, sal FROM emp
> > >    WHERE sal > Tuple1 OR sal > Tuple2 OR sal> Tuple3;
> > >    ```
> > >
> > > 2. `ALL`：满足所有内部条件
> > >
> > >    ```sql
> > >    SELECT empno, sal FROM emp
> > >    WHERE sal > ALL (SELECT....返回:Tuple1, Tuple2, Tuple3);
> > >                         
> > >    -- equals to
> > >    SELECT empno, sal FROM emp
> > >    WHERE sal > Tuple1 AND sal > Tuple2 AND sal> Tuple3;
> > >    ```
> > >
> > > **3️⃣**`EXISIS`：内部查询会返回$\text{True/False}$，从而决定外查询执行/不执行
> > >
> > >    ```sql
> > >    SELECT * FROM Buyer WHERE EXISTS(
> > >       SELECT * FROM Offer -- 内查询中，SELECT什么不重要，因为最后只会输出True/False
> > >       WHERE Buyer.BuyerID = Offer.BuyerID AND ArtefactID = 1
> > >    )
> > >    ```
> > >
> > > 1. 先遍历`Buyer`(外表)，对其每一行向内`Offer`(内表)表查询是否有行满足条件
> > >
> > >     ```sql
> > >      Buyer.BuyerID = Offer.BuyerID AND ArtefactID = 1
> > >     ```
> > >
> > > 2. 如果至少有一行条件满足，则执行下列外查询，把满足条件的行打印出来
> > >
> > >    ```sql
> > >     SELECT * FROM Buyer
> > >    ```
> > >
> > > 3. 一行行遍历$\text{+}$​打印后，结果为: 
> > >
> > >    | $\textbf{BID}$ | $\textbf{Name}$ | $\textbf{Phone}$ |
> > >    | :------------: | :-------------: | :--------------: |
> > >    |   $\text{1}$   |  $\text{Magg}$  |  $\text{0333}$   |
> > >    |   $\text{2}$   | $\text{Nicole}$ |  $\text{0444}$   |
>
> ## $\textbf{3.4. }$其他$\textbf{SQL}$子句
>
> > **1️⃣**`COALESCE()`: 返回列表中第一个非NULL值
> >
> > ```sql
> > -- 遍历每一行，如果A2非空则返回A2，如果A2空则返回''(首个非空值)
> > SELECT A1, COALESCE(A2, '') AS A2New, A3 FROM users;
> > ```
> >
> > |  初始表格   | $\textbf{A1}$  | $\textbf{A2}$ | $\textbf{A3}$  |  查询结果   | $\textbf{A1}$  | $\textbf{A2New}$ | $\textbf{A3}$  |
> > | :---------: | :------------: | :-----------: | :------------: | :---------: | :------------: | :--------------: | :------------: |
> > | $\text{\\}$ | $\text{John}$  | $\text{NULL}$ |  $\text{Doe}$  | $\text{\\}$ | $\text{John}$  |                  |  $\text{Doe}$  |
> > | $\text{\\}$ | $\text{Jane}$  |  $\text{A.}$  | $\text{Smith}$ | $\text{\\}$ | $\text{Jane}$  |   $\text{A.}$    | $\text{Smith}$ |
> > | $\text{\\}$ | $\text{Emily}$ | $\text{NULL}$ | $\text{Davis}$ | $\text{\\}$ | $\text{Emily}$ |                  | $\text{Davis}$ |
> >
> > **2️⃣**`LENGTH()`: 求出一段字符串的长度
> >
> > ```sql
> > ORDER BY LENGTH(Steing)      -- String长度从小到大排列
> > ORDER BY LENGTH(Steing) ASC  -- String长度从小到大排列
> > ORDER BY LENGTH(Steing) DEC  -- String长度从大到小排列
> > ```
> >
> > **3️⃣**`CASE WHEN`语法
> >
> > 1. 语法
> >
> >    ```sql
> >    CASE WHEN <条件表达式> THEN <条件满足时返回这个值> <条件不满足时返回这个值> END
> >    ```
> >
> > 2. 不重命名示例
> >
> >    ```sql
> >    SELECT 
> >    	id,
> >    	amount,
> >    	CASE WHEN amount > 100 THEN 'High' ELSE 'Low' END
> >    	CASE WHEN amount > 100 THEN 'High' ELSE 'Low' END AS class -- 重命名
> >    FROM orders;
> >    ```
> >
> >    |  不重命名   |    `id`    |    `CASE`     |   `amount`   |   重命名    |    `id`    |    `CASE`     |   `class`    |
> >    | :---------: | :--------: | :-----------: | :----------: | :---------: | :--------: | :-----------: | :----------: |
> >    | $\text{\\}$ | $\text{1}$ | $\text{High}$ | $\text{150}$ | $\text{\\}$ | $\text{1}$ | $\text{High}$ | $\text{150}$ |
> >    | $\text{\\}$ | $\text{2}$ | $\text{Low}$  | $\text{80}$  | $\text{\\}$ | $\text{2}$ | $\text{Low}$  | $\text{80}$  |
> >    | $\text{\\}$ | $\text{3}$ | $\text{High}$ | $\text{120}$ | $\text{\\}$ | $\text{3}$ | $\text{High}$ | $\text{120}$ |
> >
> > **4️⃣**$\text{Set Operation:}$ 目的是合并两个查询结果，原理详见关系代数
> >
> > ```sql
> > SELECT sid, sname, rating, age FROM S1 -- 此操作去除重复行
> > UNION
> > SELECT sid, sname, rating, age FROM S2;
> > SELECT sid, sname, rating, age FROM S1 -- 此操作保留重复行
> > UNION ALL
> > SELECT sid, sname, rating, age FROM S2;
> > ```

# $\textbf{4. }补充\textbf{Data Type}$ 

> ## $\textbf{4.1. }$字符类型
>
> > :one:概述
> >
> > |       类型       |          存储          | 备注                                                         |
> > | :--------------: | :--------------------: | :----------------------------------------------------------- |
> > |    `CHAR(M)`     |       定长字符串       | $\text{M∈(0,255)}$表示字符长度                               |
> > |   `VARCHAR(M)`   |       变长字符串       | $\text{M∈(1,65535)}$                                         |
> > | `BIT/BOOL/CHAR`  |      同`CHAR(1)`       | $\text{N/A}$                                                 |
> > |      `BLOB`      | 二进制文件==(音视频)== | 存储最多$\text{65535}$字节的$\text{0/1}$序列                 |
> > |      `TEXT`      |        大段文字        | 最多$\text{65535}$个字符                                     |
> > | `ENUM(a,b,c...)` |      列表(多选一)      | 列表中最多$\text{65535}$个成员，索引从左到右/从$\text{0}$开始 |
> > | `SET(a,b,c...)`  |      列表(多选多)      | 列表中最多$\text{64}$个成员                                  |
> >
> > :two:补充
> >
> > 1. `CHAR(M)`中对于定长字符，如果长度不够则会用空格填充
> >
> >    ```sql
> >    Name CHAR(5) -- 如果赋值Name='Kan'则实际存储Name='Kan<空格><空格>'
> >    ```
> >
> > 2. `TEXT`中说的是最多$\text{65535}$字符，不是字节；一个字符可占$\text{1-4}$​字节
> >
> > 3. `SET(a,b,c...)`示例
> >
> >    ```sql
> >    SET(a1,a2,a3) -- 可存储<空>/a1/a1a2/a1a2a3
> >    ```
>
> ## $\textbf{4.2. }$​整数类型
>
> > :one:概述
> >
> > |     $\textbf{Type}$     | $\textbf{Signed Range}$ | $\textbf{Unsigned Range}$ |
> > | :---------------------: | :---------------------: | :-----------------------: |
> > |     `TINYINT[(M)]`      |      $-128\to127$       |         $0\to255$         |
> > |     `SMALLINT[(M)]`     |    $-32768\to32767$     |        $0\to65535$        |
> > | `INT[(M)]/INTEGER[(M)]` |        ........         |         ........          |
> > |      `BIGINT[(M)]`      |        ........         |         ........          |
> >
> > :two:示例：`TINYINT(4)` 
> >
> > 1. 数字显示宽度为$\text{4}$
> > 2. 如果存储的数字为$\text{12}$，则会显示为$\text{0012}$ 
>
> ## $\textbf{4.3. }$​实数类型
>
> > :one:概述
> >
> > |  $\textbf{Type}$   | $\textbf{Precision}$ |    存储类型     |
> > | :----------------: | :------------------: | :-------------: |
> > |   `FLOAT[(M,D)]`   |        单精度        | $\text{Binary}$ |
> > |  `DOUBLE[(M,D)]`   |   双精度(范围更大)   | $\text{Binary}$ |
> > |   `REAL[(M,D)]`    |   双精度(范围更大)   | $\text{Binary}$ |
> > | `DECIMAL[(M[,D])]` |       定点类型       |     字符串      |
> >
> > :two:参数含义
> >
> > 1. `M`: 小数点左右加起来，一共有多少位
> > 2. `D`: 小数位数
>
> ## $\textbf{4.4. Data \& Time Type}$​ 
>
> > | $\textbf{Type}$ |         $\textbf{Format}$          | $\textbf{Range}$                                          |
> > | :-------------: | :--------------------------------: | :-------------------------------------------------------- |
> > |     `DATA`      |     $\small\text{YYYY-MM-DD}$      | $\text{1000-01-01}\to\text{9999-12-31}$                   |
> > |     `TIME`      |      $\small\text{HH:MM:SS}$       | $\text{-838:59:59}\to\text{838:59:59}$                    |
> > |   `DATETIME`    | $\small\text{YYYY-MM-DD HH:MM:SS}$ | $\text{1000-01-01 00:00:00}\to\text{9999-12-31 23:59:59}$ |
> > |   `TIMESTAMP`   | $\small\text{YYYY-MM-DD HH:MM:SS}$ | $\text{1970-01-01 00:00:00 UTC}\to\text{2037}$            |
> > |    `YEAR[4]`    |        $\small\text{YYYY}$         | $\text{1901}\to\text{2155}$                               |
> >
> > :one:`TIMESTAMP`是$\text{DB}$记录的时间点，会将时间转换为当地时间
> >
> > :two:`NOW()`函数会以$\text{YYYY-MM-DD HH:MM:SS}$格式返回当前时间
