# 存储系统

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/44444.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/44444.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/44444.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/44444.html)==**

# 1. 存储层次：平衡容量-价格-速度

> ## 1.1. 层次结构概览
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240131231639427.png" alt="image-20240131231639427" style="zoom: 30%;" /> 
> >
> > | 层间结构            | 原理                                                  | 对程序员可见？ |
> > | ------------------- | ----------------------------------------------------- | -------------- |
> > | $\text{Cache}$—主存 | 将当前使用最多的一小段程序/数据放入$\text{Cache}$     | NO             |
> > | 主存—辅存           | 主存+辅存的一部$\xrightarrow{软硬结合技术}$虚拟存储器 | YES            |
>
> ## 1.2. 层次设计准则
>
> > **1️⃣**层次间原则
> >
> > 1. 包含性：上层内容$\subseteq$下层内容
> > 2. 一致性：数据在不同层间流动时，不能被随意篡改
> >
> > **2️⃣**局部性原理：提高$\text{CPU-Cache}$命中率
> >
> > 1. 时间局部性：被$\text{CPU}$访问过的一个单元，很短时间内大概率会被再次访问
> > 2. 空间局部性：一段时间内$\text{CPU}$访问的指令数据，往往集中在一小片存储区域
> >
> > **3️⃣**其他：地址映射/地址变换/替换策略

# 2. $\text{CPU}$寄存器概览

> **1️⃣**运算器中的寄存器
>
> | 寄存器类别                 | 描述                                                       |
> | -------------------------- | ---------------------------------------------------------- |
> | 暂存寄存器                 | 用于暂存从主存读来的数据，对应用程序员透明                 |
> | 累加寄存器$\text{ACC}$     | 通用寄存器，暂存$\text{ALU}$运算结果                       |
> | 通用寄存器组               | 存放操作数和地址信息，如$\text{AX/BX/CX/DX}$，对程序员可见 |
> | 状态条件寄存器$\text{PSW}$ | 保由多个状态条件标志组成                                   |
>
> **2️⃣**控制器中的寄存器
>
> | 寄存器类别                   | 描述                                       | 对程序员可见？ |
> | ---------------------------- | ------------------------------------------ | :------------: |
> | 程序计数器$\text{PC}$        | 定位下一条指令的地址                       |      可见      |
> | 指令寄存器$\text{IR}$        | 保存当前正在执行的指令                     |     不可见     |
> | 存储器数据寄存器$\text{MDR}$ | 临时存放/中转从主存读出的数据或指令        |     不可见     |
> | 存储器地址寄存器$\text{MAR}$ | 保存当前$\text{CPU}$所访问的内存单元的地址 |     不可见     |

# 3. $\text{Cache}$

> ## 3.1. $\text{Cache}$原理
>
> > **0️⃣**块结构$\&$地址结构
> >
> > 1. 分块：主存$\text{/Cache}$被分别为若干块，一块由定长个字组成
> >
> > 2. 地址：
> >
> >    - 主存$\text{/Cache}$地址被分为两部分，块地址(寻块)$\&$块内地址(块内寻字)
> >    - $\text{Cache}$的每块都要附加一个标记，说明该$\text{Cache}$块来源于主存的哪一块
> >    - 示例如下：$\text{Cache}$中的块1保留的，是主存块3的副本
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202000330697.png" alt="image-20240202000330697" style="zoom:67%;" /> 
> >
> > **1️⃣**$\text{CPU-Cache-主存}$
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240201225827470.png" alt="image-20240201225827470" style="zoom: 75%;" />  
> >
> > - 块逻辑：位于$\text{Cache}\xleftrightarrow{大小相同的块}主存$
> >
> > **2️⃣**基于$\text{Cache}$的$\text{CPU}$访存流程
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240201232750619.png" alt="image-20240201232750619" style="zoom: 28%;" /> 
> >
> > - 判断$\text{Cache}$命中与否，是基于地址变换的结果
> >
> > **3️⃣**$\text{Cache}$评价指标
> >
> > 1. $\text{命中率: }H=\cfrac{命中次数}{\text{Cache}请求总数}$
> > 2. $失效率\text{: }F=1-命中率$
> > 3. $平均访问时间\text{: }T_c=H×\text{Cache存取时间}+(1-H)×\text{主存存取时间}$
> > 4. $加速比\text{: }S_p=\cfrac{主存存取时间}{平均访问时间}$
> > 5. $访问效率\text{: }e=\cfrac{Cache存取时间}{平均访问时间}$
>
> ## 3.2. 地址映射：$\text{Cache}$地址$\xleftrightarrow{}$主存地址
>
> > | 映射方式 | 概述                                                     | 备注                                                         |
> > | :------- | -------------------------------------------------------- | :----------------------------------------------------------- |
> > | 全相联   | $\text{Cache}$每一块$\xleftrightarrow{}$主存==任意==一块 | $\text{Cache}$利用率最高，但最贵                             |
> > | 直接相联 | $\text{Cache}$每一块$\xleftrightarrow{}$主存==固定==一块 | $\text{Cache}$块号$\text{=}$主存块号$\text{ mod Cache}$总块数 |
> > | 组相联   | 几块一组，组间直接相联/组内全相联                        | 主存和$\text{Cache}$都分组，切每组块数一样多                 |
> >
> > ### 3.2.1. 全相联
> >
> > > **1️⃣**原理示意图：$\text{Cache}$每一块$\xleftrightarrow{}$主存==任意==一块
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202004312962.png" alt="image-20240202004312962" style="zoom: 67%;" /> 
> > >
> > > **3️⃣**变换过程：$\text{CPU}$给出主存地址$\to$比较目录表后命中$\text{Cache}$$\to$直接访问$\text{Cache}$中单元
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202013437379.png" alt="image-20240202013437379" style="zoom: 87%;" /> 
> > >
> > > - 目录表(相联存储器)存储了$\text{Cache}$块$\xleftrightarrow{}$主存块映射
> > > - 主存调入$\text{Cache}$时，主存块号/$\text{Cache}$块号都被塞入目录表，有效位置1
> >
> > ### 3.2.2. 直接相联
> >
> > > **1️⃣**原理示意图：
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202014809995.png" alt="image-20240202014809995" style="zoom: 77%;" /> 
> > >
> > > - 可以理解$\text{Cache}$块在主存空间中一遍遍循环，循环一遍就是一个区，==一个区对应一个$\text{Cache}$大小==
> > >
> > > **2️⃣**变换原理：
> > >
> > > ==$主存任意区第N块\xleftrightarrow{对应}\text{Cache}第N块\xleftrightarrow{对应}区表第N个地址单元\,,N=1,2,...,\text{Cache}最大块$==
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202015108748.png" alt="image-20240202015108748" style="zoom: 43%;" /> 
> > >
> > > 1. 地址结构：注意每个区内的块号从0开始排起
> > >
> > >    |        地址        |     Part1      |       Part2        |         Part3          |
> > >    | :----------------: | :------------: | :----------------: | :--------------------: |
> > >    |      主存地址      | 区号$\text{E}$ | 区内块号$\text{B}$ | 块内地址单元$\text{W}$ |
> > >    | $\text{Cache}$地址 |      $\#$      |   块号$\text{b}$   | 块内地址单元$\text{w}$ |
> > >
> > > 2. 区表：
> > >
> > >    - 尺寸：区表的尺寸大小和$\text{Cache}$一样大(区表本身就是个mini版$\text{Cache}$)
> > >    - 按地址访问：==比如区表第二地址单元$\text{E=4}$，则$\text{Cache}$第二块来自主存第四区第二块==
> > >
> > > 3. 区表更新(示例)
> > >
> > >    - 主存第7区中第3块$\xrightarrow{传输}\text{Cache}$中第3块
> > >    - 区表中第3个单元处，更新区号为7，表明送入$\text{Cache}$的是第七区的第三块
> > >
> > > 4. 变换过程
> > >
> > >    - $\text{CPU}$给出主存地址，说明了是第$E$区第$B$块
> > >    - 查一下区表中的第$B$个地址单元，看看目前在$\text{Cache}$中的第$B$块是不是来自第$E$区
> > >    - 如果是来自第$E$区，则说明主存第$E$区第$B$块已经在$\text{Cache}$中了，命中
> >
> > ### 3.2.3. 组相联
> >
> > > **1️⃣**原理示意图：组间直接相联(固定映射)/组内全相联·
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202121057882.png" alt="image-20240202121057882" style="zoom:67%;" /> 
> > >
> > > | 存储器         | 1级划分     | 1级内的2级划分        | 2级内的3级划分    | 3级内的4级划分         |
> > > | -------------- | ----------- | --------------------- | ----------------- | ---------------------- |
> > > | 主存           | $2^s$个区   | 每个区内$2^u$个组     | 每个组内$2^v$个块 | 每块含多个存储地址单元 |
> > > | $\text{Cache}$ | $\text{\#}$ | ==一个==区内$2^u$个组 | 每个组内$2^v$个块 | 每块含多个存储地址单元 |
> > >
> > > **2️⃣**变换原理
> > >
> > > $\begin{cases}组间\text{: }主存任意区第G组\xleftrightarrow{对应}\text{Cache}第G组\xleftrightarrow{对应}块表第G个地址单元\,,N=1,2,...,\text{Cache}最大组\\\\组内\text{: }主存和\text{Cache}以组为单位对上，对上后组内实施全相联\end{cases}$
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202123255247.png" alt="image-20240202123255247" style="zoom: 36%;" /> 
> > >
> > > 1. 地址结构：注意每个区内的块号从0开始排起
> > >
> > > |        地址        |     Part1      |       Part2        |       Part3        |         Part4          |
> > > | :----------------: | :------------: | :----------------: | :----------------: | :--------------------: |
> > > |      主存地址      | 区号$\text{S}$ | 区内组号$\text{G}$ | 组内块号$\text{B}$ | 块内地址单元$\text{W}$ |
> > > | $\text{Cache}$地址 |      $\#$      |   组号$\text{g}$   | 组内块号$\text{b}$ | 块内地址单元$\text{w}$ |
> > >
> > > 2. 块表结构尺寸：$\text{Cache}组数=块表所含地址单元数$
> > >
> > > 3. 块表原理：以区表==第二地址单元$\text{E=4/B=5/b=6}$==为例
> > >
> > >    | 映射层级 |            主存中的单位            |            映射类型            |            $\text{Cache}$中的单位            |
> > >    | :------: | :--------------------------------: | :----------------------------: | :------------------------------------------: |
> > >    | 组间映射 | 主存$\text{E=4}$(第四区)内的第二组 | $\xleftrightarrow{组间组映射}$ |             $\text{Cache}$第二组             |
> > >    | 组内映射 |  选定主存组内$\text{B=5}$(第五块)  | $\xleftrightarrow{组内块映射}$ | 选定的$\text{Cache}$组内$\text{b=6}$(第六块) |
> > >
> > > 4. 变换过程
> > >
> > >    - $\text{CPU}$给出主存地址，说明了是第$E$区第$G$组第$B$块
> > >    - 组间：查一下块表中的第$G$个地址单元，看看目前在$\text{Cache}$中的第$G$组是不是来自第$E$区
> > >    - 组内：如果是来自第$E$区，则看是不是主存组第$B$块$\xleftrightarrow{映射}\text{Cache}$组第$b$块
> > >    - 组间组内都满足，才算命中
>
> ## 3.3. $\text{Cache}$替换算法
>
> > **1️⃣**背景：主存块调入$\text{Cache}$时，$\text{Cache}$对应地址内已经有内容了(冲突)，分三种情况
> >
> > | 地址映射 | 冲突后替换策略                                               |
> > | -------- | ------------------------------------------------------------ |
> > | 直接相联 | 主存块只能调入到$\text{Cache}$特定位置，直接替换             |
> > | 全相联   | 主存块调入$\text{Cache}$的位置随机，$\text{Cache}$空闲时插空放入，$\text{Cache}$满时按替换策略覆盖 |
> > | 组相联   | 组内全相联，故组全满了后也需要$\text{Cache}$替换算法         |
> >
> > **2️⃣**替换算法：注意$\text{R=Recent/F=Frequent}$
> >
> > |   替换算法    | 换掉哪一块 | 实现方法：每块一个计数器                                | 替换的块 |
> > | :-----------: | ---------- | ------------------------------------------------------- | -------- |
> > |     随机      | 任一       | $\#$                                                    | $\#$     |
> > | $\text{FIFO}$ | 待最久     | 块==装入/替换==时本计数器清0，其余计数器+1              | 计数最大 |
> > | $\text{LRU}$  | 近期最少用 | 块==装入/命中/替换==时本计数器清0，所有块计数值时钟递增 | 计数最大 |
> > | $\text{LFU}$  | 访问最少   | 块==装入/替换==时本计数器清0，命中时计数器+1            | 计数最小 |

# 4. 主存

> ## 4.1. 主存结构
>
> > ### 4.1.1. 主存部件
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20230920184746832.png" alt="image-20230920184746832" style="zoom: 67%;" />  
> > >
> > > **1️⃣**存储体(存储阵列)
> > >
> > > 1. 结构：多个存储元(存储位)构成一个存储单元，按照单元读写，每个单元一个地址
> > > 2. 存储字长：存储单元的位数，一般是$\text{N×Byte}$
> > >
> > > **2️⃣**寻址系统：$\text{MAR}$(暂存来自$\text{CPU}$的$n$位地址)+**译码器**(产生$2^n$位地址选择信号)+**驱动器**(放大器)
> > >
> > > **3️⃣**读写系统：$\text{MDR}$(暂存来自$\text{CPU}$的数据)+**读写电路**(根据控制电路的命令执行读写操作)
> > >
> > > **4️⃣**控制电路：产生读写命令
> > >
> > > ⚠️$\text{MAR/MDR}$在逻辑上属于主存，但一般放在$\text{CPU}$中
> >
> > ### 4.1.2. 主存$-\text{CPU}$连接
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20230920193801415.png" alt="image-20230920193801415" style="zoom:60%;" /> 
> > >
> > > **1️⃣**地址总线：总线位数$n=$机器字长$=$存储字长，寻址空间为$0\sim{}2^n-1$
> > >
> > > **2️⃣**数据总线：其位数$m$称为主存的**存储字长**，决定了一次可读写最大多少位
> > >
> > > **3️⃣**控制总线：$\text{CPU}$通过控制总线向主存发操作命令(读/写命令)
>
> ## 4.2. 主存读写操作
>
> > **1️⃣**读操作 
> >
> > |   操作    |         步骤         |               传递               |      步骤      |             传递             |         步骤         |
> > | :-------: | :------------------: | :------------------------------: | :------------: | :--------------------------: | :------------------: |
> > |  送地址   | $\text{CPU地址总线}$ |       $\xrightarrow{给出}$       |   $访存地址$   |    $\xrightarrow{缓存到}$    |     $\text{MAR}$     |
> > | 译码+命中 | $\text{MAR}缓存地址$ | $\xrightarrow[译码器]{译码得到}$ | $地址选择信号$ | $\xrightarrow[驱动器]{指定}$ | $对应地址的存储单元$ |
> > |  读命令   | $\text{CPU控制总线}$ |     $\xrightarrow{控制信号}$     |   $控制电路$   |    $\xrightarrow{读命令}$    |       $读信号$       |
> > | 数据读出  |   $命中的存储单元$   |     $\xrightarrow{单元数据}$     |   $读写电路$   |     $\xrightarrow{传递}$     | $\text{CPU数据总线}$ |
> >
> > **2️⃣**写操作
> >
> > |   操作    |         步骤         |               传递               |         步骤         |             传递             |         步骤         |
> > | :-------: | :------------------: | :------------------------------: | :------------------: | :--------------------------: | :------------------: |
> > |  送地址   | $\text{CPU地址总线}$ |       $\xrightarrow{给出}$       |      $访存地址$      |    $\xrightarrow{缓存到}$    |     $\text{MAR}$     |
> > | 译码+命中 | $\text{MAR}缓存地址$ | $\xrightarrow[译码器]{译码得到}$ |    $地址选择信号$    | $\xrightarrow[驱动器]{指定}$ | $对应地址的存储单元$ |
> > | 数据写入  |     $待写入数据$     |       $\xrightarrow{发送}$       | $\text{CPU数据总线}$ |             $\#$             |         $\#$         |
> > |  写命令   | $\text{CPU控制总线}$ |     $\xrightarrow{控制信号}$     |      $控制电路$      |    $\xrightarrow{写命令}$    |       $写信号$       |
>
> ## 4.3. 主存系统的两种地址译码
>
> > **1️⃣**线选法：单译码器
> >
> >  <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20230920200728378.png" alt="image-20230920200728378" style="zoom:50%;" /> 
> >
> > 1. 结构：共有$2^n$个存储单元(对应的单元地址为$n$位)，每个单元为$m$位
> > 2. 工作原理：输入$n$位地址$A_0A_2\cdots{}A_{n-1}\to$译码后选定一个存储单元的==所有$m$位==
> >
> > **2️⃣**重合法：双译码器
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20230920202419406.png" alt="image-20230920202419406" style="zoom:50%;" /> 
> >
> > 1. 结构：将地址拆分为$\text{X/Y}$地址两部分，各自译码
> > 2. 原理：先用$\text{X}$译码结果确定一行的地址单元，再用$\text{X}$译码结果确定一列的，横竖交叉命中
>
> ## 4.4. 主存的性能指标
>
> > **1️⃣**主存容量：有字地址/字节地址两种格式写法
> >
> > **2️⃣**存取速度
> >
> > 1. 存取时间$\text{MAT}$：启动读写→完成读写的时间
> >    - 读出时间：存储器收到有效地址→产生有效输出
> >    - 写入时间：存储器收到有效地址→数据被写入单元
> > 2. 存取周期$\text{MCT}$：两次读写操作的间隔，就是$\text{MAT+恢复时间}$ 
> >
> > **3️⃣**存储器带宽：
> >
> > 1. 含义：单位时间内存储器存取的信息量，单位$\text{bit/s}$
> > 2. 公式：$带宽=\cfrac{一周期可访问位数}{一存取周期时长}$ 
> >
> > ⚠️带宽中$\text{1K=1000}$，容量中$\text{1K=1024}$；在实际操作中位
> >
> > 1. $\text{1KB=1024B，1MB=1024KB}$，==大写B时一定对应1024倍==
> > 2. $\text{1Kb=1000b，1Mb=1024Kb}$，==小写b时一定对应1000倍==
>
> ## 4.5. 主存的编址
>
> > **1️⃣**字/字节编址の主存大小格式
> >
> > | 编址方式 | 容量                         | 单位          |
> > | -------- | ---------------------------- | ------------- |
> > | 字编址   | $容量=存储单元个数×存储字长$ | $\text{bit}$  |
> > | 字节编址 | $容量=字节数$                | $\text{Byte}$ |
> >
> > **2️⃣**字地址$\text{\&}$字节地址
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20230915004947775.png" alt="image-20230915004947775" style="zoom: 67%;" />  
> >
> > 1. <font color='red'>红字</font>为字节地址**是连续的**，<font color='blue'>蓝字</font>为字地址**不连续**
> > 2. 一个字单位里包含整数个字节单位，字地址编号=所包含的最低字节的编号 
> > 3. 字节在字中有两种排列方式
> >    - 小端：字低位$\xleftrightarrow{对应}$低地址字节
> >    - 大端：字低位$\xleftrightarrow{对应}$高地址字节
> >
> > **3️⃣**边界对齐/不对齐
> >
> > 1. 含义：
> >    - 对齐：数据的==起始字节地址=数据大小的整数倍==，由此极可能造成空间浪费
> >    - 不对齐：数据挤在一起，尽量不浪费
> >
> > 2. 示例：依次输入以下数据，得到在主存中的存储情况如下图和下表
> >
> > |       数据       |         $\text{int1}$         | $\text{char1}$ | $\text{char2}$ |          $\text{int2}$          |     $\text{半字数据1}$      |     $\text{半字数据2}$      |
> > | :--------------: | :---------------------------: | :------------: | :------------: | :-----------------------------: | :-------------------------: | :-------------------------: |
> > |   大小(多少字)   |          $\text{1}$           | $\text{0.25}$  | $\text{0.25}$  |           $\text{1}$            |        $\text{0.5}$         |        $\text{0.5}$         |
> > |  大小(多少字节)  |          $\text{4}$           |   $\text{1}$   |   $\text{1}$   |           $\text{4}$            |         $\text{2}$          |         $\text{2}$          |
> > |  字节地址(对齐)  | ==$\text{0}$==$\text{/1/2/3}$ |   $\text{4}$   |   $\text{5}$   | ==$\text{8}$==$\text{/9/10/11}$ | ==$\text{12}$==$\text{/13}$ | ==$\text{14}$==$\text{/15}$ |
> > | 字节地址(不对齐) |       $\text{0/1/2/3}$        |   $\text{4}$   |   $\text{5}$   |  ==$\text{6}$==$\text{/7/8/9}$  | ==$\text{10}$==$\text{/11}$ | ==$\text{12}$==$\text{/13}$ |
> >
> > 上边为对齐的，下边为不对齐的
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240201215945794.png" alt="image-20240201215945794" style="zoom: 38%;" /> 

# 5. 辅存：不易失性

> ## 5.1. 磁表面存储器：磁带/磁盘
>
> > ### 5.1.1. 结构
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202143602871.png" alt="image-20240202143602871" style="zoom:67%;" /> 
> > >
> > > **1️⃣**存储介质：涂有磁性材料的载体
> > >
> > > **2️⃣**读写装置：磁头，分为接触式(磁带软盘)/浮动式(硬盘)
> >
> > ### 5.1.2. 读写操作
> >
> > > **1️⃣**写操作：
> > >
> > > 1. 磁头停留在未磁化单元处→线圈加电流→单元处带上磁性
> > > 2. 电流方向不同，单元出磁性不同(绿色箭头方向)，以此区分0/1
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202144213684.png" alt="image-20240202144213684" style="zoom: 60%;" /> 
> > >
> > > **2️⃣**读操作：磁头停留在已磁化单元→磁性单元让线圈感应起电→通过感应电动势的正负读出0/1
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202144517205.png" alt="image-20240202144517205" style="zoom:60%;" /> 
> >
> > ### 5.1.3. 记录(编码)方式
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202151151837.png" alt="image-20240202151151837" style="zoom: 33%;" /> 
> > >
> > > |             编码制             | 写入前 |            写入0的电流变化            |    写入1的电流变化    |
> > > | :----------------------------: | :----: | :-----------------------------------: | :-------------------: |
> > > |      归零制度$\text{RZ}$       | 未磁化 |                负脉冲                 |        正脉冲         |
> > > |     不归零制度$\text{NRZ}$     |  $\#$  |                  负                   |          正           |
> > > | 见1翻的不归零制度$\text{NRZ1}$ |  $\#$  |                 不变                  |      在中间翻转       |
> > > |       调相制$\text{PM}$*       |  $\#$  |            在中间负转正**             |    在中间正转负**     |
> > > |       调频制$\text{FM}$        |  $\#$  |           只在==起始==翻转            | 在==起始/中间==各翻转 |
> > > |     改进调频制$\text{MFM}$     |  $\#$  | ==单个0==时不变/==连续0==时只起始翻转 |      只中心翻转       |
> > >
> > > *可简单理解为：1对应波形<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202150033028.png" alt="image-20240202150033028" style="zoom: 15%;" />，0对应波形<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202150041781.png" alt="image-20240202150041781" style="zoom:15%;" />，不管上一位如何都执行这两波形表示0/1
> > >
> > > **这二者其实可以完全反过来
>
> ## 5.2. 硬盘
>
> > ### 5.2.1. 硬盘结构(温彻斯特磁盘)
> >
> > > **1️⃣**内部结构概览
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202152536987.png" alt="image-20240202152536987" style="zoom: 70%;" /> 
> > >
> > > 1. 主轴：旋转盘片
> > > 2. 定位驱动器：驱动磁头沿盘片==径向运动==
> > > 3. 读写控制系统：就是磁头+磁头控制器+读写控制电路，一个盘一个头
> > >
> > > **2️⃣**硬盘—主机结构：其实这两个系统中还会有一定缓存(物理上位于硬盘)，解决速度不匹配问题
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202153035937.png" alt="image-20240202153035937" style="zoom: 75%;" /> 
> >
> > ### 5.2.2. 磁盘中的数据存放
> >
> > > **1️⃣**盘片结构：环形(中间是主轴)，可单面记录信息/也可以双面
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20231009142841675.png" style="zoom: 67%;" />  
> > >
> > > 1. 二维结构：==磁道==
> > >
> > >    - 磁道：盘面上的等距同心圆，每个盘面同心圆数量一样，磁道编址由外向内(0起始)
> > >    - 着陆区：靠内半径最小的一些磁道
> > >    - 数据区：着陆区以外的磁道
> > >
> > > 2. 三维结构：==柱面== 
> > >
> > >    - 柱面：不同盘面同一磁道号的集合，就是竖直方向上一个个平行等大的圆环
> > >    - 柱面数=磁道数
> > >    - 每个柱面上的磁头从上到下从0 开始编号
> > >
> > > 3. 一维结构：==扇区(扇段)==
> > >
> > >    - 扇区：是单个磁道划分成的若干弧线，是硬盘的最小寻址单元
> > >
> > >    - 磁道的起始扇区：在磁道起始位置打一个索引孔，标识起始0号扇区
> > >
> > >    - 扇区硬分区：所有扇区弧度相同/长度不同/==存储大小相同==，所有磁道存放内容等大
> > >
> > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202162141296.png" alt="image-20240202162141296" style="zoom:50%;" /> 
> > >
> > >    - 扇区软分区：扇区存放内容大小可不同，外圈磁道能放下更多内容
> > >
> > > **2️⃣**数据(扇区)定位：
> > >
> > > 1. 地址格式：`<驱动器号><柱面号/磁道号><盘面号/磁头号><扇区号>`
> > > 2. 驱动器号：适用于系统中有多个硬盘，先要选定读哪个硬盘
> > >
> > > **3️⃣**读写操作的空间顺序
> > >
> > > 1. 选柱面：磁盘驱动器&定位驱动器，径向移动所有磁头，选定一个柱面
> > > 2. 读第一个盘面：主轴旋转，编号为0的磁头开始在所在磁道上，一扇区一扇区地读写数据
> > > 3. 读剩下盘面：0磁头读完此磁道后，1磁头开始读下一个磁道，以此类推直到读写完柱面所有磁道
> >
> > ### 5.2.3. 硬盘记录的格式(磁道—扇区内结构)
> >
> > > **1️⃣**定长记录格式：数据块大小固定，适合硬分区
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202162340644.png" alt="image-20240202162340644" style="zoom: 80%;" /> 
> > >
> > > **2️⃣**不定长记录格式：数据块大小可变
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240202162732633.png" alt="image-20240202162732633" style="zoom:70%;" />  
> >
> > ### 5.2.4. 硬盘技术参数
> >
> > > **1️⃣**记录密度：单位面积或单位长度记录了多少位位
> > >
> > > 1. 道密度：盘面径向上，单位长度内的磁道数量，单位$\text{tpi}$
> > > 2. 位密度：磁道单位长度上能记录多少位，单位$\text{bpi}$ 
> > >
> > > **2️⃣**容量：全部磁道中存储信息的总和
> > >
> > > 1. 非格式化容量：包含间隙和非有效单元
> > >
> > > | 容量 | $=$  | 硬盘数 | $\text{×}$ | 盘面数 | $\text{×}$ |           磁道数           | $\text{×}$ |         磁道容量         |
> > > | :--: | :--: | :----: | :--------: | :----: | :--------: | :------------------------: | :--------: | :----------------------: |
> > > | 容量 | $=$  | 硬盘数 | $\text{×}$ | 盘面数 | $\text{×}$ | 道密度$\text{×}$盘有效半径 | $\text{×}$ | 位密度$\text{×}$磁道周长 |
> > >
> > > 2. 格式化容量：用户可用的有效容量
> > >
> > > | 容量 | $=$  | 硬盘数 | $\text{×}$ | 盘面数 | $\text{×}$ | 磁道数 | $\text{×}$ | 每道扇区数 | $\text{×}$ | 扇区容量 |
> > > | :--: | :--: | :----: | :--------: | :----: | :--------: | :----: | :--------: | :--------: | ---------- | -------- |
> > >
> > > **3️⃣**寻址+读写时间
> > >
> > > |     指标     |            含义            |
> > > | :----------: | :------------------------: |
> > > | 平均寻道时间 |   磁头定位到磁道平均耗时   |
> > > | 平均等待时间 | 磁头旋转到目标扇区平均耗时 |
> > > | 磁头读写时间 |            $\#$            |
> > >
> > > 补充：
> > >
> > > 1. 平均寻址时间$=$平均寻道时间$+$平均等待时间
> > > 2. 转速：单位时间内盘片能转多少圈(单位$\text{rpm}$)，平均等待时间$=\cfrac{1}{转速}×0.5$
> > >
> > > **4️⃣**数据传输速率
> > >
> > > 1. 内部速率：就是磁道容量$\text{×}$转速，描述了硬盘数据以多块速度冲入缓存
> > > 2. 外部速率：系统总线，能以多块的速度，从硬盘缓冲区中读出数据



