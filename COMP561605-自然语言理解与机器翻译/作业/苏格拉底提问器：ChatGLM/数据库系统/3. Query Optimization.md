# $\textbf{Query Optimization}$ 

# $\textbf{1. Storage}$​ 

> ## $\textbf{1.1. File Hierarchy}$  
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1043190004.png" alt="1043190004" style="zoom: 30%;" /> 
> >
> > |         术语          |                             描述                             |
> > | :-------------------: | :----------------------------------------------------------: |
> > | $\text{Record/Tuple}$ |                         表格中的一行                         |
> > |     $\text{Page}$     | $\text{Fixed-size}$的数据块($\text{MySQL}$中为$\text{16KB}$) |
> > |     $\text{File}$     |                  包含若干多的$\text{Page}$                   |
>
> ## $\textbf{1.2. File Orgnisation}$​
>
> > |       文件类型       |        存放         |      记录的排列方式      |             适用情况             |
> > | :------------------: | :-----------------: | :----------------------: | :------------------------------: |
> > |  $\text{Heap file}$  | $\text{Data File}$  |     记录间无特定顺序     | 检索所有记录($\text{Heap Scan}$) |
> > | $\text{Sorted file}$ | $\text{Data File}$  |   页和记录按某条件排序   |        按特定顺序检索记录        |
> > | $\text{Index file}$  | $\text{Index File}$ | 存放目录，某顺序检索最快 |      快速检索特定顺序的记录      |
> >
> > **1️⃣**$\text{Heap File}$ 
> >
> > 1. $\text{Data File}$结构：$\text{Tuple}$按顺序填满一个个$\text{Page}$ 
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/18238755500.png" alt="18238755500" style="zoom: 39%;" /> 
> >
> > 2. 特点：
> >
> >    - 插入快：插入记录时，随便插入哪里
> >    - 扫描快：即快速扫描所有页($\text{Heap Scan}$)
> >    - 查找慢：要想找到一个$\text{Record}$，需要查看每条记录
> >
> > 3. $\text{Heap Scan / Sequential Scan: }$扫描表格中所有的$\text{Tuple}$ 
> >
> >    ```sql
> >    SELECT * FROM Table;
> >    ```
> >
> > **2️⃣**$\text{Sorted File}$
> >
> > 1. $\text{Data File}$结构：$\text{Pages and records are sorted}$, 上图是根据年龄-薪水复合排序
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1218859907.png" alt="1218859907" style="zoom: 33%;" /> 
> >
> > 2. 特性：
> >
> >    - 查找快：对于有序序列，可以用二分查找
> >    - 插入慢：为了保证顺序，就不能随便插入
> >
> > **3️⃣**$\text{Index File}$ 
>
> ## $\textbf{1.3. Cost}$评估标准
>
> > **1️⃣**$\text{DBMS}$评估$\text{Transactions/Buffer Pool}$等操作需要开销，但最主要的开销是$\text{IO}$操作
> >
> > **2️⃣**开销衡量(忽略$\text{IO}$开销以外的开销)：
> >
> > 1. $\text{DBMS}$的数据存储方式
> >
> >    | 执行查询 |                存储方式                 |           介质           |
> >    | :------: | :-------------------------------------: | :----------------------: |
> >    |    ❌     | 存储在$\text{Non-Volatile}$(非活性)介质 | $\text{Hard Disk / SSD}$ |
> >    |    ✔️     |    存储在$\text{Volatile}$(活性)介质    |       $\text{RAM}$       |
> >
> > 2. 衡量：
> >
> >    - 粗略认为开销$\text{=IO}$开销
> >    - $\text{IO}$开销$\text{ }\propto{}\text{(}$硬盘$\xrightarrow{\text{Data}}$主存$\text{IO}$的页数$\text{)}$ 
>
> ## $\textbf{1.4. Index and Index File}$详解
>
> > ### $\textbf{1.4.1. Index}$概述
> >
> > > **1️⃣**$\text{Index: }$相当于一个目录/指针，每个$\text{Index}$指向一个$\text{Data}$​ 
> > >
> > > :two:$\text{Index File: }$
> > >
> > > 1. 存储$\text{Index}$的文件，建立在$\text{Data File}$​之上
> > > 2. 允许快速检索
> > > 3. 相比$\text{Sorted File}$，$\text{Index}$可以在不改变$\text{Data File}$的情况下，建立多种排序方式
> > >
> > > :three:$\text{Index Key}$
> > >
> > > 1. $\text{Search Key Field}$​(搜索关键字字段): 
> > >
> > >    - 其实就是选取自表格的$\text{Column}$ 
> > >
> > >    - 用于建立索引的特定字段($\text{Fields}$)，比如按年龄排序
> > >
> > > 2. ==$\text{Composite Search Key}$== 
> > >
> > >    - 以比如`<Age, Sal, Name>`先按`Age`排序再按`Sal`排序最后按`Name`排序
> > >
> > >    - 重点关注$\text{Index}$​的顺序
> >
> > ### $\textbf{1.4.2. Indexing Implementation: Hash/B}^{+}\textbf{Tree Index}$ 
> >
> > > **==决定$\text{Index File}$​的顺序==**
> > >
> > > **1️⃣**$\text{B}^{+}\text{Tree Index}$: 
> > >
> > > 1. $\text{Index File}$​结构结构
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421165933628.png" alt="image-20240421165933628" style="zoom:49%;" />  
> > >
> > >    | $\textbf{Index File}$结构结构 |                            特点                             |
> > >    | :---------------------------: | :---------------------------------------------------------: |
> > >    |  $\text{Leaf Node}$(最底层)   | 包含==所有==可能的值$\text{Data Entries}$(这点不同于二叉树) |
> > >    |           中间节点            |     相当于$\text{Guiding}$的作用，包含指向下一层的指针      |
> > >
> > > 2. 特点：
> > >
> > >    - $\text{Index File}$有序
> > >    - 对$\text{Range Search}$和$\text{Equality Search}$效果都很好
> > >
> > > **2️⃣**$\text{Hash Index}$
> > >
> > > 1. 哈希是什么：$\text{Key(Record)}\xrightarrow{\text{Hash函数}}\text{Hash值}\xrightarrow{\text{一个Hash值对应一个Bucket}}放入对应桶$ 
> > >
> > >    | $\textbf{Record}$ | $\textbf{Key}$ | $\textbf{Hash}$ | $\textbf{Bucket}$  |
> > >    | :---------------: | :------------: | :-------------: | :----------------: |
> > >    |  $\text{Alice}$   |   $\text{A}$   |   $\text{1}$    | $\text{1}$对应的桶 |
> > >    |   $\text{Bob}$    |   $\text{B}$   |   $\text{2}$    | $\text{2}$对应的桶 |
> > >    |  $\text{David}$   |   $\text{D}$   |   $\text{4}$    | $\text{4}$对应的桶 |
> > >
> > > 2. $\text{Hash Index}$​原理：哈希函数$\text{H=Sal(Mod4)}$ ​
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image.png" alt="image" style="zoom:50%;" /> 
> > >
> > >    - 先确定要查找的数在哪个$\text{Bucket}$中
> > >    - 再到相应$\text{Bucket}$​中寻找，找到后再索引到$\text{Data File}$中
> > >
> > > 3. 特点：$\text{Index File}$按$\text{Bucket}$排列$\text{→Index File}$无序
> > >
> > >    - 极难作$\text{Range Search}$(<span style="color:red;">还不如直接$\text{Heap Scan}$</span>)，==只能作$\text{Equality Search}$​== 
> > >    
> > >      ```sql
> > >      SELECT * FROM A>10 -- 若A建立在HASH索引上，这一行效率最高的恰恰是Heap Scan
> > >      ```
> > >    
> > >    - 再去让$\text{Hash Index}$作$\text{Cluster}$无意义，因为$\text{Data}$顺序等于/不等于无序的$\text{Index}$都无意义 
> >
> > ### $\textbf{1.4.3. Index Storage: Cluster/Uncluster Index}$ 
> >
> > > **==决定$\text{Data File}$顺序(无序/与$\text{Index File}$​顺序一致)==**
> > >
> > > **1️⃣**$\text{Cluster/Uncluster Index}$​概述
> > >
> > > 1. 原理
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162644005.png" alt="image-20240421162644005" style="zoom:55%;" />   
> > >
> > >
> > >    |     $\textbf{Type}$      |        $\textbf{Data File}$        |
> > >    | :----------------------: | :--------------------------------: |
> > >    |  $\text{Cluster Index}$  | 有序，且==按照$\text{Index}$排序== |
> > >    | $\text{Uncluster Index}$ |     无序，即$\text{Heap File}$     |
> > >
> > > 2. 注意事项：
> > >
> > >    - 一个表格的$\text{Cluster Index}$必须是唯一的，因为其按照$\text{Index}$​排序
> > >    - $\text{Cluster/Uncluster Index}$的概念很大程度是只应用在$\text{B}^{+}\text{Tree Index}$，而非$\text{Hash}$上的
> > >
> > > **2️⃣**$\text{Cluster/Uncluster Index}$的$\text{Range Scan}$开销：例如要搜索成绩在$\text{10→50}$的学生 
> > >
> > > |  $\textbf{Type}$   |              开销               |                     示例                      |
> > > | :----------------: | :-----------------------------: | :-------------------------------------------: |
> > > |  $\text{Cluster}$  |     存放所需范围数据的页数      | 假设$\text{10→50}$存放在$3$页中$\to$开销是$3$ |
> > > | $\text{Uncluster}$ | 符合要求的$\text{Data Entry}$数 |               最坏情况$40(41)$                |
> > >
> > > 1. $\text{Cluster Index}$开销原理
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240510140340276.png" alt="image-20240510140340276" style="zoom: 50%;" />  
> > >
> > > 2. $\text{Uncluster Index}$开销原理：最坏的情况，每读一个数据都要$\text{IO}$一页
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240510141358438.png" alt="image-20240510141358438" style="zoom:50%;" /> 
> >
> > ### $\textbf{1.4.3. Index Role: Primary/Secondary Index}$
> >
> > > |  $\textbf{Type}$   |   $\textbf{Search Key}$    | $\textbf{Duplicates}$ |             示例              |
> > > | :----------------: | :------------------------: | :-------------------: | :---------------------------: |
> > > |  $\text{Primary}$  |  包含$\text{Primary Key}$  |        不存在         | 按照`Student.ID`排序建立索引  |
> > > | $\text{Secondary}$ | 不包含$\text{Primary Key}$ |       可能存在        | 按照`Student.Age`排序建立索引 |

# $\textbf{2. Query Processing}$

> ## $\textbf{2.1. SELECTION Processing}$
>
> > ### $\textbf{2.1.1. }$有关参数：==高亮为$\text{SELECTION}$开销决定参数== 
> >
> > > :one:基础参数
> > >
> > > |         $\textbf{Factor}$         | 含义                                 |
> > > | :-------------------------------: | :----------------------------------- |
> > > |      ==$\text{NPages(I)}$==       | $\text{Index File}$一共有多少页      |
> > > |        $\text{NTuples(R)}$        | $\text{Data File}$一共有多少条数据   |
> > > |        $\text{NPages(R)}$         | $\text{Data File}$一共有多少页       |
> > > | $\text{NTuplesPerPage}\text{(R)}$ | $\text{Data File}$每页存放多少条数据 |
> > >
> > > - $\text{NTuples(R)=}\text{NPages(R)}\times\text{NTuplesPerPage}\text{(R)}$ 
> > >
> > > **2️⃣**查询优化参数
> > >
> > > |             $\textbf{Factor}$             | 含义                                         |
> > > | :---------------------------------------: | :------------------------------------------- |
> > > |       ==$\text{Result Size(RS)}$==        | $\text{Data File}$一共有多少页**是需要的**   |
> > > | $\text{Reduction Factor(RF)/Selectivity}$ | 有多少百分比的数据符合$\text{SELECTION}$条件 |
> > >
> > > 1. 原理：$\text{NPages(R)(关系大小)}\xrightarrow[剩下的]{经过\text{WHERE + Condition}筛选}\text{RS}$，即$\text{RS = NPages(R)×RF}$  
> > > 2. 示例：整个表格有$\text{100}$页，经过`WHERE+condition`筛选后只有$\text{20}$页，那$\text{RS=20, RF=0.2}$ 
> >
> > ### $\textbf{2.1.2. SELECTION Cost}$
> >
> > > **1️⃣**非索引情况下的开销($\text{Sorted File}$基本不考)
> > >
> > > | $\textbf{File Structure}$ |     $\textbf{Cost}$(单位是$\textbf{IO}$次数)     |               原理               |
> > > | :-----------------------: | :----------------------------------------------: | :------------------------------: |
> > > |    $\text{Heap File}$     |                $\text{NPages(R)}$                | $\text{Heap Scan}$读取表中每一页 |
> > > |   $\text{Sorted File}$    | $\log_{2}\text{[NPages(R)]+RF×}\text{NPages(R)}$ |   二分查找定位$+$所需读多少页    |
> > >
> > > **2️⃣**索引情况下的开销
> > >
> > > |   $\textbf{Index}$实现    |   $\textbf{Index}$存储/角色    |                             开销                             |
> > > | :-----------------------: | :----------------------------: | :----------------------------------------------------------: |
> > > | $\text{B}^{+}\text{Tree}$ |     $\text{Primary Index}$     |                 $\text{树高Height(Index)+1}$                 |
> > > |       $\text{Hash}$       |     $\text{Primary Index}$     |     $\text{ProbeCost(Index)+1}\xrightarrow{默认为}1.2+1$     |
> > > | $\text{B}^{+}\text{Tree}$ | ==$\text{Unclustered index}$== | $\text{[NPages(I)+N\textcolor{red}{Tuples}(R)]×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}$ |
> > > | $\text{B}^{+}\text{Tree}$ |  ==$\text{Clustered index}$==  | $\text{[NPages(I)+N\textcolor{red}{Pages}(R)]×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}$ |
> > > |       $\text{Hash}$       |   $\text{Unclustered index}$   | $\text{N\textcolor{red}{Tuples}(R)×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}\times{}2.2$ |
> > > |       $\text{Hash}$       |    $\text{Clustered index}$    | $\text{N\textcolor{red}{Pages}(R)×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}\times{}2.2$ |
> > >
> > > 1. $\text{Unclustered/Clustered index}$的两部分开销为读取所需$\text{Index+Page}$
> > > 2. $\text{Unclustered index}$中$\text{NTuples(R)}$是因为此时读取需要反复回到$\text{Index File}$​
> > > 3. 多个$\text{RF}$​都需要乘起来，至于有多少个，取决于`WHERE`子句后面是什么
> >
> > ### $\textbf{2.1.3. SELECTION Cost}$补充：$\textbf{RF Estimate}$ 
> >
> > > #### $\textbf{2.1.3.1. }$基本假设: $\textbf{Assume Uniform Distribution}$ 
> > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/82928265853.png" alt="82928265853" style="zoom: 38%;" /> 
> > >
> > > #### $\textbf{2.1.3.2. }$$\textbf{RF Estimate}$ 
> > >
> > > > **1️⃣**简单情况下的$\text{RF}$估算
> > > >
> > > > 1. 参数含义
> > > >
> > > >    |        参数         |                    含义                    |
> > > >    | :-----------------: | :----------------------------------------: |
> > > >    | $\text{NKeys(Col)}$ | 一列中含有多少种独一无二的值，即`DISTINCT` |
> > > >    | $\text{High(Col)}$  |               一列种的最高值               |
> > > >    |  $\text{Low(Col)}$  |               一列种的最低值               |
> > > >
> > > > 2. 离散变量的$\text{RF}$​估算：`WHERE Col=Value`
> > > >
> > > >    - ${}\text{Col=Value}$对应单个值时，$\text{RF=}\cfrac{\text{1}}{\text{NKeys(Col)}}$ 
> > > >
> > > >      ```sql
> > > >      WHERE level=5;
> > > >      ```
> > > >
> > > >    - ${}\text{Col=Value}$可对应多个值，比如以下情况有$\text{X}$个$\text{Value}$，则$\text{RF=}\cfrac{\text{X}}{\text{NKeys(Col)}}$ 
> > > >
> > > >      ```sql
> > > >      WHERE level=1 AND level=2 AND ... AND level=X;
> > > >      ```
> > > >
> > > >    - 离散变量的不等$\xrightarrow{转化}$相等，如下$\text{Level>7}\Rightarrow\text{Level=8,9,10}\Rightarrow\text{Num=3}$ 
> > > >
> > > >      ```sql
> > > >      WHERE level>1 -- 共10个level
> > > >      ```
> > > >
> > > >      比如​ 
> > > >
> > > > 3. 连续变量的$\text{RF}$估算：`WHERE Col>Value / WHERE Col<Value ` 
> > > >
> > > >    |        条件        |                      $\textbf{RF}$等于                       | $\textbf{SQL}$示例 |
> > > >    | :----------------: | :----------------------------------------------------------: | :----------------: |
> > > >    | $\text{Col>Value}$ | $\cfrac{\text{High(Col)}-\text{Value}}{\text{High(Col)}-\text{Low(Col)}}$ |      `time>8`      |
> > > >    | $\text{Col<Value}$ | $\cfrac{\text{Value}-\text{Low(Col)}}{\text{High(Col)}-\text{Low(Col)}}$ |      `time<8`      |
> > > >
> > > > **2️⃣**$\text{Join}$操作下的$\text{RF}$估算：$\text{RF}=\cfrac{1}{\text{Max[NKeys(JoinCol\_A), NKeys(JoinCol\_B)]}}$ 
> > > >
> > > > 1. 示例：$\text{Student/Subject}$是两个$\text{JoinCol}$
> > > >
> > > >    ```sql
> > > >    Student INNER JOIN Subject ON Student.stuid=Subject.stuid
> > > >    ```
> > > >
> > > >
> > > > 2. 核心：$\text{Primary Key}$所在列$\text{JoinCol}$​唯一值更多​
> > > >
> > > >    - 假设`stuid`在$\text{Student}$处为$\text{PK}$，在$\text{Subject}$处为$\text{FK}$ 
> > > >
> > > >    - 则：$\text{RF}=\cfrac{1}{\text{NTuples(Student)}}$ 
> > > >
> > > > 3. 特殊情况：若$\text{Student}$筛选剩下$\text{20\%}$再去$\text{Join}$，$\text{RF}$计算无需$\text{×20\%}$，永远保持原来的大小
> > > >
> > > >    - 原理：$\text{Subject}$中还有未被筛选的那$\text{80\% Student}$​数据，即这些值是被筛掉而不是删掉
> > > >
> > > >    - 如下例子中：两种情况下$\text{NLJ}$都有$\text{RF}=\text{RF(Test}\bowtie{}\text{DTR)}$​   
> > > >
> > > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/41570539127.png" alt="41570539127" style="zoom:39.9%;" /> 
> > > >
> > > > **3️⃣**玄学情况：比如告诉你`age=5`但是不告诉你`DISTINCT age`的数量，则默认$\text{RF=}\cfrac{1}{10}$
> > >
> > > #### $\textbf{2.1.3.3. }$$\textbf{RF Estimate}$优化 
> > >
> > > > :one:存在的问题：数据不可能是平均分布的，如果数据集中向一个方向靠近，误差就会很大
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240512175609718.png" alt="image-20240512175609718" style="zoom: 43%;" /> 
> > > >
> > > > :two:误差分析
> > > >
> > > > 1. 方法$\text{1: Variable-Width Histogram}$​(柱状图)
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240512180432571.png" alt="image-20240512180432571" style="zoom:40%;" /> 
> > > >
> > > >    - 分$\text{Bucket}\to{}$尽量每个$\text{Bucket}$中数量差不多$\to{}$再去用$\text{Bucket}$估计
> > > >
> > > >    - 估算`age=5`(在$\text{Bucket1}$里)：$\text{RF=}\cfrac{1}{共4个\text{Bucket}\times{}\text{Bucket1}里有5个值}=\cfrac{1}{20}$
> > > >
> > > > 2. 方法$\text{2: }$取样出一部分数据，得出大致的数据分布
> > 
> > ### ==$\textbf{2.1.4. SELECTION Condition: }$如何处理`WHERE`子句==
> >
> > > **1️⃣**原理
> >>
> > > 1. 寻找最便宜的$\text{Access Path}$：估算成本($\text{IO}$次数)
> > >    - 利用==索引匹配的谓词==来计算$\text{RF}$，从而达到简化效果​
> > >    - $\text{Apply other predicates on-the-fly}$(实时)
> > > 2. 选取成本最小的方式($\text{Index}$或$\text{File Scan}$)
> > >
> > > **2️⃣**索引匹配的谓词：$\text{Composite Search Key}$与`WHERE + Condition`匹配
> > >
> > > 1. 匹配条件：
> > >
> > >    - `WHERE + Condition`要包含$\text{Composite Search Key}$的$\text{Prefix}$​
> > >    - `WHERE + Condition`中`AND`的顺序不重要
> > >
> > > 2. 匹配示例：`<a,b,c>`的$\text{Prefix}$包含`a/ab/abc`
> > >
> > >    | $\textbf{Composite Search Key}$ | $\textbf{ WHERE Conditions}$ | 匹配的$\textbf{Prefix}$ |
> > >    | :-----------------------------: | :--------------------------- | :---------------------- |
> > >    |            `<a,b,c>`            | `WHERE a=1`                  | `a`                     |
> > >    |            `<a,b,c>`            | `WHERE a=1 AND b=2`          | `a,b`                   |
> > >    |            `<a,b,c>`            | `WHERE a=1 AND b=2 AND c=3`  | `a,b,c`                 |
> > >    |            `<a,b,c>`            | `WHERE a=1 AND b=2 AND d=3`  | `a,b`                   |
> > >    |            `<a,b,c>`            | `WHERE a=1 AND c=2`          | `a`                     |
> > >    |            `<a,b,c>`            | `WHERE b=2 AND c=3`          | `NULL`                  |
> > >
> > > **3️⃣**基于索引匹配的谓词的$\text{RF}$​计算示例
> > >
> > > | $\textbf{Composite Search Key}$ | $\textbf{ WHERE Conditions }$ | $\textbf{Prefix}$ |    $\textbf{RF}$    |
> > > | :-----------------------------: | :---------------------------- | :---------------: | :-----------------: |
> > > |            `<a,b,c>`            | `WHERE a AND c`               |        `a`        |   $\text{RF(a)}$    |
> > > |             `<a,c>`             | `WHERE a AND b AND c`         |       `a,c`       | $\text{RF(a)RF(c)}$ |
> > >
> > > **4️⃣**其他注意事项：$\text{Hash}不能作\text{Range Search}$，见如下的综合示例中$\text{Day}$是$\text{Range Search}$
> > >
> > > ```sql
> > > WHERE day<8/9/94 AND bid=5 AND sid=3
> > > ```
> > >
> > > |      $\textbf{Type}$      | $\textbf{Index}$ | $\textbf{Prefix}$ |      是否适用于示例的查询       |      $\textbf{RF}$       |
> > > | :-----------------------: | :--------------: | :---------------: | :-----------------------------: | :----------------------: |
> > > | $\text{B}^{+}\text{Tree}$ |  `<rname,day>`   |   $\text{N/A}$    | $\text{N}(无匹配\text{Prefix})$ |        $\text{1}$        |
> > > | $\text{B}^{+}\text{Tree}$ |  `<day,rname>`   |       `day`       |           $\text{Y}$            |     $\text{RF(day)}$     |
> > > | $\text{B}^{+}\text{Tree}$ |   `<day,sid>`    |     `day,sid`     |           $\text{Y}$            | $\text{RF(day)*RF(sid)}$ |
> > > |       $\text{Hash}$       |  `<day,rname>`   |       `day`       |  $\text{N(Hash不能范围搜索)}$   |        $\text{1}$        |
> > >
> > > - 注意一个细节：这里的$\text{B}^{+}\text{Tree}$无论是$\text{Cluster/Uncluster}$，都无关紧要
>
> ## $\textbf{2.2. Projection}$(很少考)
>
> > ### $\textbf{2.2.1. Overview}$ 
> >
> > > **1️⃣**投影$\text{Process}$的流程
> > >
> > > |             场所             | 操作                                         |
> > > | :--------------------------: | -------------------------------------------- |
> > > |       磁盘$\to{}$内存        | 读取$\text{Data File}$中所有要处理的页到内存 |
> > > |       内存$\to{}$磁盘        | 在内存中投影(筛掉一些页)，剩下页写回磁盘     |
> > > | 磁盘(但排序时不断和内存交换) | 对投影后的页进行排序                         |
> > > |       磁盘$\to{}$内存        | 将投影+排序后的页，重新读回内存              |
> > >
> > > **2️⃣**为何$\text{Projection}$操作中需要$\text{Sort}$
> > >
> > > |                  原因                   | 解释                                                         |
> > > | :-------------------------------------: | ------------------------------------------------------------ |
> > > |            支持`DISTICT`操作            | ==去重时==，如果数据已经排序，那么合并相邻的相同记录即可     |
> > > | 提高$\text{B}^{+}\text{Tree}$的加载效率 | 已排序的数据插入$\text{B}^{+}\text{Tree}$时，不太可能导致大量的节点重新分配 |
> > > |           优化`GROUP BY`操作            | 比如按照`Age`分类，需要直到有几种`Age`，那就需要排序         |
> > >
> > > - 关于==去重==：$\text{Projection}$可能会$\text{Removing duplicates}$，例如假设$\text{20}$个员工隶属于$\text{4}$​个部门
> > >
> > >   ```sql
> > >   SELECT Depart FROM Employees;         -- 返回20个员工的20个部门(共20行)
> > >   SELECT DISTINCT Depart FROM Employees;-- 返回20个员工的4种部门(共4行)
> > >   ```
> > >
> > > **3️⃣**$\text{Projection Factor(PF)}$ 
> > >
> > > 1. 是投影处理的决定因素
> > > 2. 即选取的$\text{Column}$占$\text{Column}$总数的比，例如总共十个属性$\text{Project}$两个，则$\text{PF=0.2}$ 
> >
> > ### $\textbf{2.2.2. External Merge Sort: Divide \& Conquer}$(分治)
> >
> > > **1️⃣**排序原理
> > >
> > > |  $\textbf{Trem}$   |                   含义                    |
> > > | :----------------: | :---------------------------------------: |
> > > |  $\text{Passes}$   |     排序过程中数据读写硬盘的循环次数      |
> > > | $\text{NumPasses}$ | $\text{Passes}$数量(分多少次可以完成排序) |
> > > |   $\text{Runs}$    |            已排序的有序数据段             |
> > > |   $\text{N-Way}$   |     每次合并$\text{N}$个$\text{Runs}$     |
> > >
> > > 1. 分割整个数据集为多个小$\text{Runs}\to{}$每个$\text{Runs}$加载进内存排好序$\to{}$排序后的$\text{Runs}$写回磁盘
> > > 2. 将磁盘中的$\text{Runs}$有序合并为有关大的$\text{Runs}$​
> > >
> > > 😭采用$\text{External}$排序的原因在于内存不够大，需要轮换进入内存
> > >
> > > **2️⃣**$\text{2-Way External Merge Sort}$示例
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/33983312621.png" alt="33983312621" style="zoom:55%;" />  
> > >
> > > |    $\textbf{Trem}$     |               $\textbf{Value}$               |                      $\textbf{E.g.}$                       |
> > > | :--------------------: | :------------------------------------------: | :--------------------------------------------------------: |
> > > |   $\text{NumPasses}$   | $1 + \lceil \log_2 [\text{NPages(R)]}\rceil$ | $1 + \lceil \log_2 \text{7}\rceil=1 + \lceil 2.3\rceil=3 $ |
> > > | $\text{Total IO Cost}$ |        $\text{2×NPages(R)×NumPasses}$        |              $\text{2}\times{}7\times{}3=42$               |
> > >
> > > **3️⃣**基于外归并排序的$\text{Projection}$开销：等于以下每列之和(==记下即可==)
> > >
> > > | 步骤 | 操作                                             | $\textbf{Cost}$值                 |
> > > | :--: | ------------------------------------------------ | :-------------------------------- |
> > > | 读取 | 读取表($\text{Data File}$)中所有要排序的页到内存 | $\text{NPages(R)}$                |
> > > | 投影 | 投影筛掉一些页，将投影后的页写回磁盘             | $\text{NPages(R)×PF}$             |
> > > | 排序 | 对投影后的数据排序(每轮都要读写一次)             | $\text{NPages(R)×PF×2×NumPasses}$ |
> > > | 写回 | 将投影+排序后的页，重新读回内存                  | $\text{NPages(R)×PF}$             |
> >
> > ### $\textbf{2.2.3. External Hashing}$
> >
> > > **1️⃣**原理
> > >
> > > 1. 第一轮：内存有限$\to{}1$页用作缓存$+$剩下$\text{B-1}$页当作$\text{Bucket}$​
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/30913827511.png" alt="image-20240511073935359" style="zoom: 47%;" />  
> > >
> > >    - 硬盘的每页$\xrightarrow[缓存]{读取}$内存中的缓存页
> > >    - 缓存页的数据$\xrightarrow[\text{Hash}]{\text{H1}}$剩下的$\text{B-1}$个$\text{Bucket}$​中
> > >    - 满了的$\text{Bucket}\xrightarrow{读出}$硬盘中**若干**页(由于不够细分一个$\text{Bucket}$​​可能输出多页)
> > >    - 最终硬盘中有$\text{Bucket1→Bucket(B-1)}$共$\text{B-1}$个$\text{Bucket}$，每个$\text{Bucket}$中有若干页
> > >
> > > 2. 第二轮：试图用有限内存充分分类
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/13807891517.png" alt="13807891517" style="zoom:45%;" />  
> > >
> > >    - 硬盘$\text{Bucket1}$的每页/$\text{Bucket2}$的每页/..../$\text{Bucket(B-1)}$的每页$\xrightarrow[缓存]{读取}$内存中的缓存页
> > >    - 缓存页的数据$\xrightarrow[\text{Hash}]{\text{H2(注意是一个新的Hash函数)}}$新的$\text{B-1}$个$\text{Bucket}$​中
> > >    - 以此类推.............
> > >
> > > 3. 最后一轮：所有的数据得到了充分的细分，以至于最后每个$\text{Bucket}$​中只包含一个数据
> > >
> > > **2️⃣**基于$\text{External Hashing}$的$\text{Projection}$开销
> > >
> > > | 步骤 | 操作                                             | $\textbf{Cost}$值     |
> > > | :--: | ------------------------------------------------ | :-------------------- |
> > > | 读取 | 读取表($\text{Data File}$)中所有要排序的页到内存 | $\text{NPages(R)}$    |
> > > | 投影 | 投影筛掉一些页，将投影后的页写回磁盘             | $\text{NPages(R)×PF}$ |
> > > | 写回 | 将投影后的页，重新读回内存                       | $\text{NPages(R)×PF}$ |
>
> ## $\textbf{2.3. Join Algorithms}$ 
>
> > ### $\textbf{2.3.1. Nested Loops Join}$
> >
> > > **0️⃣**关于$\text{Inner/Outer Table}$​
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240511093730591.png" alt="image-20240511093730591" style="zoom:59%;" />  
> > >
> > > 1. 如果可以选$\text{→}$一般设定$\text{Outer}$为$\text{NPages}$​较小的表
> > > 2. 默认左边是$\text{Outer}$右边是$\text{Inner}$
> > >
> > > **1️⃣**原理
> > >
> > > |    $\textbf{Type}$     | $\textbf{Outer Table}$的每___ | $\xrightarrow{扫描}$ | $\textbf{Inner Table}$的每___ |
> > > | :--------------------: | :---------------------------: | :------------------: | :---------------------------: |
> > > |    $\text{Simple}$     |              行               | $\xrightarrow{扫描}$ |              页               |
> > > | $\text{Page-Oriented}$ |              页               | $\xrightarrow{扫描}$ |              页               |
> > > |     $\text{Block}$     |        块(包含多个页)         | $\xrightarrow{扫描}$ |              页               |
> > >
> > > **2️⃣**示意图与工作流程
> > >
> > > 1. $\text{Simple Nested Loops Join}$​
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240511123035510.png" alt="image-20240511123035510" style="zoom: 26.5%;" />  
> > >
> > >    |      $\textbf{Outer Page}$      | $\textbf{Inner Page}$ |
> > >    | :-----------------------------: | :-------------------: |
> > >    | $\text{Outer Page 1, Tuple 1}$  | $\text{Inner Page 1}$ |
> > >    | $\text{Outer Page 1, Tuple 1}$  | $\text{Inner Page 2}$ |
> > >    | $\text{Outer Page 1, Tuple 1}$  | $\text{Inner Page 3}$ |
> > >    | $\text{Outer Page 1, Tuple 1}$  | $\text{Inner Page 4}$ |
> > >    | $\text{Outer Page 1, Tuple 2}$  | $\text{Inner Page 1}$ |
> > >    |              .....              |         .....         |
> > >    | $\text{Outer Page 10, Tuple N}$ | $\text{Inner Page 4}$ |
> > >
> > > 2. $\text{Page-Oriented Nested Loops Join: }$内存不多不少，就占用三页
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240511101634537.png" alt="image-20240511101634537" style="zoom:50%;" />  
> > >
> > >    | $\textbf{Outer Page}$  | $\textbf{Inner Page}$ |
> > >    | :--------------------: | :-------------------: |
> > >    | $\text{Outer Page 1}$  | $\text{Inner Page 1}$ |
> > >    | $\text{Outer Page 1}$  | $\text{Inner Page 2}$ |
> > >    | $\text{Outer Page 1}$  | $\text{Inner Page 3}$ |
> > >    | $\text{Outer Page 1}$  | $\text{Inner Page 4}$ |
> > >    | $\text{Outer Page 2}$  | $\text{Inner Page 1}$ |
> > >    |         .....          |         .....         |
> > >    | $\text{Outer Page 10}$ | $\text{Inner Page 4}$ |
> > >
> > > 3. $\text{Block Nested Loops Join}$   
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240513080234516.png" alt="image-20240513080234516" style="zoom:33%;" /> 
> > >
> > >    |             $\textbf{Outer Page}$             | $\textbf{Inner Page}$ |
> > >    | :-------------------------------------------: | :-------------------: |
> > >    | $\text{Outer Page 1 + Outer Page 2(Block1)}$  | $\text{Inner Page 1}$ |
> > >    | $\text{Outer Page 1 + Outer Page 2(Block1)}$  | $\text{Inner Page 2}$ |
> > >    | $\text{Outer Page 1 + Outer Page 2(Block1)}$  | $\text{Inner Page 3}$ |
> > >    | $\text{Outer Page 1 + Outer Page 2(Block1)}$  | $\text{Inner Page 4}$ |
> > >    | $\text{Outer Page 3 + Outer Page 4(Block2)}$  | $\text{Inner Page 1}$ |
> > >    |                     .....                     |         .....         |
> > >    | $\text{Outer Page 9 + Outer Page 10(Block5)}$ | $\text{Inner Page 4}$ |
> > >
> > > **3️⃣**开销：外表扫描成本$+$内表扫描成本
> > >
> > > |    $\textbf{Type}$     |      外表扫描成本      |                    内表扫描成本                     |
> > > | :--------------------: | :--------------------: | :-------------------------------------------------: |
> > > |    $\text{Simple}$     | $\text{NPages(Outer)}$ | $\text{NTuples(Outer)}\text{×}\text{NPages(Inner)}$ |
> > > | $\text{Page-Oriented}$ | $\text{NPages(Outer)}$ | $\text{NPagees(Outer)}\text{×}\text{NPages(Inner)}$ |
> > > |     $\text{Block}$     | $\text{NPages(Outer)}$ | $\text{NBlocks(Outer)}\text{×}\text{NPages(Inner)}$ |
> > >
> > > 1. 外表所有页都要被读一次，所以成本为$\text{NPages(Outer)}$ 
> > > 2. $\text{NBlocks(Outer)=NPages(Outer)/(Memory-2)}$
> > >    - $\text{Memory-2}$为$\text{RAM}$中$\text{Outer Pages}$的数量，即一次从$\text{Outer Table}$​读入多少页
> > >    - 当$\text{NBlocks(Outer)}$​​​​​不为整数时，要==向上取整== 
> > >    - 分配$\text{RAM(Memory)}$越多，就会$\text{NBlocks(Outer)}$越低，从而开销越小
> > >
> > > **4️⃣**开销的最优解：$\begin{cases}\text{RAM}可把\text{Outer Table}全放进\to{}大小至少为\text{NPages(Outer)+2}\\\\最优解\to{}\text{Cost=NPages(Outer)+NPages(Inner)}\end{cases}$
> > >
> > > 1. 这其实不仅是$\text{NLJ}$的最优解，==也是全局最优解，因为这个解刚刚刚好是把两个表读进来== 
> > >
> > > 2. 在最优解不变的情况下为了节省内存$\to{}$==$\text{Outer}$表要尽量小(小表)== 
> >
> > ### $\textbf{2.3.2. Sort-Merge Join}$ 
> >
> > > **1️⃣**原理：以`A INNER JOIN B ON A.age = B.number`为例
> > >
> > > 1. 第一步：按照$\text{Join Column}$(此处分别为`age`和`number`)排序
> > >    - $\text{A}$表按照`age`排序，$\text{B}$​​表按照`numver`排序
> > >    - 目的在于：==让相同/相关的值物理上靠近，可以顺序访问$\text{→}$​加快合并==
> > > 2. 第二步：$\text{AB}$两表再进行$\text{Join}$​操作
> > > 3. $\text{Output}$: 一定是按照$\text{Join Column}$排好序的
> > >
> > > **2️⃣**排序的成本为$\text{0}$的情况：==$\text{Clustered + }$$\text{B}^{+}\text{Tree + }$$\text{Join Column}$是索引依据的$\text{Prefix}$== ​
> > >
> > > ```sql
> > > A INNER JOIN B ON A.age = B.number
> > > ```
> > >
> > > | 索引根据($\textbf{Composite Search Key}$) |          索引类型          | 表$\textbf{A}$无需排序 |
> > > | ----------------------------------------- | :------------------------: | :--------------------: |
> > > | `<A.age>`                                 | $\text{Clustered B}^{+}$树 |           ✔️            |
> > > | `<A.name>`                                | $\text{Clustered B}^{+}$树 |           ❌            |
> > > | `<A.age, A.name>`                         | $\text{Clustered B}^{+}$树 |           ✔️            |
> > > | `<A.name, A.age>`                         | $\text{Clustered B}^{+}$树 |           ❌            |
> > >
> > > **3️⃣**$\text{Cost = Sort(Outer)+ Sort(Inner)+ NPages(Outer)+ NPages(Inner)}$ 
> > >
> > > |    $\textbf{Cost}$     |              成因              |
> > > | :--------------------: | :----------------------------: |
> > > |  $\text{Sort(Outer)}$  |       将外表所有元素排序       |
> > > |  $\text{Sort(Inner)}$  |       将内表所有元素排序       |
> > > | $\text{NPages(Outer)}$ | 遍历外表的所有页以执行合并操作 |
> > > | $\text{NPages(Inner)}$ | 遍历内表的所有页以执行合并操作 |
> > >
> > > - $\text{Sort(X)=}\begin{cases} \text{2×NumPasses×NPages(X)}\\\\0\text{ (Clustered B}^{+}\text{ Index on Join Column Prefix)}\end{cases}$ 
> >
> > ### $\textbf{2.3.3. Hash Join}$(一般情况开销最小)
> >
> > > **1️⃣**原理：以按照`A.id = B.id`$\text{Join}$为例，其中`id`为连接键
> > >
> > > 1. $\text{Build Phase}$: `A.id`$\xrightarrow[\text{Hash}]{\text{H1哈希函数}}$​`H1(A.id)`构建$\text{Hash}$表$\text{A}$，==通常是选小表($\text{Inner}$)来构建$\text{Hash}$表==
> > > 2. $\text{Probe Phase}$(探测阶段):  
> > >    - `B.id`$\xrightarrow[\text{Hash}]{\text{H1哈希函数}}$`H1(B.id)`得到$\text{Hash}$值$\text{B(n)}$ 
> > >    - 在$\text{Hash}$表$\text{A}$中检索$\text{Hash}$​值$\text{B(n)}$则匹配，那么匹配的行进行$\text{Join}$
> > >
> > > **2️⃣**$\text{Cost=3×NPages(Outer)+3×NPages(Inner)}$​​​ ​
> >
> > ### $\textbf{2.3.4. Join Pipeline}$：减少$\textbf{Cost}$的一种方式
> >
> > > #### $\textbf{2.3.4.1. }$基本概念
> > >
> > > > **1️⃣**$\text{Left-Deep Join Tree}$​：
> > > >
> > > > 0. 多重$\text{Join: }$考虑$\text{Join}$的顺序和类型
> > > >
> > > > 1. $\text{Left-Deep Join Tree: }$是最优$\text{Join}$顺序(快速增长率)，方便在$\text{RAM}$中$\text{Pipeline}$并行处理
> > > >
> > > > 2. 示意图：默认左边的为$\text{Outer Table}$
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240512191103986.png" alt="image-20240512191103986" style="zoom: 43%;" />  
> > > >
> > > > **2️⃣**$\text{Pipeline}$
> > > >
> > > > 1. 概念：
> > > >
> > > >    - $\text{Direct “streaming” in memory}$
> > > >    - $\text{Of the output of one operation as the input of another operation}$
> > > >    - $\text{Without writing output to disk}$
> > > >
> > > > 2. 基于$\text{Left-Deep Join Tree}$的$\text{Pipeline}$​​示例
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240513002106358.png" alt="image-20240513002106358" style="zoom: 67%;" /> 
> > > >
> > > >    | $\textbf{Stage}$ |            $\textbf{Outer Page}$             | $\textbf{Inner Page}$ | $\textbf{Output Page}$                                       |
> > > >    | :--------------: | :------------------------------------------: | :-------------------: | :----------------------------------------------------------- |
> > > >    |    $\text{1}$    |                  $\text{A}$                  |      $\text{B}$       | $\text{A}\bowtie{}\text{B}\xrightarrow{\text{Move to}}\text{Outer Page}$ |
> > > >    |    $\text{2}$    |         $\text{A}\bowtie{}\text{B}$          |      $\text{C}$       | $\text{A}\bowtie{}\text{B}\bowtie{}\text{C}\xrightarrow{\text{Move to}}\text{Outer Page}$ |
> > > >    |    $\text{3}$    | $\text{A}\bowtie{}\text{B}\bowtie{}\text{C}$ |      $\text{D}$       | $\text{A}\bowtie{}\text{B}\bowtie{}\text{C}\bowtie{}\text{D}\xrightarrow{\text{Finally}}\text{Output}$ |
> > >
> > > #### $\textbf{2.3.4.2. Pipeline}$简化计算 
> > >
> > > > **1️⃣**简化计算$\text{1}$：$\text{Heap Scan}$不算$\text{Cost + }$上层$\text{Join}$也不减其$\text{Pipelining}$
> > > >
> > > > 1. 原因：$\text{Heap Scan}$扫描的成本，和其对应减去的$\text{Pipelining}$，都等于对应表大小，互相抵消
> > > >
> > > > 2. 示例$\text{1: Join}$(顶层)开销$\text{=NLJ}$开销
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/49521839130.png" alt="49521839130" style="zoom:30%;" /> 
> > > >
> > > >    - 原本开销：$\text{NLJ+}$两个$\text{Heap Scan}$​ 
> > > >    - $\text{Pipeline: }$减去两个$\text{Heap Scan}$ 
> > > >
> > > > 3. 示例$\text{2: Join}$(顶层)开销$\text{=SMJ}$开销$-\text{RSA(Result Size A)}$，==注意$\text{RSA}$是以$\text{Pages}$为单位==
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/77537735808.png" alt="77537735808" style="zoom:30%;" />  
> > > >
> > > >    - 原本开销：$\text{SMJ+}\text{Heap Scan}$ 
> > > >    - $\text{Pipeline: }$减去$\text{Heap Scan}$，减去$\text{RSA}$ 
> > > >
> > > > **2️⃣**简化计算$\text{2: Heap Scan}$自动忽略所有$\text{Index}$​，来看一个不忽略$\text{Index}$的示例
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240617140212192.png" alt=" " style="zoom: 25%;" /> 
> > > >
> > > > 1. 原本开销：$\text{HJ}$开销$\text{+Index Scan(Test)}$开销 (具体怎么算要看采用哪种$\text{Index}$ )
> > > >
> > > > 2. $\text{Pipeline: }$减去$\text{NPages(Test)}$，减去$\text{RSA}$ 
> > >

# $\textbf{3. Query Optimization}$

> ## $\textbf{3.1. Relational Algebra Equivalences}$
>
> > ### $\textbf{3.1.1. Selection/Projection Equivalences}$
> >
> > > **1️⃣**概览
> > >
> > > |               定律                |                             公式                             |          含义           |
> > > | :-------------------------------: | :----------------------------------------------------------: | :---------------------: |
> > > | $\small\text{Selection Cascade}$  | $\sigma_{\text{c}_1 \wedge \cdots \wedge \text{c}_\text{n}}(\text{R})\equiv \sigma_{\text{c}_1}\left(\ldots\left(\sigma_{\text{c}_\text{n}}(\text{R})\right)\right)$ | 多条件筛行$=$每个都筛下 |
> > > | $\small\text{Selection Commute}$  | $\sigma_{\text{c}_\text{1}}\left(\sigma_{\text{c}_2}(\text{R})\right)\equiv \sigma_{\text{c}_2}\left(\sigma_{\text{c}_\text{1}}(\text{R})\right)\equiv{}\sigma_{\text{c}_\text{1} \wedge \text{c}_\text{2}}(\text{R})$ | 先用哪个条件筛选无所谓  |
> > > | $\small\text{Projection Cascade}$ | $\pi_{\text{a}_\text{1}}(R) \equiv \pi_{\text{a}_\text{1}}\left(\ldots\left(\pi_{\text{a}_n}(R)\right)\right)$ | 随便投，最后一下说了算  |
> > >
> > > ⚠️注意事项：$\text{Projection Cascade}$中，假设$\text{A}$是$\text{Attributes}$的集合$\left(\text{A=}\{\text{a}_\text{1},\text{a}_2,...,\text{a}_\text{n}\}\right)$
> > >
> > > 1. 在$\pi{_{\text{A}_\text{1}}}(\ldots(\pi{_{\text{A}}}_\text{n}(\text{R})))$中，必须满足$\text{A}_{\text{n}}\subseteq{}\text{A}_{\text{m}}(\text{n<m})$
> > >
> > > 2. 以$\pi{_{\text{A}_\text{1}}}(\pi{_{\text{A}}}_\text{2}(\text{R}))$为例
> > >
> > >    |     ${\textbf{A}_\textbf{1}}$      |                  ${\textbf{A}_\textbf{2}}$                   |            是否适用$\textbf{Projection Cascade}$             |
> > >    | :--------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> > >    | $\{\text{a}_\text{1},\text{a}_2\}$ |              $\{\text{a}_\text{1},\text{a}_2\}$              | $\text{A}_{\text{1}}\subseteq{}\text{A}_{\text{2}}\to{}\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\text{R}))=\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\text{R})$ |
> > >    | $\{\text{a}_\text{1},\text{a}_2\}$ | $\{\text{a}_\text{1},\text{a}_2,\text{a}_\text{3},\text{a}_4\}$ | $\text{A}_{\text{1}}\subseteq{}\text{A}_{\text{2}}\to{}\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\pi{_{\text{a}_\text{1},\text{a}_\text{2},\text{a}_\text{3},\text{a}_\text{4}}}(\text{R}))=\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\text{R})$ |
> > >    | $\{\text{a}_\text{1},\text{a}_4\}$ |     $\{\text{a}_\text{1},\text{a}_2,\text{a}_\text{3}\}$     | $\text{A}_{\text{1}} \not\subseteq{}\text{A}_{\text{2}}$不适用 |
> > >
> > > **2️⃣**示例：关于第$\text{3}$个，注意要让==外部操作($\pi{}\text{/}\sigma$)的$\text{Column}\subseteq$ 里面操作($\pi$)的$\text{Column}$==  
> > >
> > > 1. $\large{}\sigma_{\text{age<18 }\wedge \text{ rating}>5}\text{(Sailors)}\Leftrightarrow\begin{cases} \sigma_{\text{age}<18}\left(\sigma_{\text{rating}>5}\text{(Sailors)}\right)\\\\ \left.\sigma_{\text{rating}>5}\left(\sigma_{\text{age}<18}\text{(Sailors}\right)\right)\end{cases}$ 
> > >
> > >    
> > > 
> > > 2. $\large\pi_{\text{age,rating}}(\text{Sailors})\Leftrightarrow \pi_{\text{age,rating}}\left(\pi_{\text{age,rating,sid}}\text{(Sailors)}\right)$ ​
> > >
> > >    
> > >
> > > 3. $\large\begin{cases}\begin{flalign*}& \pi_{\text{age,sid}}( \sigma_{\text{age<18 }\wedge \text{ rating}>5}\text{(Sailors))} &\\& \Updownarrow &\\& \begin{cases}\text{错误的: }\sigma_{\text{age<18 } \wedge \text{ rating}>5}\left(\pi_{\text{age, sid}}(\text{Sailors})\right)\\\\\text{正确的: }\sigma_{\text{age<18 } \wedge \text{ rating}>5}\left(\pi_{\text{age, sid, rating}}(\text{Sailors})\right)\end{cases}&\\\end{flalign*}\end{cases}$ ​
> > 
> > ### $\textbf{3.1.2. Join Equivalences}$
> > 
> > > |           定律            |                             公式                             |               含义                |
> >> | :-----------------------: | :----------------------------------------------------------: | :-------------------------------: |
> > > | $\text{Join Associative}$ | $\text{R}\bowtie(\text{S} \bowtie \text{T})\equiv(\text{R}\bowtie \text{S})\bowtie \text{T} \quad$ | $\text{Join}$顺序不影响结果(三个) |
> >> | $\text{Join Commutative}$ | $(\text{R}\bowtie \text{S})\equiv(\text{S}\bowtie \text{R})\quad$ | $\text{Join}$顺序不影响结果(两个) |
> > 
> 
> ## $\text{3.2. }$$\textbf{Query Optimization}$实例
> 
> > **1️⃣**$\text{Cross Product}$优化：转化为有条件的$\text{Join}$
>>
> > $\large{}\begin{flalign*}& \sigma_{\text{Sailors.sid=Reserves.sid}}(\text{Sailors} \text{×}\text{Reserves}) &\\& \Updownarrow &\\& \text{Sailors} \bowtie_{\text{Sailors.sid=Reserves.sid}} \text{Reserves} &\\& \Updownarrow &\\& \text{Sailors} \bowtie \text{Reserves }\end{flalign*}$ 
>>
> > **2️⃣**$\text{Predicate Pushdown: }$先给表格$\sigma{}$筛选$\to{}$降低数据量/减少计算
> >
> > $\large{}\begin{flalign*}
> > & \sigma_{\text{Sailors.age<18}}(\text{Sailors} \bowtie_{\text{Sailors.sid=Reserves.sid}} \text{Reserves}) &\\
> > & \Bigg\Updownarrow {\small{想办法把\text{Join}左边的\text{Sailors}表格变小}} &\\
> > &(\sigma_{\text{Sailors.age<18}}(\text{Sailors})) \bowtie_{\text{Sailors.sid=Reserves.sid}} \text{Reserves} &
> > \end{flalign*}$ 
> >
> > **3️⃣**$\text{Projection Pushdown: }$先给表格$\pi{}$筛选$\to{}$降低数据量/减少计算
> >
> > $\large{}\begin{flalign*}
> > & \pi_{\text{Sailors.sname}}(\text{Sailors} \bowtie_{\text{Sailors.sid=Reserves.sid}} 
> > \text{Reserves})&\\
> > & \Bigg\Updownarrow {\small{想办法把\text{Join}左右的\text{Sailors/Reserves}表格变小}\to{}\text{把两张表中用得到的Column都Project出来}} &\\
> > &\pi_{\text{Sailors.sname}}(\pi_{\text{sname, sid}}
> > (\text{Sailors}) \bowtie_{\text{Sailors.sid=Reserves.sid}} \pi_{\text{sid}}(\text{Reserves})) &
> > \end{flalign*}$​ 

# $\textbf{4. Query Cost}$计算题

> ## $\textbf{4.1. Of One Table}$
>
> > **1️⃣**原理：考虑各种可能的$\text{Query}$途径($\text{Scan/Index}$)$\to{}$选择开销最小的一个
> >
> > 1. 注意永远别忘了算一下$\text{Heap Scan}$，有时候算来算去反倒$\text{Heap Scan}$​​开销最小
> > 2. 除去$\text{Heap Scan}$其它所有类型的开销，都需要先估计$\text{RF }\downarrow{}$​
> >
> > **2️⃣**$\text{RF}$估算汇总
> >
> > |         条件         |                       $\text{RF}$等于                        |               补充说明               |
> > | :------------------: | :----------------------------------------------------------: | :----------------------------------: |
> > | ${}\text{Col=Value}$ |           $\cfrac{\text{Num}}{\text{NKeys(Col)}}$            |           ==处理离散变量==           |
> > |  $\text{Col>Value}$  | $\cfrac{\text{High(Col)}-\text{Value}}{\text{High(Col)}-\text{Low(Col)}}$ |           ==变量必须连续==           |
> > |  $\text{Col<Value}$  | $\cfrac{\text{Value}-\text{Low(Col)}}{\text{High(Col)}-\text{Low(Col)}}$ |           ==变量必须连续==           |
> > |  $\text{Join}$操作   |    $\cfrac{1}{\text{Max[NKeys(Col\_A), NKeys(Col\_B)]}}$     | 主键所在列$\text{JoinCol}$唯一值更多 |
> > |    无任何已知条件    |                  $\text{RF=}\cfrac{1}{10}$                   |                 默认                 |
> >
> > **3️⃣**基于`WHERE + Condition`的$\text{RF}$​​​选取
> >
> > ```sql
> > WHERE day<8/9/94 AND bid=5 AND sid=3
> > ```
> >
> > |      $\textbf{Type}$      | $\textbf{Index}$ | $匹配的\textbf{Prefix}$ |      是否适用于示例的查询       |      $\textbf{RF}$       |
> > | :-----------------------: | :--------------: | :---------------------: | :-----------------------------: | :----------------------: |
> > | $\text{B}^{+}\text{Tree}$ |  `<rname,day>`   |      $\text{N/A}$       | $\text{N}(无匹配\text{Prefix})$ |        $\text{1}$        |
> > | $\text{B}^{+}\text{Tree}$ |  `<day,rname>`   |          `day`          |           $\text{Y}$            |     $\text{RF(day)}$     |
> > | $\text{B}^{+}\text{Tree}$ |   `<day,sid>`    |        `day,sid`        |           $\text{Y}$            | $\text{RF(day)*RF(sid)}$ |
> > |       $\text{Hash}$       |  `<day,rname>`   |          `day`          |  $\text{N(Hash不能范围搜索)}$   |        $\text{1}$        |
> >
> > 1. 索引匹配的谓词：`WHERE + Condition`==必须要==包含$\text{Composite Search Key}$的$\text{Prefix}$
> > 2. $\text{Hash}$不能作$\text{Range Search}$
> >
> > **4️⃣**基于$\text{RF}$的$\text{Scan Cost Formula}$汇总
> >
> > | $\textbf{Structure}$ |     $\textbf{Index}$实现      | $\textbf{Index}$存储/角色 |                             开销                             |
> > | :------------------: | :---------------------------: | :-----------------------: | :----------------------------------------------------------: |
> > |  $\text{Heap File}$  |         $\text{N/A}$          |       $\text{N/A}$        |                      $\text{NPages(R)}$                      |
> > | $\text{Sorted File}$ |         $\text{N/A}$          |       $\text{N/A}$        |       $\log_{2}\text{[NPages(R)]+RF×}\text{NPages(R)}$       |
> > | $\text{index File}$  |   $\text{B}^{+}\text{Tree}$   |     $\text{Primary}$      |                 $\text{树高Height(Index)+1}$                 |
> > | $\text{index File}$  |         $\text{Hash}$         |     $\text{Primary}$      |     $\text{ProbeCost(Index)+1}\xrightarrow{默认为}1.2+1$     |
> > | $\text{index File}$  |   $\text{B}^{+}\text{Tree}$   | ==$\text{Unclustered}$==  | $\text{[NPages(I)+NTuples(R)]×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}$ |
> > | $\text{index File}$  | ==$\text{B}^{+}\text{Tree}$== |  ==$\text{Clustered}$==   | $\text{[NPages(I)+NPages(R)]×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}$ |
> > | $\text{index File}$  |         $\text{Hash}$         | ==$\text{Unclustered}$==  | $\text{NTuples(R)×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}\times{}2.2$ |
> > | $\text{index File}$  |         $\text{Hash}$         |  ==$\text{Clustered}$==   | $\text{NPages(R)×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}\times{}2.2$ |
> >
>
> ## $\textbf{4.2. Of Multiple Tables}$ 
>
> > **1️⃣**需要考虑的问题
> >
> > |            事项             | 注释                                                         |
> > | :-------------------------: | ------------------------------------------------------------ |
> > | $\text{Join}$所有可能的顺序 | 这不会影响$\text{Join}$结果但会影响开销，一般只考虑$\text{Left-Deep Join Tree}$ |
> > | $\text{Join}$所有可能的算法 | 但是排除最蠢的$\text{Cross Product}$                         |
> >
> > **2️⃣**对$\text{Pipeline}$​的处理
> >
> > 1. $\text{Heap Scan}$不算$\text{Cost + }$上层$\text{Join}$也不减其$\text{Pipelining}$​
> > 2. $\text{Heap Scan}$自动忽略所有$\text{Index}$
> >
> > **3️⃣**$\text{Join Cost}$汇总：注意小表为$\text{Outer}$
> >
> > |       $\textbf{Type}$       | 扫描成本                                                     |
> > | :-------------------------: | :----------------------------------------------------------- |
> > |     $\text{Simple NLJ}$     | $\text{NPages(Outer)+}\text{NTuples(Outer)}\text{×}\text{NPages(Inner)}$ |
> > | $\text{Page-Oriented  NLJ}$ | $\text{NPages(Outer)+}\text{NPagees(Outer)}\text{×}\text{NPages(Inner)}$ |
> > |     $\text{Block  NLJ}$     | $\text{NPages(Outer)+}\text{NPages(Outer)/(Memory-2)}\text{×}\text{NPages(Inner)}$ |
> > |   $\text{Hash Join(HJ)}$    | $\text{[NPages(Outer)+NPages(Inner)]×3}$                     |
> > |        $\text{SMJ}$         | $\text{[NPages(Outer)+NPages(Inner)]×(2×NumPasses+1)}$       |
> >
> > 1.  $\text{NPages(Outer)/(Memory-2)}$要==向上取整==
> > 2.  最优解：$\begin{cases}\text{RAM大小: }\text{NPages(Outer)+2}\\\\\text{开销: Cost=NPages(Outer)+NPages(Inner)}\end{cases}$​​ 
> > 3.  注意$\text{SMJ}$中可能出现$\text{Outer/Inner}$的$\text{NumPass}$​不一样的情况，此时就要分开讨论
>
> ## $\textbf{4.3. Pipeline}$​例题
>
> > ### $\textbf{4.3.0. }$前提条件
> >
> > > :one:$\text{SQL}$代码
> > >
> > > 1. 关系结构
> > >
> > >    ```sql
> > >    Movie(MovieID, name, genre, releasedate, duration, budget)
> > >    Show(ShowID, dateofShow, MovieID(FK), TheatreID(FK), attend, revenue)
> > >    Theatre(TheatreID, name, city, capacity)
> > >    ```
> > >
> > > 2. 查询
> > >
> > >    ```sql
> > >    SELECT *
> > >    FROM Movie AS M, Show AS S, Theatre AS T
> > >    WHERE M.MovieID = S.MovieID
> > >      AND S.TheatreID = T.TheatreID
> > >      AND S.revenue < 60000
> > >      AND M.genre = 'Comedy';
> > >    ```
> > >
> > > :two:参数
> > >
> > > 1. $\text{Data}$​参数
> > >
> > >    |          $\textbf{\\}$          | $\small\textbf{Genre}$ | $\small\textbf{Revenue}$ | $\small\textbf{Movie}$ | $\small\textbf{Show}$ | $\small\textbf{Theatres}$ |
> > >    | :-----------------------------: | :--------------------: | :----------------------: | :--------------------: | :-------------------: | :-----------------------: |
> > >    |    $\small\text{Num/Tuples}$    |      $\text{10}$       |      $\textbf{\\}$       |     $\text{5000}$      |   $\text{600,000}$    |       $\text{100}$        |
> > >    |      $\small\text{Range}$       |     $\textbf{\\}$      |  $\text{[0, 100,000]}$   |     $\textbf{\\}$      |     $\textbf{\\}$     |       $\textbf{\\}$       |
> > >    |   $\small\text{Tuples/Page}$    |     $\textbf{\\}$      |      $\textbf{\\}$       |      $\text{100}$      |      $\text{10}$      |        $\text{10}$        |
> > >    | $\small\Rightarrow\text{Pages}$ |     $\textbf{\\}$      |      $\textbf{\\}$       |      $\text{50}$       |    $\text{60,000}$    |        $\text{10}$        |
> > >
> > > 2. $\text{Index}$​​​参数
> > >
> > >    |    $\textbf{\\}$    |    $\small\textbf{Show.Revenue}$    | $\small\textbf{Movie.MovieID}$ |
> > >    | :-----------------: | :---------------------------------: | :----------------------------: |
> > >    | $\small\text{Type}$ | $\text{Clustered B}^{+}\text{Tree}$ |    $\text{Clustered Hash}$     |
> > >    | $\small\text{Size}$ |          $\text{10Pages}$           |        $\text{10Pages}$        |
> > >
> > > 3. $\text{Join}$​参数
> > >
> > >    | $\textbf{Movie}\bowtie{}\textbf{Show}$ | $\textbf{Theater}\bowtie{}\textbf{Show}$ |
> > >    | :------------------------------------: | :--------------------------------------: |
> > >    |        $\text{100Tuples/Page}$         |         $\text{100Tuples/Page}$          |
> > >
> > > 4. $\text{Sort}$参数：所有关系的排序，$\text{NumPass=2}$ 
> > >
> > > :three:其它：$\text{NLJ}$是$\text{Page-Oriented}$​的
> >
> > ### $\textbf{4.3.1. }$​前提条件
> >
> > > | $\textbf{SQL}$              |   $\textbf{RF}$   | 备注                                                       |
> > > | :-------------------------- | :---------------: | :--------------------------------------------------------- |
> > > | `M.MovieID = S.MovieID`     | $\cfrac{1}{5000}$ | `MovieID`是$\text{Movie(5000}$个$\text{)}$的$\text{PK}$    |
> > > | `S.TheatreID = T.TheatreID` | $\cfrac{1}{100}$  | `TheatreID`是$\text{Theatre(100}$个$\text{)}$的$\text{PK}$ |
> > > | `S.revenue < 60000`         |  $\cfrac{6}{10}$  | 范围$\text{[0, 100,000]}$                                  |
> > > | `M.genre = 'Comedy'`        |  $\cfrac{1}{10}$  | 共十种                                                     |
> >
> > ### $\textbf{4.3.2. Plan A}$​ 
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240617124259352.png" alt="image-20240617124259352" style="zoom: 46%;" /> 
> > >
> > > :one:$\text{RSA}$计算
> > >
> > > 1. $\text{NTuples(M)×NTuples(S)×RF(M}\bowtie\text{S)}=5000×600000×\cfrac{1}{5000}$​  
> > > 2. 结果为$600000\text{Tuples}$，记得转化为$\text{6000Pages (100Tuples/Page)}$​
> > >
> > > :two:$\text{B}$处$\text{NLJ(Page-Oriented)}$计算，默认左边为$\text{Outer}$ 
> > >
> > > 1. $\text{NPages(M)+}\text{NPagees(M)}\text{×}\text{NPages(S)}=50+50×60000$
> > >
> > > 2. 结果为$\text{3000050 I/O}$​  
> > >
> > > :three:$\text{C}$处$\text{SMJ}$计算
> > >
> > > 1. $\text{[RSA+NPages(T)]×(2×NumPasses+1)-RSA=(6000+10)×5-6000}$ 
> > > 2. 结果为$\text{24050 I/O}$​ 
> >
> > ### $\textbf{4.3.2. Plan B}$ 
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240617131414662.png" alt="image-20240617131414662" style="zoom:65%;" />  
> > >
> > > :one:$\text{RSA}$计算
> > >
> > > 1. $\text{NTuples(S)×RF(Revenue)=600000×}\cfrac{6}{10}$ 
> > >
> > > 2. 结果为$\text{360000Tuples}$，即$\text{36000Pages}$ 
> > >
> > > :two:$\text{RSB}$计算
> > >
> > > 1. $\text{NTuples(RSA)×NTuples(T)×RF(S}\bowtie\text{T)}=360000×100×\cfrac{1}{100}$  
> > > 2. 结果为$\text{360000Tuples}$，也就是$\text{3600Pages}$​ 
> > >
> > > :three:$\text{C}$处$\text{Index Scan}$开销，注意是$\text{Clustered B}^{+}\text{Tree}$ 
> > >
> > > 1. $\text{[NPages(Index)+NPages(S)]×RF(Revenue)=(10+60000)×}\cfrac{6}{10}$
> > > 2. 结果为$\text{36006 I/O}$ 
> > >
> > > :four:$\text{D}$处$\text{SMJ}$开销
> > >
> > > 1. $\text{[RSA+NPages(Inner)]×(2×NumPasses+1)-RSA}=(36000+10)×5-36000$
> > > 2. 开销为$\text{144050 I/O}$ 
> > >
> > > :five:$\text{E}$处开销$\text{ = HJ}$开销$\text{ + Index Scan}$开销
> > >
> > > 1. $\text{HJ=[RSB+NPages(M)]×3-RSB-NPages(M)=(3600+50)×2}$
> > > 2. $\text{Index Scan(M)=NPages(M)×RF×2.2}=50×2.2$
> > >    - 注意此处是$\text{Clustered Hash}$，并且$\text{RF=1}$ 
> > >
> > > 3. 结果为$\text{7300+110=7410 I/O}$ 
