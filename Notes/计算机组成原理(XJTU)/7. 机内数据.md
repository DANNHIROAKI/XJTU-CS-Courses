<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240208173106272.png" alt="image-20240208173106272" style="zoom: 60%;" />  

⚠️此外还有多媒体类型，如视频/音频，但此处不讨论

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/77777.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/77777.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/77777.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/77777.html)==**

# $\text{PART-Ⅰ}$ 杂项

# 1. 非数值数据

> ## 1.1. 字符与字符串
>
> > ### 1.1.1. 西文字符
> >
> > > **1️⃣**原理：给每个字符一个二进制编码，作为其机内表示
> > >
> > > **2️⃣**$\text{ASCII}$：用低$7$为表示字符，最高位可作为——恒$0$标识位/奇偶校验位/扩展位
> >
> > ### 1.1.2. 汉字
> >
> > > **1️⃣**汉字输入——输入码：常见三种方案，数字编码(电报码)/字音编码(拼音)/字形编码(五笔)
> > >
> > > **2️⃣**汉字表示——交换码：如国标码(基本汉字编码字符集)，结构如下
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240208212932349.png" alt="image-20240208212932349" style="zoom: 67%;" /> 
> > >
> > > "红"$\to{}$位于$\text{26}$区$\text{76}$位$\to{}$区位码$\text{2676 D}$$\to{}$国标码$\text{3A6C H}$
> > >
> > > **3️⃣**汉字处理——机内码：基于国标码
> > >
> > > |     $\text{ASCII}$机内表示      | 第三字节 |               第二字节                | 第一字节 |
> > > | :-----------------------------: | :------: | :-----------------------------------: | :------: |
> > > |    $\text{ASCII}$最高位为$0$    |   $\#$   | 最高位为$1$(汉字标识)/低$7$位为国标码 |   同左   |
> > > | $\text{ASCII}$最高位为扩展/校验 | 汉字标识 |               汉字表示                | 汉字表示 |
> > >
> > > **4️⃣**汉字输出——字模码：采用点阵描述，点阵中有笔画的地方点上黑点(用$1$表示)
> >
> > ### 1.1.3. 字符串的向量表示法
> >
> > > **1️⃣**字符串：就是一串字符连一起
> > >
> > > **2️⃣**向量表示法：字符串中的字符在主存中顺序排列，以首地址$+$串长为参数
> > >
> > > **3️⃣**`if (A<B) READ(C)`向量表示法实例：分为从高到低(左)/从低到高(右)两种
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240208204741705.png" alt="image-20240208204741705" style="zoom: 32%;" /> 
>
> ## 1.2. 逻辑数
>
> > **1️⃣**本质特征：$\text{1/0}$表示真假(控制信号有无)
> >
> > **2️⃣**注意事项：在逻辑指令中默认操作数是逻辑数，按位操作

# 2. 十进制数的表示

> ## 2.1. $\text{BCD}$编码：$4$位二进制$\xrightarrow{16选10}1$位十进制
>
> > **1️⃣**有权码
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240208221502844.png" alt="image-20240208221502844" style="zoom:50%;" /> 
> >
> > 1. 原理：四位二进制，每一位都有权，为$1$时加上权
> > 2. 以$\text{5211}$码为例
> >
> > | 权值  | $\text{5}$ | $\text{2}$ | $\text{1}$ | $\text{1}$ | 十进制表示  |
> > | ----- | ---------- | ---------- | ---------- | ---------- | ----------- |
> > | 编码1 | $1$        | $0$        | $1$        | $0$        | $5×1+1×1=6$ |
> > | 编码2 | $0$        | $1$        | $0$        | $1$        | $2×1+1×1=3$ |
> >
> > **3️⃣**无权码​
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240208222431351.png" alt="image-20240208222431351" style="zoom:50%;" /> 
> >
> > 1. 关于余$3$码
> >    - 规则：$8421$码$+011\text{B}$
> >    - 是一种==自补码==：即$a+b=9\iff{}a\xleftrightarrow{按位取反}b$​
> > 2. 关于格雷码(==循环码==)
> >    - 规则：$a$和$a+1$对应的四位二进制数，只有$1$位不一样
> >    - 特点：数的转换速度快，有多种编码方案
>
> ## 2.2. 十进制数串的表示
>
> > **1️⃣**字符串形式：将十进制数看成一串字符串，数字用数字的$\text{ASCII}$​码表示
> >
> > |      二进制       |   十进制    |  十六进制   | 字符/缩写  |
> > | :---------------: | :---------: | :---------: | :--------: |
> > | $\text{00110000}$ | $\text{48}$ | $\text{30}$ | $\text{0}$ |
> > | $\text{00110001}$ | $\text{49}$ | $\text{31}$ | $\text{1}$ |
> > | $\text{00110010}$ | $\text{50}$ | $\text{32}$ | $\text{2}$ |
> > | $\text{00110011}$ | $\text{51}$ | $\text{33}$ | $\text{3}$ |
> > | $\text{00110100}$ | $\text{52}$ | $\text{34}$ | $\text{4}$ |
> > | $\text{00110101}$ | $\text{53}$ | $\text{35}$ | $\text{5}$ |
> > | $\text{00110110}$ | $\text{54}$ | $\text{36}$ | $\text{6}$ |
> > | $\text{00110111}$ | $\text{55}$ | $\text{37}$ | $\text{7}$ |
> > | $\text{00111000}$ | $\text{56}$ | $\text{38}$ | $\text{8}$ |
> > | $\text{00111001}$ | $\text{57}$ | $\text{39}$ | $\text{9}$ |
> >
> > 1. 前分隔数字串：正负号放在数字前面，用$\text{+/-}$的$\text{ASCII}$码表示
> >
> >    | $+$          | $2$          | $3$          | $6$          | $+236$                 |
> >    | ------------ | ------------ | ------------ | ------------ | ---------------------- |
> >    | $\text{2BH}$ | $\text{32H}$ | $\text{33H}$ | $\text{36H}$ | $\text{2B 32 33 36 H}$ |
> >
> > 2. 后嵌入数字串：
> >
> >    - 正数：不做任何变化
> >    - 负数：低位数的$\text{ASCII}$高四位$\text{0011→0111}$​
> >
> > **2️⃣**==压缩十进制数串==：最理想的表示方式
> >
> > 1. 数的表示规则
> >    - 数值：砍掉数字$\text{ASCII}$的高四位，用低四位($\text{0000-1001}$)表示数，其实就是$\text{8421}$码
> >    - 符号：$\text{1100(CH)}$为正/$\text{1101(DH)}$为负，放在最低位数之后
> >    - 奇偶补全：十进制数值位$+$一个数值位$=$偶数，如果为奇数就往前补$0$
> >    - 示例：$\text{-12 = 12DH}\xrightarrow{往前补一个十进制0}\text{012DH = 0000 0001 0002 1101}$​
> > 2. 表征参数：串首主存地址$+$位长(不包括符号位)，注意位长位$0$代表数值$0$​

# 3. 校验码(了解即可)

> ## 3.1. 水平奇偶校验：检错不纠错
>
> > **1️⃣**奇/偶校验：
> >
> > 1. 发送端：信息后加$\text{1bit}$的校验，使得1的个数是奇数/偶数
> > 2. 接收端：检测到$\text{1}$有奇数/偶数个，则认为没出错(否则重传)
> >
> > **2️⃣**特点：二比特同时出错，检测不出
>
> ## 3.2. 循环冗余码$\text{CRC}$：检错不纠错
>
> > ### 3.2.1. 示例
> >
> > > **1️⃣**前提条件：
> > >
> > > 1. 数据单元为$\text{101001}$，对应$G(x)=x^5+x^3+1$
> > > 2. ==强制规定==生成码为$\text{1101}$，规定生成多项式为$G(x)=x^3+x^2+1$
> > > 3. 令$r\text{=}$生成码位数$\text{-1}$，为检测位位数
> > >
> > > **2️⃣**发送端行为
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/61N84AYUU67%7B%247ERI16GW52.png" alt="61N84AYUU67{$7ERI16GW52" style="zoom:33%;" /> 
> > >
> > > 1. 构造被除数：原始数据$\text{+0}$(个数等于生成码位数$\text{-1}$)$\text{→<101001><000}$(检测位)$\text{>}$
> > > 2. 除数：就是生成码，即$\text{1101}$
> > > 3. 执行除法：注意图中的$\oplus$表示异或，==余数就是校验码==，这里是$\text{001}$
> > > 4. 发出数据$\text{+}$校验码，为$\text{<101001><001>}$
> > >
> > > **3️⃣**接收端行为：
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101050614110.png" alt="image-20240101050614110" style="zoom:33%;" /> 
> > >
> > > 1. 收到$\text{<101001><001>}$
> > > 2. 执行除法，被除数是收到数据，除数是生成码
> > > 3. 余数为$\text{0}$，则没出错
> >
> > ### 3.2.2. 检错性能
> >
> > > **1️⃣**有$r$检测位的多项式，能检出所有小于等于$r$位的突发
> > >
> > > **2️⃣**长度大于$r+1$的错误逃脱的概率是$\cfrac{1}{2^r}$
>
> ## 3.3. 海明码：可纠错
>
> > ### 3.3.1. 求海明码：$\text{D=101101}$为例
> >
> > > **1️⃣**确定校验码位数$r$：==满足$k\leq{}2^r-r-1$，$k$为数据位数==，此处$k=6$所以至少有$r=4$
> > >
> > > **2️⃣**确定校验码放哪：==第$i$位校验码$P_i$放在总的$2^{i-1}$位==，此处如下(数据按顺序填满剩下的位)
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101093154656.png" alt="image-20240101093154656" style="zoom:77%;" />  
> > >
> > > **3️⃣**求出校验值
> > >
> > > 1. 假设出错位为==$e_1,e_2,...,e_r$==，此处是$e_1,e_2,e_3,e_4$
> > >
> > > 2. 用$r$位二进制数 ，给==$M_1,M_2,...,M_{k+r}$==标号，此处是$M_1,M_2,...,M_{10}$
> > >
> > > 3. 找出$M$与$r$的对应关系
> > >
> > >    |          | 标号 | $e_4$    | $e_3$    | $e_2$    | $e_1$    |
> > >    | -------- | ---- | -------- | -------- | -------- | -------- |
> > >    | $M_1$    | 0001 | 无关     | 无关     | 无关     | ==有关== |
> > >    | $M_2$    | 0010 | 无关     | 无关     | ==有关== | 无关     |
> > >    | $M_3$    | 0011 | 无关     | 无关     | ==有关== | ==有关== |
> > >    | $M_4$    | 0100 | 无关     | ==有关== | 无关     | 无关     |
> > >    | $M_5$    | 0101 | 无关     | ==有关== | 无关     | ==有关== |
> > >    | $M_6$    | 0110 | 无关     | ==有关== | ==有关== | 无关     |
> > >    | $M_7$    | 0111 | 无关     | ==有关== | ==有关== | ==有关== |
> > >    | $M_8$    | 1000 | ==有关== | 无关     | 无关     | 无关     |
> > >    | $M_9$    | 1001 | ==有关== | 无关     | 无关     | ==有关== |
> > >    | $M_{10}$ | 1010 | ==有关== | 无关     | ==有关== | 无关     |
> > >
> > > 4. 整理有关项，然后异或
> > >
> > >    | 出错位 | 有关项           | 异或操作                                                     |
> > >    | ------ | ---------------- | ------------------------------------------------------------ |
> > >    | $e_1$  | $M_{1,3,5,7,9}$  | $e_{1}=M_{1}\oplus{}M_{3}\oplus{}M_{5}\oplus{}M_{7}\oplus{}M_{9}$ |
> > >    | $e_2$  | $M_{2,3,6,7,10}$ | $e_{2}=M_{2}\oplus{}M_{3}\oplus{}M_{6}\oplus{}M_{7}\oplus{}M_{10}$ |
> > >    | $e_3$  | $M_{4,5,6,7}$    | $e_{3}=M_{4}\oplus{}M_{5}\oplus{}M_{6}\oplus{}M_{7}$         |
> > >    | $e_4$  | $M_{8,9,10}$     | $e_{4}=M_{8}\oplus{}M_{9}\oplus{}M_{10}$                     |
> > >
> > > 5. 代入**2️⃣**中数据，求出$e$表达式
> > >
> > >    | 出错位 | 表达式                                                      |
> > >    | ------ | ----------------------------------------------------------- |
> > >    | $e_1$  | $P_{1}\oplus{}D_{1}\oplus{}D_{2}\oplus{}D_{4}\oplus{}D_{5}$ |
> > >    | $e_2$  | $P_{2}\oplus{}D_{1}\oplus{}D_{3}\oplus{}D_{4}\oplus{}D_{6}$ |
> > >    | $e_3$  | $P_{3}\oplus{}D_{2}\oplus{}D_{3}\oplus{}D_{6}$              |
> > >    | $e_4$  | $P_{4}\oplus{}D_{5}\oplus{}D_{6}$                           |
> > >
> > > 6. 如果没有错误信息，则必须由==$e_1,e_2,e_3,e_4=0$==，注意==$A\oplus{}B=0\iff{A=B}$==，所以有
> > >
> > >    | 校验码  | 表达式                                           | 取值 |
> > >    | ------- | ------------------------------------------------ | ---- |
> > >    | $P_{1}$ | $D_{1}\oplus{}D_{2}\oplus{}D_{4}\oplus{}D_{5}$   | 0    |
> > >    | $P_{2}$ | ${}D_{1}\oplus{}D_{3}\oplus{}D_{4}\oplus{}D_{6}$ | 0    |
> > >    | $P_{3}$ | ${}D_{2}\oplus{}D_{3}\oplus{}D_{6}$              | 0    |
> > >    | $P_{4}$ | $D_{5}\oplus{}D_{6}$                             | 1    |
> > >
> > > 7. 填充，最后得到海明码
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101095843763.png" alt="image-20240101095843763" style="zoom: 59%;" /> 
> >
> > ### 3.3.2. 通过海明码校验
> >
> > > **1️⃣**先通过这张表求出$e$
> > >
> > > | 出错位 | 有关项           | 异或操作                                                     |
> > > | ------ | ---------------- | ------------------------------------------------------------ |
> > > | $e_1$  | $M_{1,3,5,7,9}$  | $e_{1}=M_{1}\oplus{}M_{3}\oplus{}M_{5}\oplus{}M_{7}\oplus{}M_{9}$ |
> > > | $e_2$  | $M_{2,3,6,7,10}$ | $e_{2}=M_{2}\oplus{}M_{3}\oplus{}M_{6}\oplus{}M_{7}\oplus{}M_{10}$ |
> > > | $e_3$  | $M_{4,5,6,7}$    | $e_{3}=M_{4}\oplus{}M_{5}\oplus{}M_{6}\oplus{}M_{7}$         |
> > > | $e_4$  | $M_{8,9,10}$     | $e_{4}=M_{8}\oplus{}M_{9}\oplus{}M_{10}$                     |
> > >
> > > **2️⃣**结果按照$e_4,e_3,e_2,e_1$排列，排列结果化为十进制$N$，那么出错的就是第$N$位
> >
> > ### 3.3.3. 海明距离
> >
> > > **1️⃣**含义：把两个码字对齐后，不相同的位的个数
> > >
> > > **2️⃣**海明距离和编码方案
> > >
> > > | 目的            | 编码方案的海明距离 |
> > > | --------------- | ------------------ |
> > > | 检测出$d$位错误 | $d+1$              |
> > > | 纠正$d$位错误   | $2d+1$             |
> > >
> > > **3️⃣**$L-1\geq{D+C}$：$LDC$分别为编码长度/检错位数/纠错位数

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{分割线}\Huge{-------}}
$$

# $\text{PART-Ⅱ}$定点数

# 1. 定点数的表示

> ## 1.1. 从真值→机器数：正负号和小数点的机内处理
>
> > **1️⃣**正负号的机内表示
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240209230942951.png" alt="image-20240209230942951" style="zoom: 65%;" />  
> >
> > |   类型   |                       本质特性                        | $\text{Min}$ | $\text{Max}$ |
> > | :------: | :---------------------------------------------------: | :----------: | :----------: |
> > | 无符号数 |             $n$位机器字长全部位都表示数值             |     $0$      |  $(2^n-1)$   |
> > | 有符号数 | 最高位安排$\text{0/1}$表示正负，其余$n-1$位仍表示数值 |  $-2^{n-1}$  | $2^{n-1}-1$  |
> >
> > **2️⃣**小数点的机内定位
> >
> > 1. 隐含表示：实现约定好小数点的位置，按照约定的方式识别数值，约定方式分为定点和浮点
> > 2. 定点小数：是纯小数，小数点藏在符号位后
> > 3. 定点整数：是纯整数，小数点放最最后面
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240210000256042.png" alt="image-20240210000256042" style="zoom:80%;" /> 
> >
> > **3️⃣**真值$\&$机器数：$真值\xrightarrow[这一过程\text{aka}数字化]{\text{+/-}区分正负\to{}0/1区分正负}机器数$
> >
> > 1. 真值：数学语言中数的表示
> > 2. 机器数：计算机内数据表示，编码码值有原码/反码/补码/移码
>
> ## 1.2. 机器码：原码/补码/反码
>
> > ### 1.2.1. 原码
> >
> > > |      |                           整数原码                           |                           小数原码                           |                          $0$的原码                           |
> > > | :--: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> > > | 规则 |           符号位$\xleftrightarrow{拼接}$整数数值位           |           符号位$\xleftrightarrow{拼接}$小数数值位           |                          分$+0/-0$                           |
> > > | 示例 | $\text{[+101]}_{原}=\text{0,101 }$<br/>$[-\text{101]}_{原}=\text{1,101 }$ | $\text{[+0.101]}_{原}=\text{0.101}$<br/>$[-\text{0.101]}_{原}=\text{1.101}$ | $\text{[+0.000]}_{原}=\text{0.000}$<br/>$[-\text{0.000]}_{原}=\text{1.000}$ |
> > > | 范围 |                       $\pm{}(1-2^{n})$                       |                      $\pm{}(1-2^{-n})$                       |                             $\#$                             |
> > >
> > > ⚠️小数表示和整数表示基本一致，仅仅在于小数点位置不一样，下同
> >
> > ### 1.2.2. 反码
> >
> > > |      |                           整数反码                           |                           小数反码                           |                          $0$的反码                           |
> > > | :--: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> > > | 规则 | 正数：符号位$\xleftrightarrow{拼接}$数值位<br/>负数：符号位$\xleftrightarrow{拼接}$数值位取反 | 正数：符号位$\xleftrightarrow{拼接}$数值位<br/>负数：符号位$\xleftrightarrow{拼接}$数值位取反 |                          分$+0/-0$                           |
> > > | 示例 | $\text{[+101]}_{反}=\text{0,101 }$<br/>$[-\text{101]}_{反}=\text{1,010 }$ | $\text{[+0.101]}_{反}=\text{0.101}$<br/>$[-\text{0.101]}_{反}=\text{1.010}$ | $\text{[+0.000]}_{反}=\text{0.000}$<br/>$[-\text{0.000]}_{反}=\text{1.111}$ |
> > > | 范围 |                       $\pm{}(1-2^{n})$                       |                      $\pm{}(1-2^{-n})$                       |                             $\#$                             |
> > >
> > > ⚠️取反的电路实现：逐位异或(不同为真) 
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240213154002482.png" alt="image-20240213154002482" style="zoom: 55%;" />  
> > >
> > > |       原数据       | $0$  | $1$  |     备注     |
> > > | :----------------: | :--: | :--: | :----------: |
> > > | 与$\text{M=0}$异或 | $0$  | $1$  |   保持原样   |
> > > | 与$\text{M=1}$异或 | $1$  | $0$  | ==逐位取反== |
> >
> > ### 1.2.3. 补码(模2)
> >
> > > |      |                           整数补码                           |                           小数补码                           |  $0$的补码   |
> > > | :--: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------: |
> > > | 规则 | 正数：符号位$\xleftrightarrow{拼接}$数值位<br/>负数：符号位$\xleftrightarrow{拼接}$数值位取反$+1$ | 正数：符号位$\xleftrightarrow{拼接}$数值位<br/>负数：符号位$\xleftrightarrow{拼接}$数值位取反$+1\text{LSB*}$ | $\text{0**}$ |
> > > | 示例 | $\text{[+101]}_{补}=\text{0,101 }$<br/>$[-\text{101]}_{补}=\text{1,011 }$ | $\text{[+0.101]}_{补}=\text{0.101}$<br/>$[-\text{0.101]}_{补}=\text{1.011}$ |     $\#$     |
> > > | 范围 |                      $(-2^{n},2^{n}-1)$                      |                  $(-1,1-2^{-n})\text{***}$                   |     $\#$     |
> > >
> > > $\text{*LSB}$：是指最低位，$\text{1LSB}$是指最低位$+1$
> > >
> > > $\text{**}$补码$0$：相比原码反码正负定义域都定义了$0$，补码$0$​唯一且只出现在正定义域
> > >
> > > $\text{***}$补码$-1$：下限到$-1$源自$0$唯一空出一个码点，$[-1.000]_{补}=1.000$(这个$1$同时表示符号和数值)
> > >
> > > 🥰几点补充
> > >
> > > **1️⃣**负数补码的电路逻辑实现依据
> > >
> > > 1. 从最低位开始，从右往左查找$1$，找到的第一个$1$为分界线
> > > 2. 符号置$1\xleftrightarrow{拼接}$分解左边取反$\xleftrightarrow{拼接}$​分解及其右边不变
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240210134537949.png" alt="image-20240210134537949" style="zoom:50%;" /> 
> > >
> > > **2️⃣**$X=[[X]_{补}]_{补}$
> > >
> > > 1. 即：原码$\xrightarrow{变补码一次}$补码$\xrightarrow{变补码二次}$原码，但注意这一过程不包含符号
> > > 2. 示例：$-0.10110\xrightarrow[符号位: 单独变换]{数值位: 高位变反\text{or}取反+1}1.01010\xrightarrow[符号位: 单独变换]{数值位: 高位变反\text{or}取反+1}-0.10110$​
> > >
> > > **3️⃣**==模四补码==
> > >
> > > 1. 表示规则：$00$表示$+$，$11$表示$-$，数值部分处理与原来(二阶补码)一样
> > > 2. 运算规则：符号位$-$数值部分一起运算，高符号位产生进位直接丢掉
> > > 

# 2. 定点算数运算

> ## 2.1. 定点加减运算(补码)
>
> > ### 2.1.1. 特点(模$2/4$皆适用)
> >
> > > **1️⃣**数类型：操作数/结果都是模2/4补码
> > >
> > > **2️⃣**符号位：
> > >
> > > 1. 单/双符号位和数值位一起运算(原码符号位则单独处理)
> > > 2. 结果的单/双符号位由运算自动产生
> > >
> > > **3️⃣**模溢出：高位产生进位自动丢掉
> >
> > ### 2.1.2. 规则(模$2/4$皆适用)
> >
> > > **1️⃣**运算规则
> > >
> > > 1. $\text{[X}\pm\text{Y]}_{补}=\text{[X]}_{补}\pm{}\text{[Y]}_{补}\xrightarrow{}\begin{cases}\text{[X}+\text{Y]}_{补}=\text{[X]}_{补}+\text{[Y]}_{补}\\\\\text{[X}-\text{Y]}_{补}=\text{[X]}_{补}+\text{[-Y]}_{补}\end{cases}$
> > > 2. $\text{[Y]}_{补}\xrightarrow{每位取反}\xrightarrow{最低位+1}\text{[-Y]}_{补}$(减法中，减数求补后再与被减数相加)​
> > >
> > > **2️⃣**示例：$\text{X}=0.1011011\text{, }\text{Y}=-0.0010010$求$\text{[X-Y]}_{补}$​
> > >
> > > 1. $0.1011011\to{}\text{[X]}_{补}$
> > > 2. $-0.0010010\to{}1.1101101\to{}1.1101110\to{}\text{[Y]}_{补}$
> > > 3. ${}1.1101110\to{}0.0010001\to{}0.0010010\to{}\text{[-Y]}_{补}$
> > >
> > > 4. $\text{[X-Y]}_{补}=\text{[X]}_{补}+\text{[-Y]}_{补}=0.1011011+0.0010010=0.1101101$
> >
> > ### 2.1.3. 溢出判断
> >
> > > **1️⃣**溢出基本概念
> > >
> > > 1. 溢出原因
> > >
> > >    |  种类  |                        本质特征                         |
> > >    | :----: | :-----------------------------------------------------: |
> > >    | 正溢出 | 结果本应是正数，但是超出最大可表示正数，导致符号位为$1$ |
> > >    | 负溢出 | 结果本应是负数，但是超出最小可表示负数，导致符号位为$0$ |
> > >
> > > 2. 溢出后果：数值位侵入符号位
> > >
> > > **2️⃣**模$2$溢出判别
> > >
> > > | 方法 | 描述                                                         |
> > > | :--: | :----------------------------------------------------------- |
> > > | 法1  | 将减法全化为加法，则正数$+$正数$=$负数$/$负数$+$负数$=$正数时溢出 |
> > > | 法2  | 最高数值位$/$符号位，二者之一产生进位                        |
> > >
> > > **3️⃣**模$4$溢出判别：
> > >
> > > 1. 两符号位相异是表明溢出
> > > 2. 最高符号位为正确的符号$\to{}01$表示正溢出$/10$表示负溢出
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240213171131224.png" alt="image-20240213171131224" style="zoom:40%;" /> 
> >
> > ### 2.1.4. 硬件逻辑
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240213173613501.png" alt="image-20240213173613501" style="zoom:33%;" />
>
> ## 2.2. 定点乘法运算
>
> > ### 2.2.1. 原码一位乘
> >
> > > **1️⃣**基本公式
> > >
> > > 1. 前提：$\begin{cases}
> > >    \text{[X]}_{原}=\text{X}_s|\text{X}_1\text{X}_2\text{...X}_n\\\\
> > >    \text{[Y]}_{原}=\text{Y}_s|\text{Y}_1\text{Y}_2\text{...Y}_n
> > >    \end{cases}$   运算前先检测操作数是否含$0$
> > >
> > > 2. 处理:$\begin{array}{c}\text{[P]}_{原}=\text{[X×Y]}_{原}\to{}\begin{cases}符号位\text{P}_{s}=\text{X}_{s}\oplus{}\text{Y}_{s}(其实就是负负得正,原码符号位单独处理)\\\\数值位\text{P}_{1}...\text{P}_{2n}\xrightarrow{记作}\text{Z}_{n}\to{}\begin{cases}\text{Z}_{0}=0\\\\\text{Z}_{1}=2^{-1}(\text{Y}_{n}×\text{|X|}+\text{Z}_{0})\\\\\text{Z}_{2}=2^{-1}(\text{Y}_{n-1}×\text{|X|}+\text{Z}_{1})\\\\...\\\\\text{Z}_{i}=2^{-1}(\text{Y}_{n-i+1}×\text{|X|}+\text{Z}_{i-1})\\\\...\\\\\text{Z}_{2}=2^{-1}(\text{Y}_{1}×\text{|X|}+\text{Z}_{n-1})\\\\\end{cases}\end{cases}\end{array}$
> > >
> > > **2️⃣**规则
> > >
> > > 1. `|=.`代表小数$/$​`|=,`代表整数，这二者处理方式一样 
> > > 2. 乘数(数值有$\text{n}$位)$\xrightarrow[相乘]{\text{n}次加法\&\text{n}次移位}$积(数值有$\text{2n}$​​位)
> > > 3. 部分积$\text{Z}_{0}=0$​为认为强制设定，目的在于防止暂时性溢出
> > >
> > > **3️⃣**部分积更新规则​
> > >
> > > | $\text{Y}_n$ | $\text{Z}_i=\text{Z}_{i-1}+\_\_$ | $\text{Z}_{i}\xrightarrow{算数\_\_移一位}\text{Z}_{i+1}$ |
> > > | :----------: | :------------------------------: | :------------------------------------------------------: |
> > > |     $1$      |            $\text{X}$            |                            右                            |
> > > |     $0$      |               $0$                |                            右                            |
> > >
> > > **4️⃣**机器运算步骤示例：$\text{X=0.1101, Y=1.1011}$
> > >
> > > |                      部分积$\text{Z}_i$                      |           乘数$\text{Y}_0\text{Y}_1...\text{Y}_n$            |                      当前所需执行的操作                      |
> > > | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> > > |                 $\text{Z}_{0}\text{=}$0.0000                 |                            .1011                             |  $\text{Y}_n=1\Rightarrow \text{Z}_1=Z_0+\text{X}(0.1101)$   |
> > > | $\text{Z}_{1}\text{=}$<font color='red'>0.110</font>==<font color='red'>1</font>== |               <font color='gree'>.1011</font>                | $\text{Z}_{1}\xrightarrow{算术右移一位}\text{Z}_{2}$；$\text{Y}_0\text{Y}_1...\text{Y}_n$接收这一位并舍掉$\text{Y}_n$ |
> > > |    $\text{Z}_{2}\text{=}$<font color='red'>0.0110</font>     | ==<font color='red'>1</font>==<font color='gree'>.101</font> | $\text{Y}_n=1\Rightarrow\text{Z}_3=\text{Z}_2+\text{X}(0.1101)$ |
> > > | $\text{Z}_{3}\text{=}$<font color='red'>1.001</font>==<font color='red'>1</font>== |   <font color='red'>1</font>.<font color='gree'>101</font>   | $\text{Z}_{3}\xrightarrow{算术右移一位}\text{Z}_{4}$；$\text{Y}_0\text{Y}_1...\text{Y}_n$接收这一位并舍掉$\text{Y}_n$ |
> > > |    $\text{Z}_{4}\text{=}$<font color='red'>0.1001</font>     | ==<font color='red'>1</font>==<font color='red'>1</font><font color='gree'>.10</font> | $\text{Y}_n=0\Rightarrow\text{Z}_5=\text{Z}_4+\text{0}(0.0000)$ |
> > > | $\text{Z}_{4}\text{=}$<font color='red'>0.100</font>==<font color='red'>1</font>== |   <font color='red'>11</font>.<font color='gree'>10</font>   | $\text{Z}_{4}\xrightarrow{算术右移一位}\text{Z}_{5}$；$\text{Y}_0\text{Y}_1...\text{Y}_n$接收这一位并舍掉$\text{Y}_n$ |
> > > |    $\text{Z}_{5}\text{=}$<font color='red'>0.0100</font>     | ==<font color='red'>1</font>==<font color='red'>1</font><font color='red'>1</font>.<font color='gree'>1</font> | $\text{Y}_n=1\Rightarrow\text{Z}_6=\text{Z}_5+\text{X}(0.1101)$ |
> > > | $\text{Z}_{6}\text{=}$<font color='red'>1.000</font>==<font color='red'>1</font>== |   <font color='red'>111</font>.<font color='gree'>1</font>   | $\text{Z}_{6}\xrightarrow{算术右移一位}\text{Z}_{7}$；$\text{Y}_0\text{Y}_1...\text{Y}_n$接收这一位并舍掉$\text{Y}_n$ |
> > > |    $\text{Z}_{7}\text{=}$<font color='red'>0.1000</font>     | ==<font color='red'>1</font>==<font color='red'>111.</font>  | ==<font color='gree'>乘数小数点已经最右不再右移</font>==，<font color='red'>当前红色的就是结果</font> |
> > >
> > > 原色：初始状态
> > >
> > > <font color='red'>红色：每行拼接，就是当前的**中间结果**</font>
> > >
> > > <font color='gree'>绿色：当前**乘数**</font>
> > >
> > > ==<font color='red'>高亮：乘积寄存器低位的**流向**</font>==
> >
> > ### 2.2.2. 补码一位乘(基于比较法)
> >
> > > **1️⃣**比较法
> > >
> > > $1. 比较算法: \begin{cases}\text{[X×Y]}_{补}=\text{[X]}_{补}×\text{Y}(运算前检测操作数是否含0)\\\\\text{[Y]}_{补}\text{=}\text{Y}_{0}|\text{Y}_{1}\text{Y}_{2}...\text{Y}_{3}\iff{}\text{Y=}\displaystyle\sum\limits_{i=0}^{n}(\text{Y}_{i+1}-\text{Y}_{i})×2^{-i}\end{cases}$
> > >
> > > $2. 部分积递归: \text{[X×Y]}_{补}=\text{[Z}_{n+1}\text{]}_{补}\leftarrow{}\begin{cases}\text{[Z}_{0}\text{]}_{补}\text{=0}\\\\\text{[Z}_{1}\text{]}_{补}\text{=}2^{-1}\{\text{[Z}_{0}\text{]}_{补}+(\text{Y}_{n+1}-\text{Y}_{n})×\text{[X}_{}\text{]}_{补}\}\\\\....\\\\\text{[Z}_{i}\text{]}_{补}\text{=}2^{-1}\{\text{[Z}_{i-1}\text{]}_{补}+(\text{Y}_{n-i+2}-\text{Y}_{n-i+1})×\text{[X}_{}\text{]}_{补}\}\\\\....\\\\\text{[Z}_{n+1}\text{]}_{补}\text{=}2^{-1}\{\text{[Z}_{n}\text{]}_{补}+(\text{Y}_{1}-\text{Y}_{0})×\text{[X}_{}\text{]}_{补}\}\end{cases}\\\\$
> > >
> > > **2️⃣**规则
> > >
> > > 1. 小数整数处理方式都一样，除了定点小数点位置不一样
> > > 2. 符号位参与运算
> > > 3. 部分积采用双符号位，乘数采用单符号位
> > > 4. 进行$\text{n}$次比较$\&$运算，右移$\text{n}$​次(最后一次不位移)
> > >
> > > **3️⃣**部分积更新规则​
> > >
> > > | $\text{Y}_n\text{Y}_{n+1}$ | $\text{[Z}_{i}\text{]}_{补}=\text{[Z}_{i-1}\text{]}_{补}+\_\_$ | $\text{[Z}_{i}\text{]}_{补}\xrightarrow{算数\_\_移一位}\text{[Z}_{i+1}]_{补}$ |
> > > | :------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> > > |            $00$            |                             $0$                              |                              右                              |
> > > |            $01$            |                       $\text{[X]}_补$                        |                              右                              |
> > > |            $10$            |                       $\text{[-X]}_补$                       |                              右                              |
> > > |            $11$            |                             $0$                              |                              右                              |
> > >
> > > 注意：$\text{[X]}_补\xrightarrow{取反+1\text{LSB}}\text{[-X]}_补$
> > >
> > > **4️⃣**机器运算步骤示例：$\begin{cases}\text{[X]}_{\text{补}} = 11.0101\\\\\text{[-X]}_{\text{补}}=00.1011\end{cases}\,,\text{[Y]}_{\text{补}} = 11.0011\,,求\text{[X×Y]}_补$
> > >
> > > |          部分积$\text{[Z}_{i}\text{]}_{补}\text{}$           |                 $\text{Y}_0...\text{Y}_n$                 |    $\text{Y}_\text{n+1}$    | 当前所需执行的操作                                           |
> > > | :----------------------------------------------------------: | :-------------------------------------------------------: | :-------------------------: | :----------------------------------------------------------- |
> > > |         $\text{[Z}_{0}\text{]}_{补}\text{=}$00.0000          |                          1.0011                           |              0              | $\text{Y}_{n}\text{Y}_{n+1}\text{=}10\Rightarrow{}\text{[Z}_{1}\text{]}_{补}\text{=}\text{[Z}_{0}\text{]}_{补}+\text{[-X]}_补$ |
> > > | $\text{[Z}_{1}\text{]}_{补}\text{=}$<font color='red'>00.1011</font> |             <font color='gree'>1.0011</font>              | <font color='blue'>0</font> | $\text{[Z}_{1}\text{]}_{补}\text{}\xrightarrow{右移}\text{[Z}_{2}\text{]}_{补}\text{}$，移出低位塞进乘数和标志 |
> > > | $\text{[Z}_{2}\text{]}_{补}\text{=}$<font color='red'>00.0101</font> | <font color='red'>1</font><font color='gree'>1.001</font> | <font color='blue'>1</font> | $\text{Y}_{n}\text{Y}_{n+1}\text{=}11\Rightarrow{}\text{[Z}_{2}\text{]}_{补}$不变 |
> > > | $\text{[Z}_{2}\text{]}_{补}\text{=}$<font color='red'>00.0101</font> | <font color='red'>1</font><font color='gree'>1.001</font> | <font color='blue'>1</font> | $\text{[Z}_{2}\text{]}_{补}\text{}\xrightarrow{右移}\text{[Z}_{3}\text{]}_{补}\text{}$，移出低位塞进乘数和标志 |
> > > | $\text{[Z}_{3}\text{]}_{补}\text{=}$<font color='red'>00.0010</font> | <font color='red'>11</font><font color='gree'>1.00</font> | <font color='blue'>1</font> | $\text{Y}_{n}\text{Y}_{n+1}\text{=}01\Rightarrow{}\text{[Z}_{4}\text{]}_{补}\text{=}\text{[Z}_{3}\text{]}_{补}+\text{[X]}_补$ |
> > > | $\text{[Z}_{4}\text{]}_{补}\text{=}$<font color='red'>11.0111</font> | <font color='red'>11</font><font color='gree'>1.00</font> | <font color='blue'>1</font> | $\text{[Z}_{4}\text{]}_{补}\text{}\xrightarrow{右移}\text{[Z}_{5}\text{]}_{补}\text{}$，移出低位塞进乘数和标志 |
> > > | $\text{[Z}_{5}\text{]}_{补}\text{=}$<font color='red'>11.1011</font> | <font color='red'>111</font><font color='gree'>1.0</font> | <font color='blue'>0</font> | $\text{Y}_{n}\text{Y}_{n+1}\text{=}11\Rightarrow{}\text{[Z}_{5}\text{]}_{补}$不变 |
> > > | $\text{[Z}_{5}\text{]}_{补}\text{=}$<font color='red'>11.1011</font> | <font color='red'>111</font><font color='gree'>1.0</font> | <font color='blue'>0</font> | $\text{[Z}_{5}\text{]}_{补}\text{}\xrightarrow{右移}\text{[Z}_{6}\text{]}_{补}\text{}$，移出低位塞进乘数和标志 |
> > > | $\text{[Z}_{6}\text{]}_{补}\text{=}$<font color='red'>11.1101</font> | <font color='red'>1111</font><font color='gree'>1.</font> | <font color='blue'>0</font> | $\text{Y}_{n}\text{Y}_{n+1}\text{=}10\Rightarrow{}\text{[Z}_{7}\text{]}_{补}\text{=}\text{[Z}_{6}\text{]}_{补}+\text{[-X]}_补$ |
> > > | $\text{[Z}_{7}\text{]}_{补}\text{=}$<font color='red'>00.1000</font> | <font color='red'>1111</font><font color='gree'>1.</font> | <font color='blue'>0</font> | ==乘数小数点已经最右不再右移==，$\text{Y}_{n}\text{Y}_{n+1}$清零 |
> > > | $\text{[Z}_{7}\text{]}_{补}\text{=}$<font color='red'>00.1000</font> | <font color='red'>1111</font><font color='gree'>0.</font> | <font color='blue'>0</font> | $\text{[X×Y]}_补\text{=}$<font color='red'>00.10001111</font><font color='gree'>0</font><font color='blue'>0</font> |
> > >
> > > <font color='blue'>紫色：**附加位**</font>
> >
> > ### 2.2.3. 补码两位乘：一位乘两步合并一步
> >
> > > **1️⃣**与一位乘的对比
> > >
> > > |                          | 部分积符号位数 | 乘数符号位数 |        右移次数         |      右移位数      |
> > > | :----------------------: | :------------: | :----------: | :---------------------: | :----------------: |
> > > |          一位乘          |      $2$       |     $1$      |      $\text{n}+1$       |        $1$         |
> > > | 两位乘，$\text{n}$为偶数 |      $3$       |     $2$      | $\cfrac{\text{n}+2}{2}$ |        $2$         |
> > > | 两位乘，$\text{n}$为奇数 |      $3$       |     $1$      | $\cfrac{\text{n}+1}{2}$ | $2$(最后一次$1$位) |
> > >
> > > :plate_with_cutlery:$\text{n}$​为数值部分的位数
> > >
> > > **2️⃣**部分积更新规则
> > >
> > > | $\text{Y}_{n-1}\text{Y}_n\text{Y}_{n+1}$ | $\text{[Z}_{i}\text{]}_{补}=\text{[Z}_{i-2}\text{]}_{补}+\_\_$ | $\text{[Z}_{i}\text{]}_{补}\xrightarrow{算数\_\_移2位}\text{[Z}_{i+2}]_{补}$ |
> > > | :--------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> > > |                  $000$                   |                             $0$                              |                              右                              |
> > > |                  $001$                   |                       $\text{[X]}_补$                        |                              右                              |
> > > |                  $010$                   |                       $\text{[X]}_补$                        |                              右                              |
> > > |                  $011$                   |                       $2\text{[X]}_补$                       |                              右                              |
> > > |                  $100$                   |                      $2\text{[-X]}_补$                       |                              右                              |
> > > |                  $101$                   |                       $\text{[-X]}_补$                       |                              右                              |
> > > |                  $110$                   |                       $\text{[-X]}_补$                       |                              右                              |
> > > |                  $111$                   |                             $0$                              |                              右                              |
> > >
> > > 注意：$\begin{cases}\text{[X]}_补\xrightarrow{取反+1\text{LSB}}\text{[-X]}_补\\\\\text{[X]}_{\text{补}}\xrightarrow[符号位不变]{数值部分左移1位}\text{2[X]}_{\text{补}}\\\\\text{2[X]}_{\text{补}}=\text{[2X]}_{\text{补}}\end{cases}$
> > >
> > > **3️⃣**机器运算步骤示例：$\begin{cases}\text{[X]}_{\text{补}} = 111.0101\\\\\text{2[X]}_{\text{补}} =111.1010 \\\\\text{[-X]}_{\text{补}}=000.1011\\\\\text{2[-X]}_{\text{补}}=000.0110\end{cases}\,,\text{[Y]}_{\text{补}} = 11.0011\,,求\text{[X×Y]}_补$​
> > >
> > > |             $\text{[Z}_{i}\text{]}_{补}\text{}$              |                 $\text{Y}_0...\text{Y}_n$                  |      $\text{Y}_{n+1}$       | 操作                                                         |
> > > | :----------------------------------------------------------: | :--------------------------------------------------------: | :-------------------------: | :----------------------------------------------------------- |
> > > |         $\text{[Z}_{0}\text{]}_{补}\text{=}$000.0000         |                          11.0011                           |              0              | $\text{Y}_{n-1}\text{Y}_n\text{Y}_{n+1}\text{=}110\text{→}\text{[Z}_{2}\text{]}_{补}\text{=}\text{[Z}_{0}\text{]}_{补}+\text{[-X]}_补$ |
> > > | $\text{[Z}_{2}\text{]}_{补}\text{=}$<font color='red'>000.1011</font> |             <font color='gree'>11.0011</font>              | <font color='blue'>0</font> | $\text{[Z}_{2}\text{]}_{补}\text{}\xrightarrow{右移2位}\text{[Z}_{4}\text{]}_{补}\text{}$，移出低位塞进乘数和标志 |
> > > | $\text{[Z}_{4}\text{]}_{补}\text{=}$<font color='red'>000.0010</font> | <font color='red'>11</font><font color='gree'>11.00</font> | <font color='blue'>1</font> | $\text{Y}_{n-1}\text{Y}_n\text{Y}_{n+1}\text{=}001\text{→}\text{[Z}_{6}\text{]}_{补}\text{=}\text{[Z}_{4}\text{]}_{补}+\text{[X]}_补$ |
> > > | $\text{[Z}_{6}\text{]}_{补}\text{=}$<font color='red'>111.0111</font> | <font color='red'>11</font><font color='gree'>11.00</font> | <font color='blue'>1</font> | $\text{[Z}_{6}\text{]}_{补}\text{}\xrightarrow{右移2位}\text{[Z}_{8}\text{]}_{补}\text{}$，移出低位塞进乘数和标志 |
> > > | $\text{[Z}_{8}\text{]}_{补}\text{=}$<font color='red'>111.1101</font> | <font color='red'>1111</font><font color='gree'>11.</font> | <font color='blue'>0</font> | $\text{Y}_{n-1}\text{Y}_n\text{Y}_{n+1}\text{=}110\text{→}\text{[Z}_{Ⅹ}\text{]}_{补}\text{=}\text{[Z}_{8}\text{]}_{补}+\text{[-X]}_补$ |
> > > | $\text{[Z}_{Ⅹ}\text{]}_{补}\text{=}$<font color='red'>000.1000</font> | <font color='red'>1111</font><font color='gree'>11.</font> | <font color='blue'>0</font> | ==乘数小数点已最右不再右移==，$\text{Y}_{n-1}\text{Y}_n\text{Y}_{n+1}$清零 |
> > > | $\text{[Z}_{Ⅹ}\text{]}_{补}\text{=}$<font color='red'>000.1000</font> | <font color='red'>1111</font><font color='gree'>00.</font> | <font color='blue'>0</font> | $\text{[X×Y]}_补\text{=}$<font color='red'>000.10001111</font><font color='gree'>00<font color='blue'>0</font></font> |
>
> ## 2.3. 定点除法
>
> > ### 2.3.1. 原码一位除
> >
> > > #### 2.3.1.1. 基本公式
> > >
> > > > **1️⃣**前提：$\begin{cases}
> > > > \text{[X]}_{原}=\text{X}_s|\text{X}_1\text{X}_2\text{...X}_n\\\\
> > > > \text{[Y]}_{原}=\text{Y}_s|\text{Y}_1\text{Y}_2\text{...Y}_n
> > > > \end{cases}$   
> > > >
> > > > **2️⃣**防止溢出：确保$\text{[X/Y]}_{原}$中$\text{0}\leq{}\text{|X|}\leq{}\text{|Y|}$​
> > > >
> > > > **3️⃣**处理：$\begin{array}{c}\text{[Q]}_{原}=\text{[X/Y]}_{原}\to{}\begin{cases}符号位\text{Q}_{s}=\text{X}_{s}\oplus{}\text{Y}_{s}(负负得正,原码符号位单独处理)\\\\数值位\text{Q}_{1}...\text{Q}_{n}=\text{|X|}/\text{|Y|}\end{cases}\end{array}$
> > >
> > > #### 2.3.1.2. 数值位处理：恢复法
> > >
> > > > **1️⃣**初始化：令$\text{|X|}=\text{X*}\,,\text{|Y|}=\text{Y*}$
> > > >
> > > > |                       | 部分余数$\text{X}$符号初值 | 部分余数$\text{X}$数值初值 |       商初值        |
> > > > | --------------------- | -------------------------- | :------------------------: | :-----------------: |
> > > > | $\text{X*}$取单倍字长 | 单符号位，初值为$0$        |        $\text{X*}$         |         $0$         |
> > > > | $\text{X*}$取双倍字长 | 单符号位，初值为$0$        |    $\text{X*}$高位部分     | $\text{X*}$低位部分 |
> > > >
> > > > **2️⃣**更新规则：设定步数$\text{cnt=}$操作数数值位数
> > > >
> > > > 1. $\text{X}=\text{X}_0\xrightarrow{+[-\text{Y*}]_{补}}\text{X}=\text{X}_1$
> > > > 2. $\text{X}=\text{X}_1\xrightarrow{以下规则}\text{X}=\text{X}_2$
> > > >
> > > > | $\text{X}_1$ | $\text{OP}_1$: 商 |                   $\text{OP}_2$: 恢复                    |                  $\text{OP}_3$: 移位                   |    $\text{OP}_4$: 更新$\xrightarrow{得到}\text{X=X}_{2}$     |
> > > > | :----------: | :---------------: | :------------------------------------------------------: | :----------------------------------------------------: | :----------------------------------------------------------: |
> > > > |     $>0$     |     低位塞$0$     |       $\text{X}\xrightarrow{不恢复}\text{X}_1^{'}$       | $\text{X}_1^{'}\xrightarrow{左移1位}\text{X}_{1}^{''}$ | $\text{X}_{1}^{''}\xrightarrow{+\text{[-Y*]}_{补}}\text{X}=\text{X}_2$，$\text{cnt--}$ |
> > > > |     $<0$     |     低位塞$0$     | $\text{X}\xrightarrow[]{+\text{Y*}恢复为}\text{X}_1^{'}$ | $\text{X}_1^{'}\xrightarrow{左移1位}\text{X}_{1}^{''}$ | $\text{X}_1^{''}\xrightarrow{+\text{[-Y*]}_{补}}\text{X}=\text{X}_2$，$\text{cnt--}$ |
> > > >
> > > > 3. $\text{X}=\text{X}_n\xrightarrow{以下规则}\text{X}=\text{X}_{n+1}\,,\text{n}=2,3,.....$
> > > >
> > > > | $\text{X}_n$ | $\text{OP}_1$: 商 |                    $\text{OP}_2$: 恢复                     |                  $\text{OP}_3$: 移位                   |   $\text{OP}_4$: 更新$\xrightarrow{得到}\text{X=X}_{n+1}$    |
> > > > | :----------: | :---------------: | :--------------------------------------------------------: | :----------------------------------------------------: | :----------------------------------------------------------: |
> > > > |     $>0$     |     低位塞$1$     |        $\text{X}\xrightarrow{不恢复}\text{X}_n^{'}$        | $\text{X}_n^{'}\xrightarrow{左移1位}\text{X}_{n}^{''}$ | $\text{X}_{n}^{''}\xrightarrow{+\text{[-Y*]}_{补}}\text{X=}\text{X}_{n+1}$, $\text{cnt--}$ |
> > > > |     $<0$     |     低位塞$0$     | $\text{X}\xrightarrow[]{+\text{Y*}恢复为}\text{X}_{n}^{'}$ | $\text{X}_n^{'}\xrightarrow{左移1位}\text{X}_{n}^{''}$ | $\text{X}_{n}^{''}\xrightarrow{+\text{[-Y*]}_{补}}\text{X=}\text{X}_{n+1}$, $\text{cnt--}$ |
> > > >
> > > > 直到$\text{cnt=0}$​时终止运算
> > > >
> > > > **3️⃣**数值位机内运算示例：$\begin{cases}\text{[X]}_{原}=1.1011\\\\\text{[Y]}_{原}=1.1101\end{cases}\to{}\text{[-Y*]}_{补}=1.0011$，然后求$[\text{X/Y}]_{原}$
> > > >
> > > > | $\text{cnt}$ | $\text{X}$                      |       商        | 操作                                                         |
> > > > | :----------: | :------------------------------ | :-------------: | :----------------------------------------------------------- |
> > > > |     初始     | $\text{X}_0\text{=}0.1011$      | $\text{X.XXXX}$ | $\text{X}_1\text{=}\text{X}_0\text{+}[-\text{Y*}]_{补}$      |
> > > > |   ==$4$==    | $\text{X}_1\text{=}1.1110<0$    | $\text{X.XXXX}$ | <font color='red'>恢复</font>：商低位塞$0$，执行$\text{X+0.1101}$ |
> > > > |     $4$      | $\text{X}_1^{'}\text{=}0.1011$  | $\text{X.XXX0}$ | <font color='green'>移位</font>：$\text{X}$左移一位          |
> > > > |     $4$      | $\text{X}_1^{''}\text{=}1.0110$ | $\text{X.XXX0}$ | <font color='purple'>更新</font>：执行$\text{X+1.0011}$进入下一轮 |
> > > > |   ==$3$==    | $\text{X}_2\text{=}0.1001>0$    | $\text{X.XXX0}$ | <font color='red'>恢复</font>：商低位塞$1$，不恢复           |
> > > > |     $3$      | $\text{X}_2^{'}\text{=}0.1001$  | $\text{X.XX01}$ | <font color='green'>移位</font>：$\text{X}$左移一位          |
> > > > |     $3$      | $\text{X}_2^{''}\text{=}1.0010$ | $\text{X.XX01}$ | <font color='purple'>更新</font>：执行$\text{X+1.0011}$进入下一轮 |
> > > > |   ==$2$==    | $\text{X}_3\text{=}0.0101>0$    | $\text{X.XX01}$ | <font color='red'>恢复</font>：商低位塞$1$，不恢复           |
> > > > |     $2$      | $\text{X}_3^{'}\text{=}0.0101$  | $\text{X.X011}$ | <font color='green'>移位</font>：$\text{X}$左移一位          |
> > > > |     $2$      | $\text{X}_3^{''}\text{=}0.1010$ | $\text{X.X011}$ | <font color='purple'>更新</font>：执行$\text{X+1.0011}$进入下一轮 |
> > > > |   ==$1$==    | $\text{X}_4\text{=}1.1101<0$    | $\text{X.X011}$ | <font color='red'>恢复</font>：商低位塞$0$，执行$\text{X+0.1101}$ |
> > > > |     $1$      | $\text{X}_4^{'}\text{=0.1010}$  | $\text{X.0110}$ | <font color='green'>移位</font>：$\text{X}$左移一位          |
> > > > |     $1$      | $\text{X}_4^{''}\text{=1.0100}$ | $\text{X.0110}$ | <font color='purple'>更新</font>：执行$\text{X+1.0011}$进入下一轮 |
> > > > |   ==$0$==    | $\text{X}_5\text{=}0.0111>0$    | $\text{X.0110}$ | <font color='red'>恢复</font>：商低位塞$1$，不恢复           |
> > > > |     $0$      | $\text{X}_5\text{=}0.0111$      | $\text{0.1101}$ | 商所有位都被填满，此时的商就是结果                           |
> > > >
> > > > :astonished:此时余数：$\text{R*}=0.0111×2^{-4}$
> > >
> > > #### 2.3.1.3. 数值位处理：交替法(初始化方法不变)
> > >
> > > > **1️⃣**更新规则：设定步数$\text{cnt=}$操作数数值位数
> > > >
> > > > 1. $\text{X}=\text{X}_0\xrightarrow{+[-\text{Y*}]_{补}}\text{X}=\text{X}_1$
> > > > 2. $\text{X}=\text{X}_n\xrightarrow{以下规则}\text{X}=\text{X}_{n+1}\,,\text{n}=1,2,3,.....$​
> > > >
> > > > | $\text{X}_n$ | $\text{OP}_1$: 商 | $\text{OP}_2$: 移位                                          |   $\text{OP}_3$: 更新$\xrightarrow{得到}\text{X=X}_{n+1}$    |
> > > > | :----------: | :---------------: | :----------------------------------------------------------- | :----------------------------------------------------------: |
> > > > |     $>0$     |     低位塞$1$     | $\text{X}_n^{}\xrightarrow{左移1位}\text{X}_{n}^{’}$         | $\text{X}_{n}^{'}\xrightarrow{+\text{[-Y*]}_{补}}\text{X=}\text{X}_{n+1}$, $\text{cnt--}$ |
> > > > |     $<0$     |     低位塞$0$     | $\text{X}_n^{}\xrightarrow{左移1位}\text{X}_{n}^{’}$(当$\text{cnt=0}$时无需位移) | $\text{X}_{n}^{'}\xrightarrow{+\text{Y*}}\text{X=}\text{X}_{n+1}$, $\text{cnt--}$ |
> > > >
> > > > **2️⃣**数值位机内运算示例：$\begin{cases}\text{[X]}_{原}=1.1011\\\\\text{[Y]}_{原}=1.1101\end{cases}\to{}\begin{cases}\text{[-Y*]}_{补}=1.0011\\\\\text{Y*}=0.1101\end{cases}$，然后求$[\text{X/Y}]_{原}$
> > > >
> > > > | $\text{cnt}$ | 部分余数$\text{X}$             |       商        | 操作                                                         |
> > > > | :----------: | :----------------------------- | :-------------: | :----------------------------------------------------------- |
> > > > |     初始     | $\text{X}_0\text{=}0.1011$     | $\text{X.XXXX}$ | $\text{X}_1\text{=}\text{X}_0\text{+}[-\text{Y*}]_{补}(1.0011)$ |
> > > > |   ==$4$==    | $\text{X}_1\text{=}1.1110<0$   | $\text{X.XXXX}$ | <font color='green'>移位</font>：低位塞$0$，$\text{X}$左移一位 |
> > > > |     $4$      | $\text{X}_1^{'}\text{=}1.1100$ | $\text{X.XXX0}$ | <font color='red'>更新</font>：执行$\text{X}+\text{Y*}(0.1101)$ |
> > > > |   ==$3$==    | $\text{X}_2\text{=}0.1001>0$   | $\text{X.XXX0}$ | <font color='green'>移位</font>：低位塞$1$，$\text{X}$左移一位 |
> > > > |     $3$      | $\text{X}_2^{'}\text{=}1.0010$ | $\text{X.XX01}$ | <font color='red'>更新</font>：执行$\text{X}+[-\text{Y*}]_{补}(1.0011)$ |
> > > > |   ==$2$==    | $\text{X}_3\text{=}0.0101>0$   | $\text{X.XX01}$ | <font color='green'>移位</font>：低位塞$1$，$\text{X}$左移一位 |
> > > > |     $2$      | $\text{X}_3^{'}\text{=}0.1010$ | $\text{X.X011}$ | <font color='red'>更新</font>：执行$\text{X}+[-\text{Y*}]_{补}(1.0011)$ |
> > > > |   ==$1$==    | $\text{X}_4\text{=}1.1101<0$   | $\text{X.X011}$ | <font color='green'>移位</font>：低位塞$0$，$\text{X}$左移一位 |
> > > > |     $1$      | $\text{X}_4^{'}\text{=}1.1010$ | $\text{X.0110}$ | <font color='red'>更新</font>：执行$\text{X}+\text{Y*}(0.1101)$ |
> > > > |   ==$0$==    | $\text{X}_5\text{=}0.0111>0$   | $\text{X.0110}$ | 低位塞$1$，$\text{X}$不再左移                                |
> > > > |     $0$      | $\text{X}_5\text{=}0.0111$     | $\text{0.1101}$ | 商所有位都被填满，此时的商就是结果                           |
> > > >
> > > > :astonished:此时余数：$\text{R*}=0.0111×2^{-4}$
> >
> > ### 2.3.2. 补码一位除
> >
> > > **1️⃣**初始化：已知$\text{[X]}_补\text{[Y]}_补$求$\text{[X/Y]}_补$
> > >
> > > |                           |   部分余数$\text{[X}_0]_补$补符号初值   | 部分余数$\text{[X}_0]_补$数值初值 |       商初值        |
> > > | ------------------------- | :-------------------------------------: | :-------------------------------: | :-----------------: |
> > > | $\text{[X]}_补$取单倍字长 | 双符号位，初值与$\text{[X]}_补$符号一致 |       $\text{[X]}_补$所有位       |         $0$         |
> > > | $\text{[X]}_补$取双倍字长 | 双符号位，初值与$\text{[X]}_补$符号一致 |        $\text{[X]}_补$高位        | $\text{[X]}_补$低位 |
> > >
> > > **2️⃣**更新规则：设定步数$\text{cnt=}$操作数数值位数
> > >
> > > 1.  初始(试减)：$\text{[X}_0]_补\to{\text{[X}_1]_补}$
> > >
> > > |      条件       |    更新$\xrightarrow{得到}$$\text{[X}_1]_补$     |
> > > | :-------------: | :----------------------------------------------: |
> > > | $\text{XY}$同号 | $\text{[X}_1]_补=\text{[X}_0]_补+\text{[-Y}]_补$ |
> > > | $\text{XY}$异号 | $\text{[X}_1]_补=\text{[X}_0]_补+\text{[Y}]_补$  |
> > >
> > > 2. 上商：当$\text{cnt>0}时$，$\text{[X}_n]_补\to{\text{[X}_{n+1}]_补}$​
> > >
> > > |             条件              | $\text{OP}_1$: 商 |                   $\text{OP}_2$: 余数移位                    |        更新$\xrightarrow{得到}$$\text{[X}_{n+1}]_补$         |
> > > | :---------------------------: | :---------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> > > | $\text{[X}_n]_补\text{Y}$同号 |     低位塞$1$     | $\text{[X}_n]_补\text{}\xrightarrow{左移一位}\text{[X}_n^{'}]_补$ | $\text{[X}_n^{'}]_补\xrightarrow{+\text{[-Y}]_补}\text{[X}_{n+1}]_补$, $\text{cnt--}$ |
> > > | $\text{[X}_n]_补\text{Y}$异号 |     低位塞$0$     | $\text{[X}_n]_补\text{}\xrightarrow{左移一位}\text{[X}_n^{'}]_补$ | $\text{[X}_n^{'}]_补\xrightarrow{+\text{[Y}]_补}\text{[X}_{n+1}]_补$, $\text{cnt--}$ |
> > >
> > > 3. 最后一步：当$\text{cnt=0}时$，不再移动余数$+$==将商恒置$1$左移一位==，然后考虑是否恢复余数
> > >
> > > |                     条件$1$                     |              条件$2$              |                           恢复操作                           |
> > > | :---------------------------------------------: | :-------------------------------: | :----------------------------------------------------------: |
> > > | $\text{[X}_n]_补\text{X}$**同号**(无需恢复余数) |               $\#$                |                             $\#$                             |
> > > | $\text{[X}_n]_补\text{X}$**异号**(需要恢复余数) | $\text{[X}_n]_补\text{Y}$**同号** | $\text{[X}_n^{'}]_补\xrightarrow{+\text{[-Y}]_补}\text{[X}_{n+1}]_补$ |
> > > | $\text{[X}_n]_补\text{X}$**异号**(需要恢复余数) | $\text{[X}_n]_补\text{Y}$**异号** | $\text{[X}_n^{'}]_补\xrightarrow{+\text{[Y}]_补}\text{[X}_{n+1}]_补$ |
> > >
> > > **3️⃣**数值位机内运算示例：$\begin{cases}\text{[X]}_补=11.0111\\\\\text{[Y]}_补=00.1010\\\\\text{[-Y]}_补=11.0110\end{cases}\to$求$\text{[X/Y]}_补$​
> > >
> > > | $\text{cnt}$ |    部分余数$\text{[X}_i]_补$    |                           判定条件                           |       商        | 操作                                                         |
> > > | :----------: | :-----------------------------: | :----------------------------------------------------------: | :-------------: | :----------------------------------------------------------- |
> > > |     初始     |   $\text{[X}_0]_补{=}11.0111$   |                       $\text{XY}$异号                        | $\text{X.XXXX}$ | $\text{[X}_1]_补=\text{[X}_0]_补+\text{[Y}]_补(00.1010)$     |
> > > |   ==$4$==    |   $\text{[X}_1]_补{=}00.0001$   |                $\text{[X}_1]_补\text{Y}$同号                 | $\text{X.XXXX}$ | <font color='green'>移位</font>：塞$1\text{+}\text{[X}_i]_补$$\text{X}$左移一位 |
> > > |     $4$      | $\text{[X}_1^{'}]_补{=}00.0010$ |                             $\#$                             | $\text{X.XXX1}$ | <font color='red'>更新</font>：$\text{X}+[\text{-Y}]_{补}(11.0110)$ |
> > > |   ==$3$==    |   $\text{[X}_2]_补{=}11.1000$   |                $\text{[X}_2]_补\text{Y}$异号                 | $\text{X.XXX1}$ | <font color='green'>移位</font>：塞$0\text{+}\text{[X}_i]_补$$\text{X}$左移一位 |
> > > |     $3$      | $\text{[X}_2^{'}]_补{=}11.0000$ |                             $\#$                             | $\text{X.XX10}$ | <font color='red'>更新</font>：$\text{X}+[\text{Y}]_{补}(00.1010)$ |
> > > |   ==$2$==    |   $\text{[X}_3]_补{=}11.1010$   |                $\text{[X}_3]_补\text{Y}$异号                 | $\text{X.XX10}$ | <font color='green'>移位</font>：塞$0\text{+}\text{[X}_i]_补$$\text{X}$左移一位 |
> > > |     $2$      | $\text{[X}_3^{'}]_补{=}11.0100$ |                             $\#$                             | $\text{X.X100}$ | <font color='red'>更新</font>：$\text{X}+[\text{Y}]_{补}(00.1010)$ |
> > > |   ==$1$==    |   $\text{[X}_4]_补{=}11.1110$   |                $\text{[X}_4]_补\text{Y}$异号                 | $\text{X.X100}$ | <font color='green'>移位</font>：塞$0\text{+}\text{[X}_i]_补$$\text{X}$左移一位 |
> > > |     $1$      | $\text{[X}_4^{'}]_补{=}11.1100$ |                             $\#$                             | $\text{X.1000}$ | <font color='red'>更新</font>：$\text{X}+[\text{Y}]_{补}(00.1010)$ |
> > > |   ==$0$==    |   $\text{[X}_5]_补{=}00.0110$   |                             $\#$                             | $\text{X.1000}$ | <font color='blue'>最后的位移</font>：商左移一位(末尾置$1$)  |
> > > |     $0$      |   $\text{[X}_5]_补{=}00.0110$   | $\text{[X}_5]_补\text{X}$异号<br/>$\text{[X}_5]_补\text{Y}$同号 | $\text{1.0001}$ | <font color='bluee'>恢复</font>：$\text{X}+[\text{-Y}]_{补}(11.0110)$ |
> > > |     $0$      |   $\text{[X}_6]_补{=}11.1100$   |                             $\#$                             | $\text{1.0001}$ | 此时商就是结果，$\text{[X/Y]}_补\text{=1.0001}$              |
> > >
> > > :astonished:此时余数：$\text{R*}=1.1100×2^{-4}$​

# 2s. (补充)高速定点运算：整列乘除器

> ## 2s.1. 阵列乘法器
>
> > ### 2s.1.1. 思路与结构：以$\text{A}=\text{a}_4\text{a}_3\text{a}_2\text{a}_1\text{a}_0\,,\text{B}=\text{b}_4\text{b}_3\text{b}_2\text{b}_1\text{b}_0$为例
> >
> > > **0️⃣**手算多位乘过程：算出所有的$\text{a}_i\text{b}_j$组合$+$按照图示结构相加
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240216132947914.png" alt="image-20240216132947914" style="zoom: 80%;" /> 
> > >
> > > **1️⃣**$\text{Step 1:}$ 用$5×5$阵列算出所有$\text{P}_{ij}=\text{a}_i\text{b}_j$​​
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240216132545479.png" alt="image-20240216132545479" style="zoom:90%;" /> 
> > >
> > > **2️⃣**$\text{Step 2:}$ 通过全加器$\text{FA}$的连接算出$\text{P}_0\to\text{P}_9$​  
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240216185746787.png" alt="image-20240216185746787" style="zoom: 50%;" /> 
> > >
> > > |            加法器            | 本质特点：产生的进位参与什么过程 | 结构特点：进位线连接方向 |
> > > | :--------------------------: | :------------------------------: | :----------------------: |
> > > | 保留进位加法器$\text{(CSA)}$ |  下一级加法器，高一位相加的加法  |      进位线→左下方       |
> > > | 串行进位加法器$\text{(CPA)}$ |  所处级加法器，高一位相加的加法  |      进位线→水平左       |
> >
> > ### 2s.1.2. 原码阵列乘法器
> >
> > > $\begin{cases}\text{[X}]_原=\text{X}_{s}|\text{X}_{1}\text{X}_{2}...\text{X}_{n}\\\\\text{[Y}]_原=\text{Y}_{s}|\text{Y}_{1}\text{Y}_{2}...\text{Y}_{n}\end{cases}\to{}\text{[P}]_原=\text{[X×Y}]_原=(\text{X}_{s}\oplus{}\text{Y}_{s})|(\text{X*}×\text{Y*})$
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240216194558606.png" alt="image-20240216194558606" style="zoom: 67%;" /> 
> >
> > ### 2s.1.3. 补码整列乘法器
> >
> > > $\begin{cases}\text{[X}]_补=\text{X}_{s}|\text{X}_{1}\text{X}_{2}...\text{X}_{n}\\\\\text{[Y}]_补=\text{Y}_{s}|\text{Y}_{1}\text{Y}_{2}...\text{Y}_{n}\end{cases}\to{}\text{[P}]_补=\text{[X×Y}]_补=(\text{X}_{s}\oplus{}\text{Y}_{s})|\text{P}_1\text{P}_2...\text{P}_{2n}$​
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240226215457798.png" alt="image-20240226215457798" style="zoom: 50%;" />  、
>
> ## 2s.2. 阵列除法器
>
> > ### 2s.2.1. 可控加减法单元$\text{CAS}$
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240226220640106.png" alt="image-20240226220640106" style="zoom:50%;" /> 
> > >
> > > | $\text{P=?}$ |           执行操作           |     备注     |
> > > | :----------: | :--------------------------: | :----------: |
> > > |  $\text{0}$  | 输入操作数不求补，控制做加法 | 相当于全加器 |
> > > |  $\text{1}$  |  输入操作数求补，控制做减法  |     $\#$     |
> >
> > ### 2s.2.2. 结构
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240226221337837.png" alt="image-20240226221337837" style="zoom: 44%;" />  
> > >
> > > |                            操作数                            |  含义  |   备注   |                        在结构上的体现                        |
> > > | :----------------------------------------------------------: | :----: | :------: | :----------------------------------------------------------: |
> > > | $\text{X*=0.X}_1\text{X}_2\text{X}_3\text{X}_4\text{X}_5\text{X}_6$ | 被除数 | 双倍字长 |                             $\#$                             |
> > > |            $\text{Y*=0.Y}_1\text{Y}_2\text{Y}_3$             |  除数  | 单倍字长 | $\text{3}$位除数$\to$一行$\text{3+1}$个$\text{CAS}$($\text{4}$位) |
> > > |             $\text{Q=0.Q}_1\text{Q}_2\text{Q}_3$             |   商   | 单倍字长 | $\text{3}$位商$\to$一共$\text{3+1}$行$\text{CAS}$($\text{4}$级) |
> >
> > ### 2s.2.3. 示例：$\text{X*=0.100101, Y*=0.101}$求$\text{X*/Y*}$​
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240226224849481.png" alt="image-20240226224849481" style="zoom:50%;" /> 
> > > 
> > > 
> > > |     级     |        $\text{P}$         |                 执行操作                  |        结果(最高位为$\text{C}_4$)         | $\text{Q}_{}$  |
> > > | :--------: | :-----------------------: | :---------------------------------------: | :---------------------------------------: | :------------: |
> > > | $\text{1}$ | $1$($\text{X*<Y*}$不够减) | $\text{R}_1=\text{X*}+[\text{-Y*}]_{补}$  |  $\text{01.111}$，$\text{C}_4=0$表示够减  | $\text{Q}_0=0$ |
> > > | $\text{2}$ |      $0$(上一级够减)      |     $\text{R}_2=\text{R}_1+\text{Y*}$     | $\text{10.100}$，$\text{C}_4=1$表示不够减 | $\text{Q}_1=1$ |
> > > | $\text{3}$ |      $1$(上一级够减)      | $\text{R}_3=\text{R}_2+[\text{-Y*}]_{补}$ |  $\text{01.111}$，$\text{C}_4=0$表示够减  | $\text{Q}_2=0$ |
> > > | $\text{4}$ |      $0$(上一级够减)      |     $\text{R}_2=\text{R}_1+\text{Y*}$     | $\text{10.100}$，$\text{C}_4=1$表示不够减 | $\text{Q}_3=1$ |
> > >

# 3. 其他定点运算

> ## 3.1. 移位运算
>
> > ### 3.1.1. 规则概述
> >
> > > **1️⃣**三种移位
> > >
> > > | 类型 |     本质特点     |                             规则                             |                   对值的影响                    |
> > > | :--: | :--------------: | :----------------------------------------------------------: | :---------------------------------------------: |
> > > | 逻辑 | 不管符号位，硬移 |  1. 左移：高位丢掉/低位补零<br/>2. 右移：高位补零/低位丢掉   |                      $\#$                       |
> > > | 循环 | 首尾先相联，再移 | 1. 左移：高位塞低位/低位接高位<br/>2. 右移：高位接低位/低位塞高位 |                      $\#$                       |
> > > | 算术 | 考虑符号位，再移 | 0. 正数$\&$负原码：同逻辑位移<br/>1. 负补码：右移补$1$/左移补$0$<br/>1. 负反码：右移补$1$/左移补$1$ | 1. 左移：必定溢出出错<br/>2. 右移：必定影响精度 |
> > >
> > > **2️⃣**位移操作框图
> > >
> > > 1. 算数
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240213182133182.png" alt="image-20240213182133182" style="zoom: 33%;" /> 
> > >
> > > 2. 循环(不进位)
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240213182214788.png" alt="image-20240213182214788" style="zoom:33%;" /> 
> > >
> > > 3. 循环(进位)
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240213182255460.png" alt="image-20240213182255460" style="zoom:33%;" /> 
> > >
> > > 4. 循环(双字长)
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240213182456018.png" alt="image-20240213182456018" style="zoom:33%;" /> 
> > >
> > > 5. 算术：左边小方框为符号位
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240213182546655.png" alt="image-20240213182546655" style="zoom:33%;" /> 
> >
> > ### 3.1.2. 补码算术右移的符号延伸特性
> >
> > > **1️⃣**含义：补码右移时，相当于将$\text{MSB}$填充为符号位
> > >
> > > **2️⃣**应用1：补码右移公式$\to{}\begin{cases}   [\cfrac{1}{1}X]_{补}=X_0|X_1X_2X_3X_4...X_n\\\\{}[\cfrac{1}{2}X]_{补}=X_0|X_0X_1X_2X_3...X_{n-1}\\\\{}[\cfrac{1}{4}X]_{补}=X_0|X_0X_0X_1X_2...X_{n-2}\\\\{}[\cfrac{1}{8}X]_{补}=X_0|X_0X_0X_0X_1...X_{n-3}\end{cases}$
> > >
> > > **3️⃣**应用2：定点整数的子长转化
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240213184458213.png" alt="image-20240213184458213" style="zoom: 67%;" />  
> >
> > ### 3.1.3. 算术右移的误差舍入处理
> >
> > > **1️⃣**方法概述
> > >
> > > | 方法       | 操作                            | 单次误差                          | 误差累计? |
> > > | ---------- | ------------------------------- | --------------------------------- | :-------: |
> > > | 截断       | 截掉右移部分                    | $(\text{-1LSB},0)$                |    是     |
> > > | 末尾置$1$  | 截掉右移部分，剩下最低位设为$1$ | $(\text{-1LSB},\text{+1LSB})$     |    否     |
> > > | $0$舍$1$入 | 见下表                          | $(\text{-0.5LSB},\text{+0.5LSB})$ |    否     |
> > >
> > > **2️⃣**$0$舍$1$入规则
> > >
> > > | 条件$1$     | 条件$2$               | 条件$3$               | 操作                       |
> > > | ----------- | --------------------- | --------------------- | -------------------------- |
> > > | 原码/补码正 | 移出最高位$\text{=}0$ | $\#$                  | 截断                       |
> > > | 原码/补码正 | 移出最高位$\text{=}1$ | $\#$                  | 截断$\to{}$末尾$\text{+1}$ |
> > > | 补码负      | 移出最高位$\text{=}0$ | $\#$                  | 截断                       |
> > > | 补码负      | 移出最高位$\text{=}1$ | 移出其余各位全为$0$   | 截断                       |
> > > | 补码负      | 移出最高位$\text{=}1$ | 移出其余各位不全为$0$ | 截断$\to{}$末尾$\text{+1}$ |
>
> ## 3.2. 十进制运算
>
> > ### 3.2.1. 基本思路
> >
> > > **1️⃣**前提：十进制的二进制编码，本质就是四位二进制数
> > >
> > > **2️⃣**思路：一位十进制$\xrightarrow{看作}$四位二进制$\xrightarrow{二进制加法器}$初步结果$\xrightarrow{修正逻辑}\text{BCD}$形式和
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240226225950381.png" alt="image-20240226225950381" style="zoom:50%;" /> 
> > >
> > > **3️⃣**$\text{n}$位的思路：每位并行相加(施行修正逻辑)$+$​进位串行传递
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240226232339907.png" alt="image-20240226232339907" style="zoom: 67%;" /> 
> >
> > ### 3.2.2. $\text{BCD}$码校正逻辑
> >
> > > **1️⃣**一位逻辑表
> > >
> > > | 判定$\text{1: F}$的范围 | 判定$\text{2: C}$的取值 |   操作   |
> > > | :---------------------: | :---------------------: | :------: |
> > > |   $\text{0000→1001}$    |           $0$           |  不修正  |
> > > |   $\text{1010→1111}$    |           $0$           | $+6$修正 |
> > > |   $\text{0000→1111}$    |           $1$           | $+6$修正 |
> > >
> > > **2️⃣**一位关系表
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240226231116258.png" alt="image-20240226231116258" style="zoom:60%;" /> 
> > >
> > > **3️⃣**多位示例
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240226232603777.png" alt="image-20240226232603777" style="zoom:50%;" /> 
> >
> > ### 3.2.3. 余$3$​码校正逻辑
> >
> > > **1️⃣**一位逻辑表
> > >
> > > | 判定$\text{: C}$的取值 |        操作         |
> > > | :--------------------: | :-----------------: |
> > > |          $0$           | $-3$修正，即$+1101$ |
> > > |          $1$           | $+3$修正，即$+0011$ |
> > >
> > > **2️⃣**一位关系表
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240226233049280.png" alt="image-20240226233049280" style="zoom:60%;" /> 
> > >
> > > **3️⃣**多位示例
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240226233204562.png" alt="image-20240226233204562" style="zoom:50%;" /> 
>
> ## 3.3. 逻辑运算
>
> > | 逻辑运算 |          操作           |
> > | :------: | :---------------------: |
> > |    非    |     自己，按位求反      |
> > |  加/或   |     二者，按位求或      |
> > |  乘/与   |     二者，按位求与      |
> > |    异    | 二者，按位异或(不同为1) |

# 4. 定点运算的硬件实现

> ## 4.1. 基本加法运算部件
>
> > ### 4.1.1. 一位加法器：全加器
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240210180636936.png" alt="image-20240210180636936" style="zoom: 33%;" />  
> > >
> > > | 输出             | 作用         | 逻辑规则                                                     |
> > > | ---------------- | ------------ | ------------------------------------------------------------ |
> > > | $\text{F}_i$     | 存放相加结果 | $\text{X}_i\text{Y}_i\text{C}_{i}=100/010/001/111$时$\text{F}_i=1$ |
> > > | $\text{C}_{i+1}$ | 存放进位结果 | $\text{X}_i\text{Y}_i\text{C}_{i}=110/101/011/111$时$\text{C}_{1+i}=1$ |
> >
> > ### 4.1.2. $n$位加法器：串行
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231222195431294.png" alt="image-20231222195431294" style="zoom: 80%;" /> 
> > >
> > > **1️⃣**结构：加法器$+2$移位寄存器$+$触发器
> > >
> > > **2️⃣**原理：
> > >
> > > 1. 寄存器$\text{AB}\xrightarrow{移位}$两操作数压入全加器$\xrightarrow{运算}\begin{cases}进位结果\xrightarrow{送入}一位触发器\\\\加法结果\xrightarrow{进入}\text{A}寄存器另一端\end{cases}$
> > >
> > > 2. 完成$n$次全加后，$\text{A}$中得到$n$​位和，触发器保留最高位的进位
>
> ## 4.2. 加法器的进位技术
>
> > ### 4.2.1. 行波进位加法器：并行求加+串行进位
> >
> > > **1️⃣**结构：若干个加法器，通过进位输出端相联
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227004802078.png" alt="image-20240227004802078" style="zoom:60%;" /> 
> > >
> > > **2️⃣**进位逻辑
> > >
> > > $\text{C}_{i+1}=\text{X}_i\text{Y}_i+(\text{X}_i\oplus\text{Y}_i)\text{C}_{i}\xrightarrow{\begin{cases}g_i=\text{X}_i\text{Y}_i\\\\p_i=\text{X}_i\oplus\text{Y}_i\end{cases}}\text{C}_{i+1}=g_i+p_i\text{C}_i\xrightarrow{扩展到四位}\begin{cases}\text{C}_1=g_0+p_0\text{C}_0\\\\\text{C}_2=g_1+p_1\text{C}_1\\\\\text{C}_3=g_2+p_2\text{C}_2\\\\\text{C}_4=g_3+p_3\text{C}_3\end{cases}$
> > >
> > > **3️⃣**基于与非逻辑的进位链
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227005915992.png" alt="image-20240227005915992" style="zoom:50%;" />  
> >
> > ### 4.2.2. 先行进位加法器：打破进位间的依赖
> >
> > > **1️⃣**先行进位原理：
> > >
> > > 1. 以四位加法器为例，所有$\text{C}_0\text{C}_1\text{C}_2\text{C}_3$展开为$\text{C}_0$
> > >
> > > $$
> > > \begin{cases}\text{C}_1=g_0+p_0\text{C}_0\\\\\text{C}_2=g_1+p_1g_0+p_1p_0\text{C}_0\\\\\text{C}_3=g_2+p_2g_1+p_2p_1g_0+p_2p_1p_0\text{C}_0\\\\\text{C}_4=g_3+p_3g_2+p_3p_2g_1+p_3p_2p_1g_0+p_3p_2p_1p_0\text{C}_0\end{cases}
> > > $$
> > >
> > > 2. 所有$\text{XY}$输入并行产生$\to$所有$\text{PG}$并行产生$\to{}$所有$\text{C}_i$​并行产生
> > > 3. 先行进位定义：==直接由原始操作数得到所有进位信号==
> > >
> > > **2️⃣**一级先行进位加法器结构：进位生成/传递部件$+$先行进位线路$\text{CLA}+$求和部件
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227125146461.png" alt="image-20240227125146461" style="zoom: 67%;" /> 
> > >
> > > 1. 四位进位生成/传递部件：所有$\text{XY}$输入并行产生$\to$所有$\text{PG}$并行产生
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227125321598.png" alt="image-20240227125321598" style="zoom: 67%;" /> 
> > >
> > > 2. $\text{CLA}$部件：所有$\text{PG}$并行产生$\to{}$所有$\text{C}_i$​并行产生
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227125651860.png" alt="image-20240227125651860" style="zoom:50%;" /> 
> > >
> > > 3. 求和部件：更具进位和输入，最终求出输出
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227125825943.png" alt="image-20240227125825943" style="zoom: 67%;" /> 
> > >
> > > **3️⃣**成组先行$-$级联进位：将$\text{n}$位加法器分为若干组$\begin{cases}组内(第一级): 先行进位\\\\组间(第二级): 串行进位\end{cases}$​
> > >
> > > $\begin{cases}\text{C}_{n+1}=g_{n}+p_{n}\text{C}_{n}\\\\\text{C}_{n+2}=g_{n+1}+p_{n+1}g_{n}+p_{n+1}p_{n}\text{C}_{n}\\\\\text{C}_{n+3}=g_{n+2}+p_{n+2}g_{n+1}+p_{n+2}p_{n+1}g_{n}+p_{n+2}p_{n+1}p_{n}\text{C}_{n}\\\\\text{C}_{n+4}=g_{n+3}+p_{n+3}g_{n+2}+p_{n+3}p_{n+2}g_{n+1}+p_{n+3}p_{n+2}p_{n+1}g_{n}+p_{n+3}p_2p_{n+1}p_{n}\text{C}_{n}\end{cases}$
> > >
> > > 第$0/1/2/3$组分别对应$\text{n}=0/4/8/12$
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227131257891.png" alt="image-20240227131257891" style="zoom:50%;" /> 
> > >
> > > **4️⃣**二级先行进位：将$\text{n}$位加法器分为若干组$\begin{cases}组内(第一级): 先行进位\\\\组间(第二级): 先行进位\end{cases}$​
> > >
> > > 1. 原理：原有的$\text{C}_{n+4}(n=0/4/8/12)$在组间串行传递，现在让四者也先行进位生成
> > >
> > >    $\text{C}_{n+4}=\text{G}_i+\text{P}_i\text{C}_{n}\to{}\begin{cases}\text{P}_i=p_{n+3}p_{n+2}p_{n+1}p_{n}\\\\\text{G}_i=g_{n+3}+p_{n+3}g_{n+2}+p_{n+3}p_{n+2}g_{n+1}+p_{n+3}p_{n+2}p_{n+1}g_{n}\end{cases}$​​
> > >
> > >    并且$i$与$n$满足以下对应关系
> > >
> > >    | $i$  | $n$  |
> > >    | :--: | :--: |
> > >    | $0$  | $0$  |
> > >    | $1$  | $4$  |
> > >    | $2$  | $8$  |
> > >    | $3$  | $12$ |
> > >
> > > 2. 对$\text{CLA}$的改进：去掉$\text{C}_{n+4}$的生成逻辑，增加$\text{P}_i\text{G}_i$​的生成逻辑$\to{}\text{BCLA}$
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227193008820.png" alt="image-20240227193008820" style="zoom:50%;" /> 
> > >
> > > 3. 工作过程：$p_{0-15}与q_{0-15}并行生成\xrightarrow[n=0/4/8/12]{\text{BCLA}}\begin{cases}\text{C}_{n+1-n+3}并行生成\\\\\text{G}_i\text{P}_i并行生成\xrightarrow{\text{CLA}}\text{C}_{n+4}并行生成\end{cases}$​
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227132240593.png" alt="image-20240227132240593" style="zoom:60%;" /> 
> > >
> > > **5️⃣**二级先行$-$级联进位：构建多个​二级先行进位(大组)，大组间串行进位
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227193336701.png" alt="image-20240227193336701" style="zoom: 67%;" /> 
> > >
> > > **6️⃣**三级先行进位链
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227193458150.png" alt="image-20240227193458150" style="zoom: 67%;" />  
>
> ## 4.3. $\text{ALU}$
>
> > ### 4.3.1. $\text{ALU}$​结构：加法器$+$逻辑函数发生器$+$功能选择控制
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227200047896.png" alt="image-20240227200047896" style="zoom: 40%;" />  
> >
> > ### 4.3.2. 典型$\text{ALU}$：$\text{74181}$芯片
> >
> > > #### 4.3.2.1. 外部结构
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227205806733.png" alt="image-20240227205806733" style="zoom:50%;" />  
> > > > 
> > > >**1️⃣**参数输入输出
> > > > 
> > > >|      参数      |          含义          |
> > > > | :------------: | :--------------------: |
> > > > | $A_3A_2A_1A_0$ | 第一个输入的四位操作数 |
> > > > | $B_3B_2B_1B_0$ | 第二个输入的四位操作数 |
> > > > | $F_3F_2F_1F_0$ |    输出的四位操作数    |
> > > > 
> > > >**2️⃣**功能选择
> > > > 
> > > >1. 工作选择：通过四位$S_3S_2S_1S_0$​十六选一
> > > > 
> > > > 2. 功能选择：同一$S_3S_2S_1S_0$​对应六种可能的功能，通过如下逻辑六选一
> > > >
> > > > $正负逻辑二选一\to\begin{cases}逻辑运算(M=H)\\\\算数运算(M=L)\to{}\begin{cases}无进位(C_n=L)\\\\有进位(C_n=H)\end{cases}\end{cases}$
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227211143236.png" alt="image-20240227211143236" style="zoom: 37%;" /> 
> > > >
> > >
> > > #### 4.3.2.2. 内部结构
> > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227230829825.png" alt="image-20240227230829825" style="zoom:50%;" /> 
> > > > 
> > > >|           模块            |                             功能                             |
> > > > | :-----------------------: | :----------------------------------------------------------: |
> > > >| 功能发生器/逻辑函数发生器 |  对$A_3A_2A_1A_0$，$B_3B_2B_1B_0$逻辑组合，产生$XY$两路逻辑  |
> > > > |         求和电路          |         $M=H$时对$XY$逻辑运算，$M=L$时对$XY$算术运算         |
> > > > |       先行进位电路        | 有$\text{CLA}$功能(输出$\text{C}_{n+4}$)，也有$\text{BCLA}$功能(输出$P_iG_i$) |
> > > > |         比较电路          |        当$F_{0-3}$全$0$时，$A=B$端输出高电平比较信号         |
> >
> > ### 4.3.3. 多位$\text{ALU}$
> >
> > > #### 4.3.3.1. 多位先行$-$级联进位$\text{ALU}$​：进位输出输入端依次连接
> > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227233316545.png" alt="image-20240227233316545" style="zoom:60%;" /> 
> > >
> > > #### 4.3.3.2. $16$位比较输出路线：所有$A=B$​端并联
> > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240227233419781.png" alt="image-20240227233419781" style="zoom:55%;" />   
> > >
> > > #### 4.3.3.3. $74182\text{BCLA}$芯片：$74181$的配套先行进位部件
> > >
> > > > **1️⃣**基本结构
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240228001755319.png" alt="image-20240228001755319" style="zoom:50%;" /> 
> > > >
> > > > **2️⃣**$16$位二级先行进位的$\text{ALU}$
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240228002102544.png" alt="image-20240228002102544" style="zoom: 67%;" /> 
> > > >
> > > > **3️⃣**$32$位二级先行进位的$\text{ALU}$
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240228002145039.png" alt="image-20240228002145039" style="zoom:55%;" /> 
> > > >
> > > > **4️⃣**$64$位三级先行进位的$\text{ALU}$​
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240228002255562.png" alt="image-20240228002255562" style="zoom: 62%;" /> 
>
> ## 4.4. 定点运算器：$\text{ALU+通用/专用寄存器+总线}$
>
> > ==$\text{aka: CPU}$的数据通路==
> >
> > ### 4.4.1. 单总线结构
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240228002817102.png" alt="image-20240228002817102" style="zoom:50%;" /> 
> > >
> > > **1️⃣**双暂存器：保证两个操作数同时压入$\text{ALU}$​
> > >
> > > **2️⃣**单次操作耗费$3$时钟周期：两周期送操作数到暂存器$+$一时钟周期将结果回送寄存器
> >
> > ### 4.4.2. 双总线结构
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240228003416370.png" alt="image-20240228003416370" style="zoom: 62%;" /> 
> > >
> > > **1️⃣**单暂存器：可放输入端也可放输出端
> > >
> > > **2️⃣**单词操作耗时$2$周期：压入操作数一周期$+$​回送操作数一周期
> >
> > ### 4.4.3. 三总线结构：单次运算耗时$1$周期
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240228003739924.png" alt="image-20240228003739924" style="zoom:50%;" /> 

$$
\textcolor{red}{\Huge{-------}\colorbox{yellow}{分割线}\Huge{-------}}
$$

# $\text{PART-Ⅱ}$浮点数





































