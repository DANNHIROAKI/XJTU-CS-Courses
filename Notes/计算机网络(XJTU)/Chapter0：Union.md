# Chapter1：导论

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter1%EF%BC%9A%E5%AF%BC%E8%AE%BA.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter1.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter1%EF%BC%9A%E5%AF%BC%E8%AE%BA.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter1%EF%BC%9A%E5%AF%BC%E8%AE%BA.html)==**


# 1. 基本概念

> **1️⃣**网络：一个在两个或多个实体之间传输有价值物品的系统
>
> **2️⃣**计算机网络：多台独立计算机，通过通信设备和软件互联，以共享交换资源的集合
>
> **3️⃣**==计算机网络vs分布式系统==
>
> 1. 分布式系统：以提高整体性能为目的，各计算机协调自治，呈现给用户的是整体系统
> 2. 计算机网络：以资源共享为目的，各计算机独立，呈现给用户的是分散的系统

# 2. 基于网络的获取信息

> **1️⃣**C-S模式：客户端进程向服务器进程发请求，然后等待服务器响应，如访问网页
>
> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/AtR3aGUCLgF8EOm.png" alt="image-20231231142047737" style="zoom:80%;" />  
>
> **2️⃣**P2P模式：无固定客户端/服务器，建立在另一个网络上的松散网络组
>
> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231142156846.png" alt="image-20231231142156846" style="zoom:50%;" /> 
>
> **3️⃣**端-端通信：即时通讯，推特，社交网络，Wiki(社区成员共同编辑)
>
> **4️⃣**电子商务 
>
> | 标签 | 全称           | 示例                         |
> | ---- | -------------- | ---------------------------- |
> | B2C  | 企业对消费者   | 在线订购书籍                 |
> | B2B  | 企业对企业     | 汽车制造商从供应商处订购轮胎 |
> | G2C  | 政府对消费者   | 电子方式分发纳税表格         |
> | C2C  | 消费者对消费者 | 在线拍卖二手产品             |
> | P2P  | 点对点         | 音乐或文件共享；Skype通话    |
>
> **5️⃣**娱乐
>
> 1. IPTV：基于IP技术的电视节目
> 2. 媒体流：通过网络实时传输的多媒体，如抖音，无需下载
> 3. 多人实时模拟游戏
> 4. 虚拟世界
>
> **6️⃣**万物互联
>
> 1. IoT(物联网)：将所有电子设备连接至互联网
> 2. 电力线网络：通过电线上网
> 3. 将计算融入生活：如智能家居

# 3. 计算机网络类型

> | 类型              | 描述                                         | 注意事项                                       |
> | ----------------- | -------------------------------------------- | ---------------------------------------------- |
> | 宽带接入网络      | 用铜线/同轴电缆/光纤，将家庭接入网络         | ==$网络价值\xleftrightarrow{正比于}用户数^2$== |
> | 移动/无线接入网络 | 基于IEEE802.11，有SMS/GPS/NFC等              | \                                              |
> | 数据中心网络      | 可以在数据中心内外大规模传输数据             | 数据中心=云                                    |
> | 内容分发网络CDN   | 存放内容副本于不同地理位置，加速本地访问速度 | \                                              |
> | 中转网络          | 当服务器和用户无法直达时，由中转网络桥接     | 不多用了，都用CDN/ISP                          |
> | 企业网络          | 通过VPN将分散的网络连接成一个逻辑网络        | \                                              |

# ==4. 网络技术类别==

> ## 4.1. 传输技术分类
>
> > **1️⃣**广播链接：一发多收(如广播电视)，有如下两种拓扑(总线和环)，需要解决共享信道和冲突
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231142223275.png" alt="image-20231231142223275" style="zoom: 67%;" />   
> >
> > **2️⃣**点对点链接：一发一收
>
> ## 4.2. 按照覆盖范围分类  
>
> > ### 4.2.1. PAN/LAN/MAN个域网&==(核心问题)==
> >
> > > **1️⃣**PAN个域网==(如何连接)==：设备仅在一个人的范围内通信，如蓝牙
> > >
> > > **2️⃣**LAN局域网==(怎么共享信道)==：范围扩展到了家庭/一栋楼，可为无线(左)/有线(以太网)
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231142522906.png" alt="image-20231231142522906" style="zoom:50%;" /> 
> > >
> > > **3️⃣**MAN城域网：信号接入总站然后分发，例如广播电视
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231142700908.png" alt="image-20231231142700908" style="zoom: 67%;" />  
> >
> > ### 4.2.2. WAN广域网==(寻找最优路径)==
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231144153271.png" alt="image-20231231144153271" style="zoom: 67%;" />    
> > >
> > > **1️⃣**子网：线路+路由器集合
> > >
> > > **2️⃣**WAN种类：VPN，ISP网络服务提供商==(其子网由不同的公司运营)==
> > >
> > > **3️⃣**示例：三地的网路采用租用线路/互联网/网络服务提供商连接
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231143217031.png" alt="image-20231231143217031" style="zoom: 67%;" />
> > >
> > > 

# 5. 网络实例

> ## 5.1. 互联网：各种类型/不同运营商的网络相连
>
> > **1️⃣**前互联网时代
> >
> > | 术语    | 简介                                                   |
> > | ------- | ------------------------------------------------------ |
> > | ARPANET | 互联网的前身，美国防高级研究计划署研发的早期网络       |
> > | NSFNET  | 美国国家科学基金会支持的网络，推动了互联网的发展和普及 |
> >
> > **2️⃣**互联网结构概览
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231144706306.png" alt="image-20231231144706306" style="zoom: 67%;" /> 
> >
> > | 术语     | 描述                                   |
> > | -------- | -------------------------------------- |
> > | POP      | 物理接入点，让企业和用户在特定地点入网 |
> > | IXP      | 物理设施，让不同网络交换流量           |
> > | CMTS     | 高速互联网接入服务(有线电视)           |
> > | DSLAM    | 收集用户的DSL连接，汇集到高速连接上    |
> > | 路由     | 负责在每个网络中交换数据包。           |
> > | 数据中心 | 聚集了服务器，承担了网络大部分流量     |
> > | 网络边缘 | 客户接入网络的地方                     |
> >
> > **2️⃣**互联网结构层次
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231145724266.png" alt="image-20231231145724266" style="zoom:67%;" />  
> >
> > 推荐一个好玩的网站http://www.opte.org/the-internet/
>
> ## 5.2. 移动网络
>
> > ### 5.2.1. 4G LTE结构
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231145948979.png" alt="image-20231231145948979" style="zoom: 50%;" /> 
> > >
> > > **1️⃣**E-UTRAN：无线接入部分，连接用户设备和网络
> > >
> > > **2️⃣**EPC：核心部分，完成数据路由和移动性管理
> > >
> > > | 术语 | 描述                                     |
> > > | ---- | ---------------------------------------- |
> > > | HSS  | 归属用户服务器，存储用户信息             |
> > > | MME  | 移动管理结点，负责移==动性管理==         |
> > > | S-GW | 服务网络网关，负责数据包的==路由和转发== |
> > > | P-GW | 分组数据网关，连接用户和外部网络         |
> >
> > ### 5.2.2. 3G结构
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231171717902.png" alt="image-20231231171717902" style="zoom:67%;" />  
> > >
> > > | 术语 | 描述                                 |
> > > | ---- | ------------------------------------ |
> > > | UMTS | 通用移动通讯系统，宽带/移动/国际漫游 |
> > > | RNC  | 无线网络控制器                       |
> > > | MSC  | 移动交换中心                         |
> > > | HSS  | 归属用户服务器                       |
> > > | MGW  | 媒体网关                             |
> > > | PSTN | 交换电话网络                         |
> >
> > ### 5.2.3. 移动网络的世代
> >
> > > | 代数   | 描述                                          |
> > > | ------ | --------------------------------------------- |
> > > | 1G     | 模拟信号传输语音                              |
> > > | 2G     | 数字信号传输语音，容量大安全性高，提供SMS     |
> > > | 3G     | 数字语音/宽带数字数据服务，采用蜂窝设计(下图) |
> > > | 4G LTE | 速度更快                                      |
> > > | 5G     | 速度更更更快，但信号衰减也更快                |
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231171732570.png" alt="image-20231231171732570" style="zoom:50%;" />  
> >
> > ### 5.2.4. Wi-Fi(WLAN/IEEE802.11)
> >
> > > **1️⃣** **基础设施无线局域网**：客户通过接入点接入，接入点通过有线方式连接其他网络
> > >
> > > **2️⃣** **Ad hoc网络**：在相同的无线范围内，客户端可以直接通信
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231171747487.png" alt="image-20231231171747487" style="zoom: 67%;" />  

# 6. 网络协议

> ## 6.0. 设计目标
>
> > **1️⃣** 可靠性：检错，纠错，正确路由
> >
> > **2️⃣** 资源分配和调度：拥塞控制，资源共享，可扩展
> >
> > **3️⃣** 可演化性：支持不断变化的网络，使用协议层次结构和地址机制
> >
> > **4️⃣**==安全性：保护机密、通信方认证、防止消息篡改==
>
> ## 6.1. 协议及有关概念
>
> > **1️⃣**协议：同一层内，==通信双方就如何通信的一种约定，包括<font color='red'>**语法/语义/时序**</font>==
> >
> > PS: ==语法：格式/封装/信息控制==
> >
> > **2️⃣**接口：定义两层之间如何交互
> >
> > **3️⃣**服务：==一层为给上一层==的操作，如请求/响应/确认，==用户进程通过原语来访问服务==
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20230917191846762.png" alt="image-20230917191846762" style="zoom: 33%;" /> 
>
> ## 6.2. 协议分层：划分网络功能的主要结构化方法
>
> > **1️⃣** 层堆叠：如下图
> >
> > 1. 每层只通过下面一层通信，第一层则直接访问物理媒介
> >
> > 2. 每个协议实例都与其对等实体进行虚拟通话
> >
> > 3. 网络架构=层+协议  
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231171645887.png" alt="image-20231231171645887" style="zoom: 67%;" />   
> >
> > **2️⃣** 协议堆栈：每一层都使用一个特定的协议，例如传输层的TCP/IP，然后一层层堆起来
> >
> > **3️⃣**==分层特点==
> >
> > 1. 各层独立：只需管好自己这一层(自己曾采用合适技术)，和与其他层的接口就行
> > 2. 灵活性好：任意层变化后，不影响接口的话，相邻层都不影响
> > 3. 易于实现和维护
> > 4. 促进标准化

# 7. 参考模型

> ## 7.1. OSI
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231171636150.png" alt="image-20231231171636150" style="zoom:67%;" />   
> >
> > | OSI模型层级 | 功能描述                                         |
> > | ----------- | ------------------------------------------------ |
> > | 物理层      | 管理与物理媒体的直接交互，在物理媒介上传输比特流 |
> > | 数据链路层  | 在物理线路上实现可靠传输，将原始比特流封装为帧   |
> > | 网络层      | 让数据在链路上传送，包括路径选择和转发           |
> > | 传输层      | 确保链路上数据可靠的传输                         |
> > | 会话层      | 建立/管理/终止数据交换之间的会话                 |
> > | 表示层      | 讲传输/收到的数据正确解释和解码                  |
> > | 应用层      | 讲数据塞给对应APP                                |
>
> ## 7.2. TCP/IP协议
>
> > **1️⃣**与OSI结构的对应
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231171823811.png" alt="image-20231231171823811" style="zoom: 67%;" /> 
> >
> > **2️⃣**每一层所用的协议
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231171854122.png" alt="image-20231231171854122" style="zoom:67%;" /> 
>
> ## 7.3. 本书采用的混合模型
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231231171920873.png" alt="image-20231231171920873" style="zoom:67%;" />  

# 8. 其他概念

> **1️⃣**网络标准化
>
> | Body | Area               | Examples               |
> | ---- | ------------------ | ---------------------- |
> | ITU  | Telecommunications | G.992/ADSL/H.264/MPEG4 |
> | IEEE | Communications     | Ethernet/802.11/ WiFi  |
> | IETF | Internet           | RFC/HTTP/DNS           |
> | W3C  | Web                | HTML5                  |
>
> **2️⃣**==有连接与无连接==
>
> 1. 向连接的服务：传数据前建立连接，传完断开(电话)，==可靠&顺序性好==
> 2. 无连接服务：无需预先建立持续连接(邮件)，==但可靠性&顺序性更差==
>
> **3️⃣**分组交换和电路交换
>
> 1. 分组交换：将数据分割成分组，让分组在网络中独立传输
>
> 2. 电路交换：双方之间建立一条固定物理线路，直到结束后才断开连接 

# CHAPTER 2：物理层

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter2.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter2.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter2.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter2.html)==**

物理层定义了比特在信道上发送时的电气/时序接口

# 1. 通信基础

>## 1.1. 基础概念
>
>> ### 1.1. 信号
>>
>> > ==**1️⃣**信号与数据==
>> >
>> > 1. 信号：数据的电气/电磁表现
>> > 2. 数据：传送信号的实体
>> > 3. 数字调制：信号$\xleftrightarrow{转化}$数据
>> >
>> > **2️⃣**模拟&数字信号：对应左右，分别为连续的/离散的
>> >
>> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20231002144109869.png" alt="image-20231002144109869" style="zoom:50%;" /> 
>> >
>> > **3️⃣**基带&宽带信号
>> >
>> > | 类型     | 数据表示                                  | 传输的信道 | 传输方式 |
>> > | -------- | ----------------------------------------- | ---------- | -------- |
>> > | 基带信号 | 转化成数字信号，用电压高低表示数据中的0/1 | 数字信道   | 基带传输 |
>> > | 宽带信号 | 转化成模拟信号                            | 模拟信道   | 宽带传输 |
>>
>> ### ==1.1.2. 信源/信道/信宿==
>>
>> >| 组件 | 描述                                            |
>> >| ---- | ----------------------------------------------- |
>> >| 信源 | 信息的源泉，产生和发送信息的设备                |
>> >| 信道 | 信号的传输媒质，分为有线(双绞线)/无线(人造卫星) |
>> >| 信宿 | 信息的归宿地，接收和处理信息的设备              |
>
>## 1.2. 其他概念
>
>> ### 1.2.1. 带宽
>>
>> > **1️⃣**模拟信号带宽(Hz)：允许通过信号的，最高频率减最低频率
>> >
>> > **2️⃣**数字信号带宽(bit/s)：通道传数据的能力
>>
>> ### 1.2.2. 噪声
>>
>> > **1️⃣**噪声：干扰有效信号传输的其他信号
>> >
>> > **2️⃣**信噪比：
>> >
>> > 1. 噪声对信号的影响是相对的
>> > 2. 信噪比：信号的平均功率/噪声平均功率$SN=\cfrac{S}{N}$，取对数$SNR=10lg(\cfrac{S}{N})(dB)$
>
>## 1.3. 通讯/传输方式
>
>>**1️⃣**数据传输方式
>>
>>1. 串行传输：一个一个比特按照时间顺序传输，常用于远距传输
>>2. 并行传输：多比特通过多信道同时传输，常用于近距传输
>>
>>**2️⃣**通信方式
>>
>>1. 同步通信：接收/发送端时钟频率相等，使接收端对收到比特流采样，从而判决时间是准确的
>>2. 异步通信：更便宜
>>
>>  - 传输单位：字节，但是字节的前/后可各塞一位
>>  - 特点：发送端发完一字节后，下一字节什么时候发不知道
>>
>>**3️⃣**通信模式
>>
>>1. 单工：只能$A\rightarrow{}B$，如广播电视
>>2. 半双工：可以$A\rightarrow{}B$和$A\leftarrow{}B$，如对讲机
>>3. 全双工：可以$A\xleftrightarrow{同时}B$，如电话
>
>## 1.4. 信息传输速率
>
>> 参考这个[知乎回答](https://s2.loli.net/2023/12/31/6LiCAakwUfF7eZT.png)
>>
>> **1️⃣**速率概念的核心：单位时间内传输的数据量
>>
>> **2️⃣**码元：一个码元就是一个脉冲信号，一个脉冲可携带一个/多个比特的数据
>>
>> **3️⃣**两种速率
>>
>> 1. 比特率：一秒能传输多少个比特
>> 2. 波特率：一秒能传输多少个码元(脉冲)，单个码元含有n比特时，比特率=n*波特率

# 2. Nyquist定理&Shannon定理

> ## 2.1. 采样定理&码间干扰
>
> > **1️⃣**原始信号最大频率为$f_{max}$，则将模拟信号转为数字信号时，须有$f_{采样}>2f_{max}$信息才不会丢失
> >
> > **2️⃣**码间串扰：带宽存在→高频分量过不去→接收端信号由此失去了码元见的清晰界限
> >
> > **3️⃣**Nyquist定理由来：不出现码间串扰时，最大的码元传输速率$C_{max}$
>
> ## 2.2. Nyquist定理
>
> > **1️⃣**定理内容：无噪声情况下，基于码元最大速率的最大速率==$C_{max}=f_{采样}\log_{2}N=2f\log_{2}N(bit/s)$==
> >
> > 1. $f$表示低通信号带宽，$2f$是码元最大传输速率
> > 2. $N$表示码元的离散电平的数目，一码元表示$n$比特时，$N=2^n$
> > 3. $2f\to{}2f\log_{2}N$后，才表示比特的最大传输速率，事实上$N$可以无穷大
> >
> > **2️⃣**低通信道
> >
> > 1. 低通信道：带宽从0开始，超过带宽范围的信号，无法不失真通过
> > 2. 带通信道：带宽从非0开始
> >
> > **3️⃣**举例
> >
> > 1. 低通信道截止频率是2kHz→最高码元传输速率是4kHz
> > 2. 带通信道频率范围是3kHz-4kHz→有效带宽1kHz→最高码元传输速率是1kHz
>
> ## 2.3. Shannon定理
>
> > **1️⃣**有噪声情况下，最大数据传输速率==$C_{Max}=W·\log_{2}(1+\cfrac{S}{N})$==
> >
> > **2️⃣**$W$是信道带宽单位是$\text{Hz}$，$\log_{2}(1+\cfrac{S}{N})$为信道比
>
> ## 2.4. 两个定理的比较
>
> > **1️⃣**Nyquist定理：
> >
> > 1. 说明码元传输速率有限，强行拔高会导致码元见干扰，接收端看不出0/1
> > 2. 没说明信息传送速率的极限，采用一定的编码(一码元含多比特)，可以使信息传送速率无穷大
> > 3. 这是理想情况下的，实际速率要小得多
> >
> > **2️⃣**Shannon定理：
> >
> > 1. 给出的是信息传送速率的极限，当然也给出了提高速率的唯二方法
> > 2. 在给定极限内，一定能找到一种无差错传输方法
> > 3. Nyquist定理中，即使有可以使速率无穷大的编码，也不能超过Shannon定理的极限，因为信噪比

# 3. 编码与调制

>**1️⃣**含义
>
>1. 调制：转化成模拟信号
>2. 编码：转化为数字信号
>
>**2️⃣**数据→信号的四种方式   
>
><img src="https://s2.loli.net/2024/01/01/pHgUfdbCYcDAqRJ.png" alt="image-20231231224828153" style="zoom: 67%;" /> 
>
>==**3️⃣**数字数据→数字信号，常见的编码方式==
>
><img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101005921668.png" alt="image-20240101005921668" style="zoom:67%;" /> 
>
>1. 不归零: 正电平 $\xrightarrow{\text { 代表 }} 1$, 负电平 $\xrightarrow{\text { 代表 }} 0$ (反之也行)
>2. 归零制: 正脉冲 $\xrightarrow{\text { 代表 }} 1$, 负脉冲 $\xrightarrow{\text { 代表 }} 0$​ (反之也行)
>
>3. Manchester: 左半边正电平 $\xrightarrow{\text { 代表 }} 1$ ，左半边负电平 $\xrightarrow{\text { 代表 }} 0$ (反之也行)，但是右半边必须翻转一下
>4. 差分Manchester: 如果当前比特 $=0$ 则跳转一次，比特 $=1$ 则维持以前电平，然后中间还是跳转一次

# 4. 数据传输方式

> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101010830460.png" alt="image-20240101010830460" style="zoom: 50%;" /> 
>
> ## 4.1. 电路交换：数据量大时适用
>
> > **1️⃣**含义：通信前在双方间建立一条被==双方独占==的物理通路
> >
> > **2️⃣**优点：延时小/实时强/传输有序/适用广(数据/模拟信号都适用)/控制简单/避免冲突
> >
> > **3️⃣**缺点：建立连接耗时长/霸着连线效率低/无统一标准/灵活性差(断开就要重新拨号)
>
> ## 4.2. 报文交换
>
> > **1️⃣**报文：报文交换的传输单位，携带有源地址/目标地址信息
> >
> > **2️⃣**报文交换：让报文在交换结点不断存储转发
> >
> > **3️⃣**优点：无连接/动态分配路线/可靠/效率高/多目标(一个报文多个目标地址)
> >
> > **4️⃣**缺点：延时大，结点需要缓存
>
> ## 4.3. 分组交换(当今主流)
>
> > **1️⃣**分组：就是报文分割，每个分组包含原地址&目标地址
> >
> > **2️⃣**分组交换：$报文\xrightarrow{分组}n个分组\xrightarrow{套上首部(源/目的地址)}\xrightarrow{传输}\xrightarrow{摘下首部}n个乱序分组\xrightarrow{排序}接收到报文$
> >
> > **3️⃣**优点
> >
> > 1. 加速传输：一个报文的不同分组可并行发送
> > 2. 存储管理更简单：不用缓存整个报文，只用缓存一部分分组
> > 3. 出错率小：重传的也更小了
> >
> > **4️⃣**缺点：有延时，可能丢失/失序/重复，接收端还需重排

# 5. 两种分组交换：数据报&虚电路

> ## 5.1. 数据报(无连接)
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101020039060.png" alt="image-20240101020039060" style="zoom: 60%;" /> 
> >
> > **1️⃣**过程：分割报文为分组→主机1缓存→主机1按照转发表转发→重复缓存转发→接收端收到信息
> >
> > **2️⃣**统计复用：多用户并行传输，在此处体现为例如A发送时，B也可以发送
> >
> > **3️⃣**特点
> >
> > 1. 尽最大努力交付：不靠性，可能会送丢，送达的是乱序的
> > 2. 降低了延时：分组可并行传输
> > 3. 能有效应对故障：一条路线崩了，交换机换一个交换表就行了
> > 4. 资源利用高：收发方谁都不独占一条路线
>
> ## 5.2. 虚电路(面向连接)
>
> >**1️⃣**含义：发数据前，在收发两端建立一条虚连接，通讯完后释放
> >
> >**2️⃣**过程：A→B
> >
> ><img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20231002211558898.png" alt="image-20231002211558898" style="zoom:50%;" /> 
> >
> >1.  A发出**呼叫请求**特殊分组，分组转发给B
> >2.  B回送**呼叫应答**ACK表示同意建立虚电路，虚电路就建立好了
> >3.  A向B发送分组，B按照顺序接收
> >4.  传送完后，释放连接
> >
> >**3️⃣**特点
> >
> >1.  延时低
> >2.  首部并不包含目的地址，但包含虚电路标识符，相对数据报方式开销小
> >3.  虚拟电路上某个线路/交换机故障会导致传输崩溃

# 6. 传输介质

>## 6.1. 介质分类
>
>>### 6.1.1. 导向型介质：实实在在的线
>>
>>>**1️⃣**双绞线：两根互相绝缘的铜导线绞合起来，==贵，效果还差==
>>>
>>><img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101022433720.png" alt="image-20240101022433720" style="zoom: 67%;" /> 
>>>
>>>**2️⃣**同轴电缆：抗干扰更强
>>>
>>><img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101022514182.png" alt="image-20240101022514182" style="zoom:50%;" />  
>>>
>>>==**3️⃣**光纤：分为单模(上图，只能直线传播)，多模(下图，可反射)，缺点是太娇贵了==
>>>
>>><img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20231002214315770.png" alt="image-20231002214315770" style="zoom:67%;" /> 
>>>
>>><img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20231002214531069.png" alt="image-20231002214531069" style="zoom: 67%;" /> 
>>>
>>>==**4️⃣**电线：这是一个雷人的想法，缺点在于==
>>>
>>><img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101024028279.png" alt="image-20240101024028279" style="zoom: 67%;" /> 
>>>
>>>1. 高速传输还需更高频率
>>>2. 电器开关的噪声大
>>>3. 电线和网线电气特性不一致
>>
>>### 6.1.2. 非导向型介质：在自由空间中自由传播
>>
>>> 短波(通讯)，微波(通讯)，红外线，可见光，激光(通讯)
>
>## 6.2. 物理层接口特性
>
>>**1️⃣**介质是第0层：物理层规定介质如何传输比特流，确定介质接口特性
>>
>><img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20231002215408405.png" alt="image-20231002215408405" style="zoom: 25%;" /> 
>>
>>**2️⃣**接口特性
>>
>>1. **机械特性**：接口形状/尺寸/引线数目/排列
>>
>>2. **电气特性**：电压范围，何种信号表示0/1
>>
>>3. **功能特性**：接口部件的信号线(数据/控制/定时线等)的用途
>>
>>4. **规程特性(过程特性)**：物理线路上对不同功能的各种可能事件的出现顺序(时序关系)

# 7. 物理层设备：中继器+集线器

>### 2.3.1. 中继器
>
>>**1️⃣**信号传输过长→信号衰减→加个中继器→衰减到不完整的信号重新完整
>>
>>**2️⃣**放大器放大模拟信号，中继器放大数字信号
>
>### 2.3.1. 集线器：多端口中继器
>
>>**1️⃣**A发信给B过程：A将信息送到集线器→集线器将信息放大后广播→收到广播后B匹配成功→B接收
>>
>>**2️⃣**通过中继器或集线器连接起来的几个网段，仍然是一个局域网

# CHAPTER 3：数据链路层

# 逻辑链路控制子层

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter3.1.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter3.1.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter3.1.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter3.1.html)==**

# 1. 数据链路概述

> ## 1.1. 基本概念
>
> > **1️⃣**结点：链路层中任一设备(主机/路由器/交换机/Wifi接入点)
> >
> > **2️⃣**链路：相邻结点间的通信信道，无线连接也是链路，不同类型链路运行不同链路协议
> >
> > **3️⃣**帧：第二层的数据包，由数据报封装(加上首部/尾部控制信息)而来，例如以下
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101035001178.png" alt="image-20240101035001178" style="zoom:50%;" /> 
>
> ## 1.2. 链路层的目的/服务/功能
>
> > **1️⃣**目的：有差错的物理线路→无差错的逻辑链路
> >
> > **2️⃣**服务：
> >
> > |            | 无确认服务 | 有确认服务 |
> > | ---------- | ---------- | ---------- |
> > | 无连接服务 | √          | √          |
> > | 有连接服务 | ×          | √          |
> >
> > **3️⃣**功能
> >
> > 1. 数据成帧：数据字段+若干首部
> > 2. 链路接入：通过MAC协议实现
> > 3. 可靠交付：通过确认重传实现
> > 4. 差错控制：由硬件实现，包括检错和纠错
> > 5. 半双工/全双工通信
> > 6. 流量控制

# 2. 组帧/成帧：给数据加上首尾

> ## 2.1. 字符计数法
>
> > **1️⃣**含义：头部包含一个字段指示帧中字符的数量，尾部不动
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101035900090.png" alt="image-20240101035900090" style="zoom: 67%;" /> 
> >
> > **2️⃣**缺点：计数字段在传输中出现差错是很难办
>
> ## 2.2. 首尾界符法
>
> > **1️⃣**ASCII中有33个不可打印的控制字符
> >
> > **2️⃣**字符填充：传送帧为文本是，在一帧的首尾加上控制字符(SOH/EOH)
> >
> > **3️⃣**缺陷：对于非文本帧，中间可能出现控制字符，全乱套了
>
> ## 2.3. 字节填充的首尾界符法
>
> > **1️⃣**基于首尾界符，数据中若出现控制字符，就将其转化为另一个非控制字符
> >
> > **2️⃣**转化方式不唯一，不论哪种方式都在接收端转化回来
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101040516839.png" alt="image-20240101040516839" style="zoom:67%;" /> 
>
> ## 2.4. 比特填充的首尾标志法
>
> > **1️⃣**方式：用01111110(6个1)作为帧起止标志
> >
> > **2️⃣**透明传输的解决
> >
> > 1. 发送时：已经发出5个1了，马上接下来强行插入一个0然后发出
> > 2. 接收时：已经收到5个1了，强制删除后面紧跟的0
>
> ## 2.5. 物理编码违例法
>
> > **1️⃣**方式：用物理介质上编码的违法标志，来区分帧的起止
> >
> > **2️⃣**例如：Manchester编码中
> >
> > 1. 一帧会中期跳变，所以只可能是0-1或1-0
> > 2. 可以拿不存在的1-1和0-0来作为起止标示

# 3. 差错控制

> ## 3.1. 水平奇偶校验(检错不纠错)
>
> > **1️⃣**奇/偶校验：
> >
> > 1. 发送端：信息后加1bit的校验，使得1的个数是奇数/偶数
> > 2. 接收端：检测到1有奇数/偶数个，则认为没出错(否则重传)
> >
> > **2️⃣**特点：二比特同时出错，检测不出
>
> ## 3.2. 循环冗余码CRC(检错不纠错)
>
> > ### 3.2.1. 示例
> >
> > > **1️⃣**前提条件：
> > >
> > > 1. 数据单元为101001，对应$G(x)=x^5+x^3+1$
> > > 2. ==强制规定==生成码为1101，规定生成多项式为$G(x)=x^3+x^2+1$
> > > 3. 令$r=$生成码位数-1，为检测位位数
> > >
> > > **2️⃣**发送端行为
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/61N84AYUU67%7B%247ERI16GW52.png" alt="61N84AYUU67{$7ERI16GW52" style="zoom:33%;" /> 
> > >
> > > 1. 构造被除数：原始数据+0(个数等于生成码位数-1)→<101001><000(检测位)>
> > > 2. 除数：就是生成码，即1101
> > > 3. 执行除法：注意图中的$\oplus$表示异或，==余数就是校验码==，这里是001
> > > 4. 发出数据+校验码，为<101001><001>
> > >
> > > **3️⃣**接收端行为：
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101050614110.png" alt="image-20240101050614110" style="zoom:33%;" /> 
> > >
> > > 1. 收到<101001><001>
> > > 2. 执行除法，被除数是收到数据，除数是生成码
> > > 3. 余数为0，则没出错
> >
> > ### 3.2.2. 检错性能
> >
> > > **1️⃣**有$r$检测位的多项式，能检出所有小于等于$r$位的突发
> > >
> > > **2️⃣**长度大于r+1的错误逃脱的概率是$\cfrac{1}{2^r}$
>
> ## 3.3. 海明码(可纠错)
>
> > ### 3.3.1. 求海明码：D=101101为例
> >
> > > **1️⃣**确定校验码位数$r$：==满足$k\leq{}2^r-r-1$，$k$为数据位数==，此处$k=6$所以至少有$r=4$
> > >
> > > **2️⃣**确定校验码放哪：==第$i$位校验码$P_i$放在总的$2^{i-1}$位==，此处如下(数据按顺序填满剩下的位)
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101093154656.png" alt="image-20240101093154656" style="zoom:77%;" />  
> > >
> > > **3️⃣**求出校验值
> > >
> > > 1. 假设出错位为==$e_1,e_2,...,e_r$==，此处是$e_1,e_2,e_3,e_4$
> > >
> > > 2. 用$r$位二进制数 ，给==$M_1,M_2,...,M_{k+r}$==标号，此处是$M_1,M_2,...,M_{10}$
> > >
> > > 3. 找出$M$与$r$的对应关系
> > >
> > >    |          | 标号 | $e_4$    | $e_3$    | $e_2$    | $e_1$    |
> > >    | -------- | ---- | -------- | -------- | -------- | -------- |
> > >    | $M_1$    | 0001 | 无关     | 无关     | 无关     | ==有关== |
> > >    | $M_2$    | 0010 | 无关     | 无关     | ==有关== | 无关     |
> > >    | $M_3$    | 0011 | 无关     | 无关     | ==有关== | ==有关== |
> > >    | $M_4$    | 0100 | 无关     | ==有关== | 无关     | 无关     |
> > >    | $M_5$    | 0101 | 无关     | ==有关== | 无关     | ==有关== |
> > >    | $M_6$    | 0110 | 无关     | ==有关== | ==有关== | 无关     |
> > >    | $M_7$    | 0111 | 无关     | ==有关== | ==有关== | ==有关== |
> > >    | $M_8$    | 1000 | ==有关== | 无关     | 无关     | 无关     |
> > >    | $M_9$    | 1001 | ==有关== | 无关     | 无关     | ==有关== |
> > >    | $M_{10}$ | 1010 | ==有关== | 无关     | ==有关== | 无关     |
> > >
> > > 4. 整理有关项，然后异或
> > >
> > >    | 出错位 | 有关项           | 异或操作                                                     |
> > >    | ------ | ---------------- | ------------------------------------------------------------ |
> > >    | $e_1$  | $M_{1,3,5,7,9}$  | $e_{1}=M_{1}\oplus{}M_{3}\oplus{}M_{5}\oplus{}M_{7}\oplus{}M_{9}$ |
> > >    | $e_2$  | $M_{2,3,6,7,10}$ | $e_{2}=M_{2}\oplus{}M_{3}\oplus{}M_{6}\oplus{}M_{7}\oplus{}M_{10}$ |
> > >    | $e_3$  | $M_{4,5,6,7}$    | $e_{3}=M_{4}\oplus{}M_{5}\oplus{}M_{6}\oplus{}M_{7}$         |
> > >    | $e_4$  | $M_{8,9,10}$     | $e_{4}=M_{8}\oplus{}M_{9}\oplus{}M_{10}$                     |
> > >
> > > 5. 代入**2️⃣**中数据，求出$e$表达式
> > >
> > >    | 出错位 | 表达式                                                      |
> > >    | ------ | ----------------------------------------------------------- |
> > >    | $e_1$  | $P_{1}\oplus{}D_{1}\oplus{}D_{2}\oplus{}D_{4}\oplus{}D_{5}$ |
> > >    | $e_2$  | $P_{2}\oplus{}D_{1}\oplus{}D_{3}\oplus{}D_{4}\oplus{}D_{6}$ |
> > >    | $e_3$  | $P_{3}\oplus{}D_{2}\oplus{}D_{3}\oplus{}D_{6}$              |
> > >    | $e_4$  | $P_{4}\oplus{}D_{5}\oplus{}D_{6}$                           |
> > >
> > > 6. 如果没有错误信息，则必须由==$e_1,e_2,e_3,e_4=0$==，注意==$A\oplus{}B=0\iff{A=B}$==，所以有
> > >
> > >    | 校验码  | 表达式                                           | 取值 |
> > >    | ------- | ------------------------------------------------ | ---- |
> > >    | $P_{1}$ | $D_{1}\oplus{}D_{2}\oplus{}D_{4}\oplus{}D_{5}$   | 0    |
> > >    | $P_{2}$ | ${}D_{1}\oplus{}D_{3}\oplus{}D_{4}\oplus{}D_{6}$ | 0    |
> > >    | $P_{3}$ | ${}D_{2}\oplus{}D_{3}\oplus{}D_{6}$              | 0    |
> > >    | $P_{4}$ | $D_{5}\oplus{}D_{6}$                             | 1    |
> > >
> > > 7. 填充，最后得到海明码
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101095843763.png" alt="image-20240101095843763" style="zoom: 59%;" /> 
> >
> > ### 3.3.2. 通过海明码校验
> >
> > > **1️⃣**先通过这张表求出$e$
> > >
> > > | 出错位 | 有关项           | 异或操作                                                     |
> > > | ------ | ---------------- | ------------------------------------------------------------ |
> > > | $e_1$  | $M_{1,3,5,7,9}$  | $e_{1}=M_{1}\oplus{}M_{3}\oplus{}M_{5}\oplus{}M_{7}\oplus{}M_{9}$ |
> > > | $e_2$  | $M_{2,3,6,7,10}$ | $e_{2}=M_{2}\oplus{}M_{3}\oplus{}M_{6}\oplus{}M_{7}\oplus{}M_{10}$ |
> > > | $e_3$  | $M_{4,5,6,7}$    | $e_{3}=M_{4}\oplus{}M_{5}\oplus{}M_{6}\oplus{}M_{7}$         |
> > > | $e_4$  | $M_{8,9,10}$     | $e_{4}=M_{8}\oplus{}M_{9}\oplus{}M_{10}$                     |
> > >
> > > **2️⃣**结果按照$e_4,e_3,e_2,e_1$排列，排列结果化为十进制$N$，那么出错的就是第$N$位
> >
> > ### 3.3.3. 海明距离
> >
> > > **1️⃣**含义：把两个码字对齐后，不相同的位的个数
> > >
> > > **2️⃣**海明距离和编码方案
> > >
> > > | 目的            | 编码方案的海明距离 |
> > > | --------------- | ------------------ |
> > > | 检测出$d$位错误 | $d+1$              |
> > > | 纠正$d$位错误   | $2d+1$             |
> > >
> > > **3️⃣**$L-1\geq{D+C}$：$LDC$分别为编码长度/检错位数/纠错位数

# 4. 基本数据链路协议

> ## 4.1. 乌托邦协议
>
> > **1️⃣**单工传输
> >
> > **2️⃣**假设是一个理想环境/没有错误/不丢包等，所以也不会有差错控制/流量控制
>
> ## 4.2. 停-等协议
>
> > **1️⃣**含义：发完一帧后，必须等对方回送ACK(所以是半双工)，才能发送下一帧
> >
> > **2️⃣**问题与Solution
> >
> > 1. 一直收不到ACK：发送端超时重传，==停止-等待+重传机制=PAR协议==
> > 2. 接收端无法确定收到数据是否重复：给每帧加上序列号，序列号有限所以可以是循环的
> >
> > **2️⃣**协议中的差错
> >
> > 1. 数据帧传丢了
> > 2. 数据帧损毁：被接收方直接扔掉，也不发ACK
> > 3. 确认帧传丢了/损坏：发送方确认不了，总是超时重传
>
> ## 4.3. 滑动窗口协议
>
> > ### 4.3.1. 单比特滑动窗口
> >
> > > **1️⃣**一对一：发送窗口大小=1，接收窗口大小=1
> > >
> > > **2️⃣**含义：实质上是有错信道下的双工停-等协议
> > >
> > > **3️⃣**特点：发送放最多缓存一个未确认的帧，接收端收到一个帧后就不再接收帧了
> > >
> > > **4️⃣**发送效率：$t_f/t_T$
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101110643371.png" alt="image-20240101110643371" style="zoom:50%;" /> 
> >
> > ### 4.3.2. 后退N帧(GBN)协议
> >
> > > **1️⃣**多对一：$n$比特给窗口编号，发送窗口尺寸$1<W_T\leq{2^n-1}$，接收窗口还是1
> > >
> > > **2️⃣**原理
> > >
> > > 1. 发送端一股脑发很多帧，若收到ACK，则继续一股脑又发很多帧
> > > 2. 如果某一帧出错了，则接收端丢掉该帧及以后所有帧，发送端重发被丢掉的帧
> >
> > ### 4.3.3. 选择重传
> >
> > > **1️⃣**多对多，二者窗口都可以是$W_T\leq{2^{n-1}}$，但不一定相等
> > >
> > > **2️⃣**原理
> > >
> > > 1. 若一帧出错，其后续帧先缓存在接收窗口，同时要求发送方重传出错帧
> > > 2. 收到重传帧后，和缓存一起按顺序排好

# Chapter 3+：介质访问控制子层

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter3.2.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter3.2.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter3.2.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter3.2.html)==**

# 1. 三种链路

> **1️⃣**点对点：单个发送端+单个接收端+二者间的链路，有PPP/HDLC协议
>
> **2️⃣**广播链路：多个发送端+多个接收端+单一共享的广播信道，一个发送端→所有接收端，如无线局域网
>
> **3️⃣**交换式链路：通过交换设备连接多个网络节点，旨在解决碰撞，如以太网

# 2. 介质访问控制协议

> ## 2.1. 信道划分协议
>
> > **0️⃣**多路复用：多个信号在一条物理信道上传输
> >
> > **1️⃣**时分多路复用FDMA：信道划分为不同频段，每个信道带宽不同(但总和有限)，相邻信道有保护频带
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101113623549.png" alt="image-20240101113623549" style="zoom: 40%;" /> 
> >
> > **2️⃣**时分多路复用TDMA：
> >
> > 1. 类似于操作系统中的分时操作系统，但是注意有间隙
> > 2. 异步改良：如果轮到A用信道，A不用，则直接跳过A(不干等了)
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101114106937.png" alt="image-20240101114106937" style="zoom:50%;" /> 
> >
> > **3️⃣**码分多路复用CDMAL：不考https://blog.csdn.net/YCCNUST/article/details/123589294
>
> ## 2.2. 随机接入协议：用户想发就发
>
> > ### 2.2.1. ALOHA协议
> >
> > > **1️⃣**纯ALOHA协议
> > >
> > > 1. 任一结点想发数据就发
> > >
> > > 2. 数据碰撞了，则直接被销毁(传输失败)
> > >
> > > 3. 传输失败后再发，直至发送成功为止
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101115714450.png" alt="image-20240101115714450" style="zoom: 67%;" /> 
> > >
> > > **2️⃣**时分 ALOHA：
> > >
> > > 1. 把时间切片，每片相等
> > > 2. 规定每个时间片的开始，才能发数据
> >
> > ### 2.2.2. CSMA协议：ALOHA+载波侦听信道是否空闲
> >
> > > **1️⃣**三种策略：见2.2.3.中的小结
> > >
> > > **2️⃣**缺点：还是有可能冲突，比如两个结点同时监听到空闲，然后发信然后冲突
> >
> > ### 2.2.3. CSMA/CD协议：CSMA+碰撞检测
> >
> > > **1️⃣**三个时期
> > >
> > > 1. 传输期：传送上一帧
> > > 2. 竞争期：上一帧传完了，其他帧争相强占信道，发送碰撞后就回到竞争槽去再等待随机时间
> > > 3. 空闲期：信道中无数据传送
> > >
> > > **2️⃣**伪代码
> > >
> > > ```c
> > > A：感知信道
> > >     if(信道空闲)
> > >     {
> > >         传输数据，监听信道;
> > >         if(检测到另一个传输)//发生碰撞，信道电平会升高
> > >         {
> > >             中止传输并发送堵塞信号;  
> > >             更新碰撞次数，碰撞次数+1;
> > >             //选择延时时长的方法
> > >             //第i次碰撞就从{0,1,...,2^i-1}中选一个数K
> > >             //延时K*512时间
> > >             根据指数性规避算法进行延时; 
> > >             goto A;
> > >         }else{
> > >             将帧发送完;
> > >             将碰撞次数设置为0;
> > >         }
> > >     }else{
> > >         等待正在进行的传输结束;
> > >         goto A;
> > >     }
> > > ```
> > >
> > > **3️⃣**小结
> > >
> > > | 协议       | 信道空  | 信道忙                       | 发生冲突                     |
> > > | ---------- | ------- | ---------------------------- | ---------------------------- |
> > > | ALOHA      | 发      | 发                           | 任由碰撞，损坏数据也坚持发出 |
> > > | 1-持续CSMA | 发      | 不发，继续监听               | 任由碰撞，损坏数据也坚持发出 |
> > > | 非持续CSMA | 发      | 不发，等待随机事件后重启监听 | 任由碰撞，损坏数据也坚持发出 |
> > > | p-持续CSMA | p概率发 | 不发，下一时间间隙重启监听   | 任由碰撞，损坏数据也坚持发出 |
> > > | CSMA/CD    | 发      | 不发，继续监听               | 终止发送，等随机事件后重发   |
> >
> > ### 2.2.4. CSMA/CA协议：CSMA+冲突避免机制
> >
> > > **1️⃣**其他都一样，不同点是发完一帧要等待确认
> > >
> > > **2️⃣**发送端收到确认，则无冲突(否则重传)
>
> ## 2.3. 轮询协议
>
> > **1️⃣**集中式轮询(左)：
> >
> > 1. 主结点循环顺序询问每个结点
> >
> > 2. 主节点告诉当前询问结点能传输帧数最大值，然后传输完数据
> >
> > 3. 转去询问下一结点
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101141733768.png" alt="image-20240101141733768" style="zoom: 67%;" />  
> >
> > **2️⃣**令牌传递轮询(右)
> >
> > 1. Token(一个特殊帧)在结点间，按照固定次序传递
> > 2. 一个结点，有令牌传过来&&有帧需要发，就接住令牌并发出帧(否则立马传给下一个)

# 3. 局域网LAN：以太网/无线局域网为主

> 以太网=802.3，无线局域网=802.11
>
> ## 3.1. 以太网的MAC帧
>
> > **1️⃣**MAC地址：物理地址/硬件地址，与网卡一一对应(刻在网卡ROM里)，长48bit(高24bit为厂家代码)
> >
> > **2️⃣**MAC帧格式：aka以太网帧
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101142836250.png" alt="image-20240101142836250" style="zoom:60%;" /> 
> >
> > | 字段        | 长度     | 描述                                          |
> > | ----------- | -------- | --------------------------------------------- |
> > | 前导码      | 8B       | 前同步码7B+帧开始定界符1B，用于收发端时钟同步 |
> > | 源/目的地址 | 6B       | 对应发/收设备的网卡==MAC地址==                |
> > | 类型        | 2B       | 指明数据交给哪个协议处理                      |
> > | 数据        | 46-1500B | 所传输的数据，不超过1500B，小于46B时强制补充  |
> > | 校验码FCS   | 4B       | 用CRC校验除前导码外的其他字段                 |
> >
> > **3️⃣**MAC帧种类
> >
> > | 帧类型 | 目的地址特征               | 描述                             |
> > | ------ | -------------------------- | -------------------------------- |
> > | 单播帧 | 前8位最后一位为0           | 发给特定工作站，由主机自己识别   |
> > | 组播帧 | 前8位最后一位为1，其余随便 | 发给特定一组工作站，由适配器识别 |
> > | 广播帧 | 前8位全为1                 | 发送给所有工作站，靠全1识别      |
>
> ## 3.2. ARP协议：子网内IP$\xleftrightarrow{转化}$MAC(其实这是网络层协议)
>
> > **1️⃣**ARP表：子网内每个主机/路由器中都有，包含IP$\xleftrightarrow[动态]{转化}$MAC和TTL(删除该映射倒计时)
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101144656275.png" alt="image-20240101144656275" style="zoom:50%;" /> 
> >
> > **2️⃣**同局域网发送IP分组
> >
> > 1. 主机先查询ARP表(缓冲)→找到目标主机IP→转化为MAC地址→写入MAC帧→发出
> > 2. 如果暂时找不到IP：广播ARP请求分组→目的主机响应→ARP表中建立表项→继续
> >
> > **3️⃣**跨局域网发送IP分组：先通过ARP分组发给本局域网的路由器，路由器转发给其他网络
> >
> > 所有常见情况：
> >
> > | 发送方 | 目的地         | ARP用途                   | 描述                   |
> > | ------ | -------------- | ------------------------- | ---------------------- |
> > | 主机   | 本网络主机     | 获取目的主机MAC地址       | 在本地网络内通信       |
> > | 主机   | 另一网络主机   | 获取本网络路由器MAC地址   | 由路由器转发至其他网络 |
> > | 路由器 | 本网络的主机   | 获取目的主机MAC地址       | 在本地网络内通信       |
> > | 路由器 | 另一网络的主机 | 获取本网络上路由器MAC地址 | 由路由器转发至其他网络 |
>
> ## 3.3. 以太网：最流行的有线局域网
>
> > **1️⃣**结构：通过集线器(Hub)/交换机连接各主机，连接的介质有光纤/双绞线/电缆
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101150903290.png" alt="image-20240101150903290" style="zoom: 67%;" /> 
> >
> > **2️⃣**集线器和交换机：用交换机连接的是交换式以太网
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240101153344457.png" alt="image-20240101153344457" style="zoom:67%;" /> 
> >
> > **3️⃣**服务模式：CRC+CSMA/CD，==无连接不可靠==，Manchester编码
> >
> > **4️⃣**高速以太网
> >
> > | 以太网类型     | 介质   | 最大电缆长度 | 拓扑结构 | 传输模式  | CSMA/CD 协议应用 |
> > | -------------- | ------ | ------------ | -------- | --------- | ---------------- |
> > | 100Base-T      | 双绞线 | 100米        | 星形     | 半/全双工 | 半双工时需要     |
> > | 千兆以太网     | 不指定 | 不指定       | 不指定   | 半/全双工 | 半双工时需要     |
> > | 10吉比特以太网 | 光纤   | 不适用       | 不适用   | 全双工    | 不使用           |
>
> ## 3.4. 无线局域网IEEE 802.11：基于CSMA/CA+确认机制
>
> > ### 3.4.1. 有固定基础设施
> >
> > > **1️⃣**最小构件：
> > >
> > > 1. 基本服务集(BSS)：就是一个基站(aka接入点AP)+若干移动站
> > > 2. 本BSS内可直接通讯，之外要通过基站
> > >
> > > **2️⃣**扩展服务集(ESS)：多个BSS通过主干分配系统(DS)相连，构成的集合
> > >
> > > **3️⃣**门桥设备：使无线网用户接入非802.11无线局域网
> >
> > ### 3.4.2. 无固定基础设施
> >
> > > 由一些平等的，可路由的移动站之间相互通信组成的临时网络
> >
> > ### 3.4.3. IEEE 802.11的层
> >
> > > **1️⃣**物理层：跳频扩频(FHSS)，直接序列扩频(DSS)，红外线(IR)
> > >
> > > **2️⃣**MAC层：在物理层之上，包含分布协调功能子层(DCF)，点协调功能子层(PCF)
>
> ## 3.5. 其他
>
> > **1️⃣**虚拟局域网VLAN：一组逻辑上的设备和用户，不受地理限制，相互之间的通信好像在同一网段一样
> >
> > **2️⃣**广域网：交换机连接多个局域网

# 4. 网桥

> ## 4.1. 网桥的概述
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20231005191943383.png" alt="image-20231005191943383" style="zoom: 67%;" />  
> >
> > **1️⃣**结构功能：工作在数据链路层，能过滤帧，至少两个端口(每端口接一个网段)
> >
> > **2️⃣**工作流程：端口收到帧后缓存，帧转发给同一网段就丢弃，给不同网段就查表转发
> >
> > **3️⃣**特点：过滤通信量/扩大物理范围/互联各种以太网，增加延时/无流量控制
>
> ## 4.2. 透明网桥
>
> > **1️⃣**特点：发出的帧结果哪个网桥是随机的
> >
> > **2️⃣**自学习
> >
> > 1. 网桥收到一帧后，帧源地址$\xleftrightarrow{匹配}$转发表中与收到帧的源地址
> > 2. 匹配失败：在转发表中增加一个项目(源地址+进入的接口+时间)
> > 3. 匹配成功：更新原有信息
> >
> > **3️⃣**帧转发
> >
> > 1. 帧目的地址$\xleftrightarrow{匹配}$转发表中与收到帧的目的地址
> > 2. 匹配成功就按表项转发，失败就转给所有接口
> >
> > **4️⃣**爱的网桥转圈圈：解决办法时生成树
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20231005195715685.png" alt="image-20231005195715685" style="zoom: 67%;" /> 
>
> ## 4.3. 源选径网桥
>
> > **1️⃣**源站$\xrightarrow[帧沿所有可能路线传递]{广播一个帧}\xrightarrow{记录所经路由}$目的站
> >
> > **2️⃣**源站根据记录得到的最佳路由选择一个路由，燃油有请网桥
>
> ## 4.4. 局域网交换机及其工作原理
>
> > **1️⃣**局域网交换机：aka==多端口网桥==，处在链路层，每个端口连接主机/集线器，全双工工作
> >
> > **2️⃣**交换机总容量：端口数×每个端口带宽(半双工)，端口数×每个端口带宽×2(全双工)
> >
> > **3️⃣**交换机的工作模式
> >
> > 1. 直通式：只检查帧的目的地址，收到后立马转出
> >
> > 2. 存储转发：缓存收到帧，检查无误后(有误直接丢掉)，根据查表从端口送出
> >
> >
> > **4️⃣**局域网交换机的工作原理
> >
> > 1. 检测从某端口进入交换机的帧的源 MAC 地址和目的 MAC 地址
> > 2. 若数据报的 MAC 地址不在查找表中，则将该地址加入查找表中，并将数据报发送给相应目的端口

# 网络层

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter4.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter4.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter4.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter4.html)==**

每个主机/路由器都有网络层部分，网络层==实现主机$\xleftrightarrow{}$主机的通讯==，最复杂

注意：笔记中所说数据报=独立的/无连接的网络通信单元

# 1. 网络层概述

> ## 1.0. 网络层主要协议
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231214151600175.png" alt="image-20231214151600175" style="zoom:50%;" /> 
> >
> > **1️⃣**控制报文协议(ICMP)：差错报告，检查连通性
> >
> > **2️⃣**IP(Internet  Protocol)
> >
> > **3️⃣**路由算法
> >
> > ⚠️网络层可分为两个子层：IP位于底下子层，ICMP位于上面子层
>
> ## 1.1. 网络连接
>
> > **1️⃣**背景：网络千千万，要将其互联，需要让路由器连接的网络共同遵守一种协议，互联成虚拟互联网
> >
> > **2️⃣**虚拟互联网：即逻辑互联网，消除物理网络的客观异构性，在协议层面逻辑统一
> >
> > **3️⃣**将网络互联所需的几种中继
> >
> > | 层级         | 物理层        | 数据链路层  | 网络层 | 传输层 |
> > | ------------ | ------------- | ----------- | ------ | ------ |
> > | 对应中继系统 | 集线器/中继器 | 网桥/交换机 | 路由器 | 网关   |
> >
> > <mark>互联网：用路由器进行互连的网络</mark>
> >
> > ⚠️传输中检测出差错的IP数据报都被丢弃了
>
> ## 1.2. 网络层功能
>
> > ### 1.2.1. 路由选择(核心)
> >
> > > **1️⃣**含义：确定分组从源→目的地端到端路径
> > >
> > > **2️⃣**特点：时间尺度长(几秒)，软件实现
> > >
> > > **3️⃣**实现：基于路由选择算法构造路由表，最优化网络拓扑计算
> > >
> > > **4️⃣**何时进行路由选择
> > >
> > > 1. 子网内部使用数据报：来一个分组就重选一次路径
> > > 2. 子网内部使用虚电路：新建虚电路时才重选路径
> >
> > ### 1.2.2. 分组转发(核心)
> >
> > > **1️⃣**含义：将分组从一个输入链路接口转移到适当的输出链路接口
> > >
> > > **2️⃣**特点：时间尺度短(几纳秒)，硬件实现，==是路由器的核心功能==
> > >
> > > **3️⃣**实现：基于路由表构造转发表，最优化查找过程，==往往不区分转发表/路由表==
> > >
> > > **4️⃣**类比：路由选择好比选择了$A\to{B}$的一条公路(路由选择)，每条公路上都有很多立交桥(分组转发)
> >
> > ### 1.2.3. 连接建立(非核心)
> >
> > > **1️⃣**路由器参与：数据报流动前，两端主机和中间路由器建立虚拟连接
> > >
> > > **2️⃣**网络&传输层服务：网络层是在两主机之间的，传输层是在两进程间不涉及路由器
>
> ## 1.3. 网络层服务模型
>
> > | 网络架构  | 服务模型        | 带宽     | 保证丢包 | 保证顺序 | 保证时序 | 拥塞反馈 |
> > | --------- | --------------- | -------- | -------- | -------- | -------- | -------- |
> > | 互联网    | Best Effort     | 无       | 否       | 否       | 否       | 否       |
> > | ATM(异步) | CBR恒比特率     | 恒定速率 | 是       | 是       | 是       | 无拥塞   |
> > | ATM       | VBR变比特率     | 保证速率 | 是       | 是       | 是       | 无拥塞   |
> > | ATM       | ABR可用比特率   | 保证最小 | 否       | 是       | 否       | 是       |
> > | ATM       | UBR未指定比特率 | 无       | 否       | 是       | 否       | 否       |
>
> ## 1.4. 虚电路网络(VC)
>
> > ### 1.4.1. 虚电路的工作原理
> >
> > > **1️⃣**数据传输前建立虚电路，通信完就撤销
> > >
> > > **2️⃣**每个包，含有一个虚电路ID
> > >
> > > **3️⃣**源-目的间，所有路由器维持连接状态
> > >
> > > **4️⃣**通信前就知道通信质量
> >
> > ### 1.4.2. 虚电路结构
> >
> > > **1️⃣**发送→接收端的路径
> > >
> > > **2️⃣**虚电路号，每条路径都有一个号
> > >
> > > **3️⃣**沿路中路由的转发表项，转发表由交换设备维护，转发后虚电路号改变
> > >
> > > 虚电路/转发表实例：
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231214142540553.png" alt="image-20231214142540553" style="zoom: 50%;" /> 
> > >
> > > | 输入端口 | 输入VC | 输出端口 | 输出VC |
> > > | -------- | ------ | -------- | ------ |
> > > | 1        | 12     | 3        | 22     |
> > > | 2        | 63     | 1        | 18     |
> > > | 3        | 7      | 2        | 17     |
> > > | ……       | ……     | ……       | ……     |
> >
> > ### 1.4.3. 信令协议
> >
> > > **1️⃣**作用：建立/维护/撤销VC
> > >
> > > **2️⃣**应用于：ATM, frame-relay, X.25, IPv6注意IPv4 中没有应用

# 2. 路由器

> ## 2.1. 路由器结构功能概述
>
> > <img src="https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220331151429700.png" alt="image-20220331151429700" style="zoom: 44%;"/>  
> >
> > **1️⃣**结构：
> >
> > 1. 路由选择部分
> > 2. 分组转发部分：输入端口，交换结构，输出端口
> >
> > **2️⃣**功能：
> >
> > 1. 运行路由算法/协议(RIP/OSPF/BGP)，只有边界网关路由器才运行BGP
> > 2. 将数据包从输入链路转发到输出链路
>
> ## 2.2. 路由器的三种交换
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231214145806703.png" alt="image-20231214145806703" style="zoom:50%;" /> 
> >
> > **1️⃣**通过存储器交换：
> >
> > 1. 原理：输入端口将数据包放进内存，输出端口从内存中取出
> > 2. 特点：CPU控制这一过程，两次访问存储器效率低(被内存带宽限制)，多见于早期路由器
> >
> > **2️⃣**通过总线交换：
> >
> > 1. 原理：任一输入端的数据都放总线上，输出端从总线读数据
> > 2. 特点：路由性能取决于总线带宽，可达32Gps
> >
> > **3️⃣**通过交叉开关网络交换：网络横竖交叉与一个Bar，需要通信时对应线路的Bar会导通
>
> ## 2.3. 输入输出端口
>
> > **1️⃣**输入端口：从左到右为物理层/链路层/网络层，有一个输入队列
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231214145137513.png" alt="image-20231214145137513" style="zoom: 67%;" /> 
> >
> > 1. 输入队列：多个输入端口欲转发至同一输出端口，产生等待队列
> > 2. 行头阻塞：等待队列满后，丢包
> >
> > **2️⃣**输出端口：
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231214150357655.png" alt="image-20231214150357655" style="zoom:50%;" /> 
> >
> > 缓冲队列：缓冲交换结构处理速度>传输速度的那部分，转而从队列中选择数据进行传输

# 3. IPv4

> ## 3.1. IPv4特点
>
> > **1️⃣**无连接性：发送数据报前，两端不必预先建立连接，数据包中含有目标IP可以自己传过去
> >
> > **2️⃣**无状态+路由选择性：路由器不需要记住经手数据包信息，只负责根据目标IP转发出去
> >
> > **3️⃣**乱序性：不同数据包会选择不同路径从发送端→接收端，不一定先发先收到，接收端需要重排
> >
> > :tanabata_tree:乱入：转发表
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231214171713643.png" alt="image-20231214171713643" style="zoom: 50%;" /> 
> >
> > 采用最长前缀原则，例如前缀为<font color='red'>11001000</font><font color='cornflowerblue'>00010111</font><font color='red'>00010</font>时，IP的范围为
> >
> > <font color='red'>11001000</font><font color='cornflowerblue'>00010111</font><font color='red'>00010000</font><font color='cornflowerblue'>00000000</font>
> >
> > <font color='red'>11001000</font><font color='cornflowerblue'>00010111</font><font color='red'>00010111</font><font color='cornflowerblue'>11111111</font>
> >
> > 在这个范围内的IP会被转发给端口0
>
> ## 3.2. 数据包格式：首部+数据
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231214184709434.png" alt="image-20231214184709434" style="zoom:50%;" /> 
> >
> > Data之前都是数据包的首部，每行代表首部的一部分，每部分都是32Bit
> >
> > **1️⃣**第一行
> >
> > 1. **Version (4 bits)**：决定是用IPv4还是IPv6
> > 2. **Header Length (4 bits)**：IP数据包首部长
> > 3. **Type of Service (8 bits)**：指示数据包的服务类型，IPv6才有区别，IPv4未启用
> > 4. **Datagram Length (16 bits)**：IP数据包的首部+数据总长
> >
> > **2️⃣**第二行：与IP切片有关
> >
> > 1. IP切片：IP数据包太大，超过链路的MTU(最大传输单元)，会被分为小片
> > 2. 这些结构有助于切片后的IP数据包，在接收端重新组织
> >    - **16-bit Identifier**：识别来自同一数据包的切片，便于在接收后组装
> >    - **Flags**：控制/状态标志，是否允许切片
> >    - **Fragmentation Offset**：切片在原始数据包中的位置
> >
> > **3️⃣**第三行
> >
> > 1. **Time to Live**：限制数据包在网络中的存在时间，经过一个路由器就会减一
> > 2. **Upper-layer Protocol**：携带数据所用的协议(TCP/UDP)
> > 3. **Header Checksum**：检错，但没用
> >
> > **4️⃣**四五六行：源IP/目标IP/额外信息
>
> ## 3.3. IPv4地址
>
> > ### 3.3.1. 概述
> >
> > > **1️⃣**IP地址$\xleftrightarrow{一一对应}$网络接口：不与主机一一对应，路由器有多少接口就有多少IP
> > >
> > > **2️⃣**IP地址组成：主机部分+网络部分，通过子网掩码分开
> > >
> > > **3️⃣**IP位于同一网段$\iff$IP地址的网络部分相同
> >
> > ### 3.3.2. IP地址的特点
> >
> > > **1️⃣**IP是分等级的地址结构
> > >
> > > 1. IP地址管理机构分配网络号，再由网络地址组织者分配主机号
> > > 2. 路由器转发分组只关注网络号，由此精简了路由表
> > >
> > > **2️⃣**IP的含义
> > >
> > > 1. 标识一个主机/路由器的一个链路接口
> > > 2. 多接口主机：主机连接两个网络(两个接口)，就有两个网络号不同的IP，比如路由器的每个接口
> > >
> > > **3️⃣**用中继器/网桥连接的$n$个局域网，仍为一个网络，有相同的网络号
> > >
> > > **4️⃣**所有网络号对应的网络，地位平等
> >
> > ### 3.3.3. A/B/C/D类IP
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231214200706246.png" alt="image-20231214200706246" style="zoom:40%;" /> 
> > >
> > > | 类型 | 最高位固定值 | 可指派网络数 | 最多主机数 | 备注                              |
> > > | :--: | ------------ | ------------ | ---------- | --------------------------------- |
> > > |  A   | 0            | $2^7-1$      | $2^{24}-2$ | 网络号0为保留地址，127为环回地址* |
> > > |  B   | 10           | $2^{14}-1$   | $2^{16}-2$ | 128.0.0.0实际上不指派             |
> > > |  C   | 110          | $2^{21}-1$   | $2^{8}-2$  | 192.0.0.0实际上不指派             |
> > > |  D   | 1110         | \            | \          | 多播通信时作为目的地址**          |
> > >
> > > 1. 环回地址：用于向自己通讯
> > > 2. 多播通信：一对多(这个多对应IP地址)，类似于微信群聊
> >
> > ### 3.3.4. 特殊IP地址
> >
> > > | 特殊地址       | 结构                    | 源or目的地址 | 应用                         |
> > > | -------------- | ----------------------- | ------------ | ---------------------------- |
> > > | 网络地址       | 网络号特定，主机号全为0 | 都不         | 标识整个网络                 |
> > > | 直接广播地址   | 网络号特定，主机号全为1 | 目的地址     | 发数据包到特定网络所有主机   |
> > > | 受限广播地址   | 255.255.255.255         | 目的地址     | 发数据包到当前网络所有主机   |
> > > | 此网络此主机   | 0.0.0.0                 | 都可         | 主机不知自己IP时，将其作为IP |
> > > | 此网络特定主机 | 网络号全为0，主机号特定 | 目的地址     | 指定同一网络内的特定主机     |
> > > | 环回地址       | 网络号127，主机号全0/1  | 二者都为本机 | 本机内部通信测试             |
>
> ## 3.5. 网络地址变换(NAT)：节省IP消耗
>
> > ### 3.5.1. 专用网
> >
> > > **1️⃣**问题背景：100个机构，每个机构有100台主机，一个机构的主机只需要内部通信(不连接Internet)
> > >
> > > 1. 每个主机分配一个共10000个IP：显然浪费
> > > 2. 每个机构分配一个共100个专用IP：aka专用地址
> > >
> > > **2️⃣**专用地址(可重用地址)
> > >
> > > 1. 特点：不会被路由器转发，其作为目的地址不会被Internet传送
> > > 2. 专用地址范围
> > >    - A类网络的一块：10.0.0.0~10.255.255.255
> > >    - B类网络的连续16个：172.16.0.0~172.31.255.255 
> > >    - C类网络的连续256个：192.168.0.0~192.168.255.255
> > >
> > > **3️⃣**专用网：采用专用IP的互联网
> > >
> > > **4️⃣**NAT的引入：使专用网的主机和因特网的主机通信
> >
> > ### 3.5.2. NAT概述
> >
> > > **1️⃣**功能：将专用网内部本地IP→有效外部全球IP，使专用网络只需一个全球IP就可连接Internet
> > >
> > > **2️⃣**使用NAT：专用网$\xleftrightarrow{NAT路由器}$Internet
> > >
> > > **3️⃣**NAT路由器：装有NAT软件的路由器，特点为
> > >
> > > 1. 至少有一个全球IP
> > > 2. 对外界隐藏了专用网内部的细节
> > > 3. 外界看来NAT路由器就是具有单一IP的单一设备
> >
> > ### 3.5.3. NAT转换表与示例
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231214214825801.png" alt="image-20231214214825801" style="zoom: 67%;" /> 
> > >
> > > **1️⃣**NAT转换表解决的问题：广域网到达NAT路由器的目标IP相同，所以要把分组转发给内部哪个主机呢
> > >
> > > **2️⃣**NAT转换表表项：端口号+IP
> > >
> > > **3️⃣**示例分析：用户处于家庭网络10.0.0.1主机
> > >
> > > 1. 用户请求128.119.40.186(端口80)的某台Web网页服务器，主机随便挑了个源端口(如3345)发出数据报
> > >
> > > 2. NAT路由器接到数据报，将源IP替换为家庭网络WAN一侧的接口IP地址138.76.29.7，选择任一个还未在NAT转换表中的源端口号(比如5001)替换原有端口号，替换后增加如下表项
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231214221020415.png" style="zoom:50%;" />   
> > >
> > > 3. Web服务器响应请求，然后返回报文，其目的地址时NAT路由器的IP，端口5001
> > >
> > > 4. 返回报文到达NAT路由器时，检索到添加过的表项WAN侧，转化回LAN侧IP，转发给家庭用户
> > >
> > > **4️⃣**特点：涉及转换，效率低
> >
> > ### 3.5.4. NAT网关穿越问题
> >
> > > **1️⃣**静态配置NAT表：每有一个新应用就要往NAT添加新表项，由网管配置
> > >
> > > **2️⃣**动态配置NAT表：软件自动添加，借助IGD协议
>
> ## 3.6. 子网掩码
>
> > ### 3.6.1. 子网划分：三级IP地址
> >
> > > **1️⃣**格式：`<网络号><子网号><主机号>`
> > >
> > > **2️⃣**范围：子网划分在单位内部，单位对外仍是没划分的网络
> > >
> > > **3️⃣**思路：网络号不变，主机号中借用若干bit作为子网号
> >
> > ### 3.6.2. 子网掩码
> >
> > > **1️⃣**作用：告诉主机/路由器，是否对网络进行划分
> > >
> > > **2️⃣**结构：
> > >
> > > 1. 将IP中的网络号/子网号对应位全置1，主机号对应位全置0
> > > 2. IP&&子网掩码=子网地址(网络号+子网号)
> > >
> > > **2️⃣**默认子网掩码：对于A/B/C三类网络分别为255.0.0.0 / 255.255.0.0 / 255.255.255.0
> >
> > ### 3.6.3. 无类别域间路由选择(CIDR)
> >
> > > **1️⃣**允许网管动态调整子网号/主机号长度
> > >
> > > **2️⃣**格式：a.b.c.d/x，x代表子网号的位数
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231214224402334.png" alt="image-20231214224402334" style="zoom: 50%;" />  
>
> ## 3.7. 动态主机配置协议(DHCP)
>
> > **1️⃣**概述：其实是一个==应用层协议==，DHCP报文用UDP传输，==目的是给主机动态分配IP==
> >
> > **2️⃣**即插即用联网+自动IP分配机制：DHCP客户端-DHCP服务器的交换过程如下
> >
> > 新设备(DHCP客户端)加入网络，执行以下操作
> >
> > | 步骤 | 参与方 | 操作                   | 说明                                        |
> > | ---- | :----: | ---------------------- | ------------------------------------------- |
> > | 1    | Clinet | 广播 **DHCP discover** | 申请，客户端不知道DHCP服务器在哪①，只能广播 |
> > | 2    | Server | 接收 **DHCP discover** | 收到申请，服务器要选一个IP准备分配②         |
> > | 3    | Server | 广播 **DHCP offer**    | 发Offer，报文包含分配的IP+配置信息③         |
> > | 4    | Clinet | 接收 **DHCP offer**    | 收到Offer，客户端会决定是否接受             |
> > | 5    | Clinet | 广播 **DHCP request**  | 接受Offer，客户端请求分配Offer中的IP地址    |
> > | 6    | Server | 接收 **DHCP request**  | 收到确认                                    |
> > | 7    | Server | 广播 **DHCP ack**      | 你有学上了，确认分配IP地址给客户端          |
> > | 8    | Clinet | 接收 **DHCP ack**      | 我有学上了，客户端得到IP                    |
> >
> > ①网络中可能不止一台DHCP服务器，广播后可能有多个服务器响应，但只有一台(一般是最先的)被选定
> >
> > ②DHCP服务器选择IP的方法：向数据库中搜索该设备信息
> >
> > - 能找到信息，就选定找到的IP
> > - 找不到的话，就从IP池中选定一个IP
> >
> > ③配置信息有：子网掩码，默认网关，本地DN服务器
>
> ## 3.8. 网络控制报文协议(ICMP)
>
> > ### 3.8.1. 路由器/主机的差错控制
> >
> > > **1️⃣**检测到数据首部出错：直接弃疗吧，因为这种情况下哪个IP发来的都不可知了
> > >
> > > **2️⃣**检测到其他错误：
> > >
> > > 1. 收到数据的主机/路由器：通过ICMP报文，把错误报告送回发来错误数据的主机
> > > 2. 发送数据的主机：根据ICMP报文确定错误类型，换种方式(如重新路由)把数据重发一遍
> >
> > ### 3.8.2. ICMP报文分类
> >
> > > #### 3.8.2.1. ICMP差错报告报文
> > >
> > > > **1️⃣**再分类
> > > >
> > > > | 类型       | 路由器/主机出问题的地方   | 路由器/主机采取的操作                        |
> > > > | :--------- | ------------------------- | -------------------------------------------- |
> > > > | 终点不可达 | 无法把数据交到目的地      | 向源点发不可达报文                           |
> > > > | 源站抑制   | 因为拥塞丢包              | 向源点发源点抑制报文，源点放慢发数据报速率   |
> > > > | 时间超过   | 所含IP报文生命周期TTL到头 | 丢弃分组，向源点发超时报文①                  |
> > > > | 参数问题   | 收到数据报首部有问题      | 丢掉数据报，发送参数问题报文==(其实不会发)== |
> > > > | 重定向     | 发现有更好路由            | 向源点发重定向报文，源点下次用更好路由发送   |
> > > >
> > > > ①当终点在预定时间内，收不到数据报所有数据片时，也会向源点发超时报文，然后丢弃已收到的片
> > > >
> > > > **2️⃣**不应发送ICMP差错报告报文的几种情况
> > > >
> > > > 1. 当收到的报文就是ICMP差错报告报文时
> > > > 2. 数据报具有组播地址
> > > > 3. 数据报具有特殊地址(127.0.0.0或0.0.0.0)
> > > > 4. 当报文被切片时，支队第一个分片发送差错报告
> > >
> > > #### 3.8.2.2. ICMP询问报文
> > >
> > > > 有回送请求和回答报文/时间戳请求和回答报文/掩码地址请求和回答报文/路由器询问和通告报文
> >
> > ### 3.8.3. ICMP应用
> >
> > > **1️⃣**ping：在应用层使用了ICMP==回送请求与回送回答报文==，测试两主机的连通性
> > >
> > > **2️⃣**tracert：在网络层使用UDP，跟踪分组经过的路由

# 4. IPv6：彻底结局IPv4耗尽问题

> ## 4.1. IPv6特点
>
> > ### 4.1.1. 基本特点
> >
> > > **1️⃣**空间扩展：长128位，可划分层次也更多了
> > >
> > > **2️⃣**首部格式灵活，首部长度必须是64bit的倍数，且简化为了8段
> > >
> > > **3️⃣**允许协议扩充
> > >
> > > **4️⃣**支持即插即用(自动配置)，支持资源与分配
> > >
> > > **5️⃣**支持选项：必要项变成可选项，使路由器能跳过无关项
> >
> > ### 4.1.2. 兼容性
> >
> > > **1️⃣**与IPv4不兼容
> > >
> > > **2️⃣**与其他网络协议兼容，只需改变处理地址长即可
>
> ## 4.2. IPv6数据包首部：一共40B
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231215011236189.png" alt="image-20231215011236189" style="zoom:50%;" /> 
> >
> > **1️⃣**priority：数据包优先级的标识符
> >
> > **2️⃣**flow label：识别数据报是否属于相同流
> >
> > **3️⃣**next header：下一个报头，识别数据的上层协议
>
> ## 4.3. IPv6→IPv4
>
> > 双栈技术&隧道技术

# 5. 路由算法

> ## 5.1. 路由算法概述
>
> > **1️⃣**什么是路由算法：生成路由表的算法，路由表控制分组转发
> >
> > **2️⃣**以是否能更具信息量/拓扑自适应调整，分为：
> >
> > 1. 静态/非自适应路由选择：手动搭建每条路由，多用于小网络，简单开销小
> > 2. 动态/自适应路由选择：多用于复杂网络，复杂开销大，又分为：
> >    - 链路状态路由算法(LS)：具全局性，维护一个全局的拓扑图
> >    - 距离-向量路由算法(DV)：具有分布性，无需维护一个全局的拓扑图
> >
> > **3️⃣**算法数据结构：用图，结点标识路由器，线表示链路
>
> ## 5.2. 链路状态路由算法
>
> > **1️⃣**算法概述：主动测试所有邻结点连接状态，定期传播链路状态给其他点，是的人每个系欸但那都有完全网络拓扑信息
> >
> > **2️⃣**算法核心：==Dijikstra算法==，这个自不必多说
> >
> > **3️⃣**其他
> >
> > 1. 算法改进：引入优先队列，复杂度可$O (n^2)\to{}O(n\text{logn})$
> > 2. 算法缺点：存在震荡，会有随即延迟
>
> ## 5.3. 距离-向量路由算法
>
> > ### 5.3.1. 算法特征
> >
> > > **1️⃣**分布式：每个结点从邻居获得信息→计算→将结果发给邻居
> > >
> > > **2️⃣**迭代+自终止：重复上述过程直到邻居无更多信息要交换，算法结束
> > >
> > > **3️⃣**异步：所有节点迭代的步伐不必一致
> >
> > ### 5.3.2. 算法思想&伪代码
> >
> > > **1️⃣**Bellman-Ford方程：$d_x(\text{y})=min_v\{c(x,v)+d_v(\text{y})\}$
> > >
> > > 1. 符号：$d_x(\text{y})$是$x\to{y}$路径最小开销，$c(x,v)$是$x$到其某一邻居$v$的路径
> > > 2. 思想：$x\to{y}$的最短路径，一定要经过邻居$v$中的个，遍历所有邻居就有可能求得
> > >
> > > **2️⃣**结点$x$的距离向量：$\pmb{D}_x=[\pmb{D}_x(y):y\in N]$
> > >
> > > 1. $y$：除$x$以外的其他所有节点之一
> > > 2. $\pmb{D}_x(y)$：结点$x$到其他结点$y$的开销估计
> > > 3. $\pmb{D}_x$：即$[\pmb{D}_x(y_1),\pmb{D}_x(y_2),.....]$
> > >
> > > **3️⃣**结点$x$维护的信息：所有邻居的$c(x,v)$，自生的距离向量$\pmb{D}_x$，所有邻居的距离向量$\pmb{D}_v$
> > >
> > > **4️⃣**算法操作
> > >
> > > 1. 每个节点周期性地，向每个邻居发送其距离向量副本
> > >
> > > 2. 当$x$收到$v$新的距离向量，则用Bellman-Ford方程更新距离向量
> > >
> > >    $\pmb{D}_x(\text{y})=min_v\{c(x,v)+\pmb{D}_v(\text{y})\}\,,y\in N$
> > >
> > > 3. 如果$\pmb{D}_x$因此改变，则向所有邻居立即更新其距离向量
> > >
> > > 4. 重复下去，最终迭代得到最低路径开销
> > >
> > > **5️⃣**算法伪代码，==背下来==
> > >
> > > ```Cpp
> > > //初始化x的距离向量
> > > for(所有其他结点y)
> > > {
> > >    if(y是邻居) Dx(y)=c(x,y);
> > >    else Dx(y)=infinity;
> > > }		
> > > //将x的距离向量发给所有邻居
> > > for(所有邻居w) 
> > > {
> > >    将 Dx=[Dx(y):y in N] 送给 w;
> > > }
> > > //无限循环，处理网络变化
> > > while(1)
> > > {
> > >    wait_until(x到邻居w的链路成本变化||收到邻居w的更新信息)
> > >       for(所有其他结点y)
> > >       {
> > >          Dx(y)=min_v {c(x,v)+D_v(y)};//更新x到其余所有节点距离，以此更新x距离向量
> > >       }
> > >    if(对任何结点y, Dx(y)变化)
> > >    {
> > >       将Dx(y)最小值发给所有邻居 
> > >    }
> > > }
> > > ```
> >
> > ### 5.3.3. 算法示例
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231215024313184.png" alt="image-20231215024313184" style="zoom:80%;" />  
> > >
> > > **1️⃣**初始化：初始化每个结点的路由选择表，包括结点自己的距离向量，邻居的距离向量全部设为无穷
> > >
> > > 完成后结果为图中第一列
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231215024339419.png" alt="image-20231215024339419" style="zoom: 80%;" /> 
> > >
> > > **2️⃣**周期性更新+计算：完成后结果为图中第二列
> > >
> > > 1. 每个结点向邻居更新距离向量：如图中箭头的指向
> > > 2. 结点收到更新后：重新计算自身的距离向量，以$x$结点为例有
> > >
> > > $$
> > > \begin{align}
> > > &\pmb D_x(x)=0\\
> > > &\pmb D_x(y)=\text{min}\{c(x,y)+\pmb D_y(y),c(x,z)+\pmb D_z(y)\}=\text{min}\{2+0,7+1\}=2\\
> > > &\pmb D_x(z)=\text{min}\{c(x,y)+\pmb D_y(z),c(x,z)+\pmb D_z(z)\}=\text{min}\{2+1,7+0\}=3\\
> > > \end{align}
> > > $$
> > >
> > > **3️⃣**改变后更新+计算：
> > >
> > > 1. $x,z$因为上一步，距离向量发生改变，所以立即让二者向邻居更新距离向量
> > > 2. 更新后再计算，算无可算算法静止，<mark>**直到一条链路开销发生改变**</mark>
> >
> > ### 5.3.4. 链路开销改变&链路故障
> >
> > > $x$与邻居$v$的开销改变：更新距离，在最低开销变化时，告诉所有邻居新距离向量
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231215031702630.png" alt="image-20231215031702630" style="zoom:50%;" /> 
> > >
> > > **1️⃣**好消息传达速度快：当4→1的变化发生时，以下时间挨个发生
> > >
> > > 1. $y$检测到开销变化，更新$\pmb{D}_y$，向邻居更新新的距离向量
> > >
> > > 2. $z$收到来自$y$的更新距离表，计算出$z\to{x}$最小开销(从5减为2)，向邻居更新新的距离向量
> > >
> > > 3. $y$收到来自$z$的更新距离表，$y$开销未变所以不发送任何信息，算法静止
> > >
> > > **2️⃣**坏消息传达速度慢：当4→60后，要迭代44此算法才会静止，这样容易造成无穷计数
> >
> > ### 5.3.5. 算法改进：增加毒性逆转
> >
> > > 以$z\to{}x$为例
> > >
> > > **1️⃣**操作：当路由是$z\to{y}\to{x}$时，$z$就持续给$y$撒谎that有$D_z(x)=∞$
> > >
> > > **2️⃣**好处：避免环路，加快收敛
>
> ## 5.4. LS/DV算法比较
>
> > | 算法 | 报文多少 | 收敛速度 |         健壮性         |
> > | :--: | :------: | :------: | :--------------------: |
> > |  LS  |    多    |    快    | 大(错误只影响单个顶点) |
> > |  DV  |    少    |    慢    | 小(错误会影响整个网络) |

# 6. 路由选择

> ## 6.1. 自治系统(AS)：一堆路由器聚集
>
> > **1️⃣**协议运行：
> >
> > 1. 同一AS内所有路由器运行相同协议，即内部网关协议(IGP)
> > 2. 不同AS的路由器运行不同协议
> > 3. 所有AS运行相同的AS间路由协议，即边界网关协议(BGP)
> >
> > **2️⃣**ASN：一个自治系统由一个ASN唯一标识
> >
> > **3️⃣**网关路由器：直接连接另一个AS的路由器
>
> ## 6.2. 网关路由选择
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/tq39PxMvgfXOQ7u.png" alt="image-20231215123905877" style="zoom:50%;" /> 
> >
> > ### 6.2.1. 起因
> >
> > > **1️⃣**AS1中路由器收到发往其他AS的数据报
> > >
> > > **2️⃣**AS1搞清，哪些路由可通过AS2/AS3访问，此处X都可通过AS2/AS3访问
> > >
> > > **3️⃣**通过跨网关协议把可达性信息传给AS1内所有路由器
> > >
> > > **4️⃣**AS1内路由器将选一个网关路由器，转发数据报
> >
> > ### 6.2.2. 热土豆路由选择
> >
> > > **1️⃣**思想：以最小开销一股脑把分组送出AS1，至于送出AS1后分组到达目的地的成本，则完全不管
> > >
> > > **2️⃣**示例：上图分组发往1d后，1d就会选择将分组转给1b(近)而不是1c(远)
>
> ## 6.3. 路由协议
>
> > | 特点         | RIP                    | OSPF                   | BGP                |
> > | ------------ | ---------------------- | ---------------------- | ------------------ |
> > | 网关协议     | 内部                   | 内部                   | 外部               |
> > | 路由表内容   | 目的网络，下一跳，距离 | 目的网络，下一跳，距离 | 目的网络，完整路径 |
> > | 最优通路依据 | 跳数                   | 费用                   | 多种有关策略       |
> > | 算法         | 距离-矢量算法          | 链路状态算法           | 路径-矢量算法      |
> > | 传送方式     | UDP                    | IP数据报               | TCP连接            |
> > | 其他         | 简单，效率低           | 效率高，规模大         | \                  |
> >
> > ### 6.3.1. 内部网关协议IGP
> >
> > > **1️⃣**路由信息协议RIP：基于DV算法(距离-向量)
> > >
> > > 1. AS内部最远两点不超过15跳，直接不超过15跳，周长不超过25跳
> > > 2. 每30s结点将距离向量广播给邻居
> > > 3. 180s内没收到邻居的广播则认为邻居已断开，重新计算BF方程，广播链路故障信息
> > > 4. 最优路径不唯一，则选其中一条
> > > 5. 算法由应用层的route-d进程管理
> > >
> > > **2️⃣**开放最短路径优先OSPF：基于链路状态算法(Dijikstra)
> > >
> > > 1. 周期性地广播自己跟谁连，代价多少，广播给整个AS，周期30min
> > > 2. 运行在网络层上部，报文封装在IP报文中，是不可靠协议
> >
> > ### 6.3.2. 边界网关协议BGP
> >
> > > **1️⃣**边界网关维护的不是路由表，而是路径表
> > >
> > > **2️⃣**BGP为每个AS提供如下方法
> > >
> > > 1. 向邻居应用服务器获取子网可达性信息
> > > 2. 将可达性信息传播到所有AS内部路由器
> > > 3. 根据可达性信息和策略确定到AS的好路由
> > >
> > > **3️⃣**路由选择：优先使用本地策略，本地缺省时使用最短路径+热土豆
> > >
> > > **4️⃣**四种报文：
> > >
> > > 1. OPEN：与相邻的BGP建立联系
> > > 2. UPDATE：发送某一路由信息
> > > 3. KEEPALIVE：打开报文+周期性证实邻居关系
> > > 4. NOTIFICATION：报告报文错误，关闭TCP

# 传输层

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter5.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter5.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter5.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter5.html)==**

# 1. 概述

> **1️⃣**传输层功能的：
>
> 1. 实现进程间的逻辑通信(相比下，网络层实现的是主机之间的逻辑通信)
> 2. 差错检测
> 3. 多路复用/分解
> 4. 提供无连接/面向连接的服务
>
> **2️⃣**传输层协议：TCP和UDP，==在端系统(而非路由器)中实现==
>
> **3️⃣**传输层基本工作过程：
>
> 1. 发送端应用层：应用进程将报文丢给传输层
> 2. 发送端传输层：将应用层来的报文转化为传输层报文(切块+加上传输层首部)，完成后丢给网络层
> 3. 发送端网络层：封装成分组，发出去
> 4. 接收端网络层：接收，并提取出传输层报文段，送给传输层
> 5. 接收端传输层：处理收到报文，使得报文中的数据可供应用进程使用
> 6. 接收端应用层：收到并使用数据
>
> **4️⃣**IP/TCP/UDP概述
>
> 1. IP概述：每个主机至少一个IP，IP协议是尽力而为的不可靠协议，不保证数据交付的顺序和完整性
> 2. TCP/UDP职责：
>    - ==多路复用/分解==：IP交付/主机交付$\xrightarrow{扩展}$进程间的交付服务
>    - ==提供完整性检查==：根据报文首部的差错检查字段
> 3. UDP：也是不可靠的，只能提供差错检测+进程端端交付

# 2. 多路复用/分解

> ## 2.1. 基本概念
>
> > **1️⃣**套接字：网络和进程间数据传递的门户，由进程持有，传输层$\xleftrightarrow{收到数据}$套接字$\xleftrightarrow{收到数据}$进程
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231215184104954.png" alt="image-20231215184104954" style="zoom: 50%;" /> 
> >
> > **2️⃣**多路分解==(接收端)==：传输层检查报文某些字段→识别出接收套字→将报文交付给正确套接字
> >
> > **3️⃣**多路复用==(发送端)==：从套接字处收集数据块→为每个数据块封装上首部(用于分解)→通过网络层发送
> >
> > 就好比课代表发作业(多路分解)，收作业给老师(发送端)
>
> ## 2.2. 传输层能多路分解/复用的要求
>
> > **1️⃣**套接字有唯一标识符
> >
> > **2️⃣**每段有特殊字段(源端口号+目的端口号)，标识索要交付到的套接字
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231215185854755.png" alt="image-20231215185854755" style="zoom: 67%;" /> 
> >
> > ➕端口号：16位，0-1023的为周知端口号，大于1023的是用户端口号
>
> ## 2.3. 两种多路复用/分解
>
> > |            |        无连接的        |                有连接的                |
> > | :--------: | :--------------------: | :------------------------------------: |
> > |    协议    |          UDP           |                  TCP                   |
> > | 套接字格式 | `<目的IP><目的端口号>` | `<源IP><目的IP><源端口号><目的端口号>` |
> >
> > **1️⃣**只有套接字两项/四项完全相同时，报文才会被送到相同套接字
> >
> > **2️⃣**无连接的应用程序，自动分配端口号

# 3. 用户数据报协议(UDP)

> ## 3.1. 概述
>
> > **1️⃣**数据报：UDP的段
> >
> > **2️⃣**UDP完成工作：有且仅有多路复用/分解+差错检测，也就是传输层最基本的工作，直接和IP交互
> >
> > **3️⃣**UDP的特点
> >
> > 1. 简单无连接：传输数据前双方不事先连接
> > 2. 是best effort服务：尽最大努力传输，但不保证可靠性/顺序
> > 3. 速度快
> > 4. 首部小：只有8字节，开销小
> >
> > **4️⃣**UDP的应用：NFS，流式多媒体，DNS
>
> ## 3.2. UDP报文段结构
>
> > 段头+数据，其中段头只有32bit，含源端口号+目的端口号+长度+校验
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231215200418989.png" alt="image-20231215200418989" style="zoom: 67%;" /> 
>
> ## 3.3. UDP校验&checksum
>
> > **1️⃣**目的：检测UDP报文从源到目的过程中，是否发生改变
> >
> > **2️⃣**特点：检错能力很弱
> >
> > **3️⃣**检错步骤：将段的内容看作16为二进制数集合
> >
> > - 发送端：
> >   1. 获得校验和：所有16位二进制数相加→截取低16位→结果按位取反
> >   2. 将校验和输入UDP校验和字段Checksum
> > - 接收端
> >   1. 对段内容所有16位二进制相加，截取低16位
> >   2. 将结果+Checksum，如果全为1111111111111111就没出错

# 4. 传输控制协议TCP

> 观前提醒：ACK是指确认收到数据的信号
>
> ## 4.1. TCP概述
>
> > **1️⃣**特点
> >
> > 1. 点对点：发送/接收方都只能有一个
> > 2. 可靠的
> > 3. 无报文边界：字节以有序流发送数据，而不是分成独立报文
> > 4. 流水线式：通过设置窗口大小，实现拥塞/流量控制
> > 5. 全双工：数据可以同时双向传输，UDP同样
> >
> > **2️⃣**结构概览
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231215203029791.png" alt="image-20231215203029791" style="zoom:50%;" /> 
> >
> > **3️⃣**功能：三控一管，可靠性/流量/拥塞控制，连接管理
>
>
> ## 4.2. TCP段文
>
> > ### 4.2.1. 段文格式：一共五行20字节
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20220315113207545.png" alt="image-20220315113207545" style="zoom: 60%;" /> 
> > >
> > > **1️⃣**第一行：==源端+目的端口号==
> > >
> > > **2️⃣**第二行：==序列号==，TCP的传输是一个个字节流送的，要给每个字节编号保证按序交付
> > >
> > > **3️⃣**第三行：==确认号==，TCP有确认机制(接收端$\xrightarrow{ACK}$发送端，当ACK=N则N-1及以前的数据都已收到
> > >
> > > **4️⃣**第四行：
> > >
> > > 1. ==首部长度==
> > >
> > > 2. ==保留字段==：占6位，忽略不计
> > >
> > > 3. ==标志位==
> > >
> > > | 标志位     | 标志位=0         | 标志位=1                                           |
> > > | :--------- | ---------------- | -------------------------------------------------- |
> > > | U(URG紧急) | 紧急指针字段无效 | 有效，报文中有紧急数据，优先级高                   |
> > > | A(ACK确认) | 确认号字段无效   | 有效，TCP连接建立后，所有ACK=1                     |
> > > | P(PSH推送) | \                | 收到PSH=1的报文，会优先上交给应用进程              |
> > > | R(RST复位) | \                | 当RST=1时，说明TCP连接崩溃，需要释放连接重传       |
> > > | S(SYN同步) | \                | 当SYN=1时，表示整个报文是一个连接请求/连接接收报文 |
> > > | F(FIN终止) | \                | 当FIN=1时，表示数据传输结束，就地释放连接          |
> > >
> > > 4. ==窗口字段==：**明确指定了目前允许对方发送的数据量**
> > >
> > > **5️⃣**第五行
> > >
> > > 1. ==校验和字段==：检测范围包括首部+数据，计算校验和时需要在TCP报头前加上12B伪首部
> > > 2. ==紧急指针字段==：前面已说，由URG控制
> > >
> > > **6️⃣**第六行开始：==选项字段==，长度可变，内容可选(最早的内容为MSS)
> > >
> > > **7️⃣**最尾部：==填充字段==，填充使整个首部长度为32bit整数倍
> >
> > ### 4.2.2. 其他
> >
> > > **1️⃣**最大段大小(MSS)：536字节
> > >
> > > **2️⃣**TCP段文$\xleftrightarrow{协同工作}$IP数据报
> > >
> > > 1. TCP报文首部不包含IP地址，IP地址在IP数据报首部
> > > 2. IP层负责处理目的IP：TCP协议在发送数据时，依赖于IP协议来确定数据报的目的地
>
> ## <font color='red'>4.3. TCP的可靠性控制：丢包重传</font>
>
> > ### 4.3.1. 发送窗口(发送缓冲区)
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231215215827220.png" alt="image-20231215215827220" style="zoom: 67%;" /> 
> > >
> > > **1️⃣**数据结构：开始指针send_base + 窗口大小n + 下一个序列号nextseqnum
> > >
> > > **2️⃣**发送窗口的行为
> > >
> > > 1. 应用层请求通过传输层发送数据，先检查nextseqnum是否有效
> > > 2. 有效的话，就将nextseqnum封装成TCP段发送，同时nextseqnum++
> > > 3. 一直移动到nextseqnum - send_base = N(窗口满)，无法继续发应用层塞的数据了
> > > 4. 直到接收方发回ACK，根据ACK，send_base右移，跳过已确认收到的段
> > >
> > > **3️⃣**丢失段和发送窗口
> > >
> > > 1. 发送窗口一定包含丢失段
> > > 2. 如何判定窗口中的段已丢失：发回的ACK包含了段序号，超时后ACK还没某段序号就重传
> >
> > ### 4.3.2. 接收窗口(接收缓冲区)
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231215221308062.png" alt="image-20231215221308062" style="zoom:67%;" /> 
> > >
> > > **1️⃣**数据结构：开始指针rcv_base + 窗口大小n，其中rcv_base指向
> > >
> > > **2️⃣**核心机制：**通过发送期待接收下一个段的序列号，以此来确认收到当前段**
> > >
> > > **3️⃣**接收窗口的行为
> > >
> > > 1. rcv_base指向接收方期待收到的段的段号==(第一个灰色)==
> > > 2. 串口内不断收到段==(红色)==，在期待段到达前，先将红色的缓存起来==(蓝色的为空闲接收缓存)==
> > > 3. 期待段到后，连通所有红段都一起上交应用层
> > > 4. rcv_base来到下一个期待收到的段(第二个灰色处)
> >
> > ### 4.3.3. 发送端的可靠性控制
> >
> > > **1️⃣**控制机制：
> > >
> > > 1. 只有一个状态即等事件，状态迁移结尾等事件→等事件
> > > 2. 假设无流量/拥塞控制，应用层给到的数据长度小于MSS，数据传输单向
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231216000326732.png" alt="image-20231216000326732" style="zoom:67%;" /> 
> > >
> > > **2️⃣**快速重传：代表了轻度拥塞(超时对应重度拥塞)
> > >
> > > 1. 接收端没收到期待包，不论接下来收到了什么都只会返回期待包的ACK，因为TCP要求数据有序
> > > 2. 当返回相同ACK三次，就可认为这个ACK所代表的包已经丢了
> > > 3. 启动快速重传
> > >
> > > **3️⃣**==伪代码==
> > >
> > > ```Cpp
> > > send_base = init_sequence number
> > > nextseqnum = init_sequence number
> > > loop(永远){
> > > 	switch(事件)
> > > 	事件:应用层有数据让TCP传输
> > > 		if(nextseqnum-send_base<N){
> > > 			创建段序号为nextseqnum的段
> > > 			启动计时器
> > > 			将段发给IP层
> > > 			nextseqnum = nextseqnum +数据长度/*段序号是跳跃式的*/
> > > 		}else{
> > > 			拒绝发送段
> > > 		}
> > > 	事件:段序号为y的段的计时器超时
> > >         重传这个段y
> > > 		重新计算计时器超时间隔
> > > 		重启计时器
> > > 	事件:接收到ACK，字段值为y
> > >         if(y>send_base){/*段在发送窗口内*/
> > >             取消掉段y之前所有的段的计时器
> > >             send_base = y/*窗口右移*/
> > >         }else{/*这里指的是y=send_base，接收端还没有收到y*/
> > >             对ACK字段为y的计数器+1
> > >             if(计数器的值==3){
> > >                 快速重传段y
> > >                 重启段y的计时器
> > >             }
> > >         }
> > > }
> > > ```
> >
> > ### 4.3.4. 接收端的可靠性控制
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231216002644621.png" alt="image-20231216002644621" style="zoom:67%;" /> 
> > >
> > > | 收到段的特征                              | TCP接收端动作                                                |
> > > | ----------------------------------------- | ------------------------------------------------------------ |
> > > | 有序到达<br/>无间隙<br/>其他段都已确认    | 延迟等待下一个段0.5s<br/>1. 期间如果下一段来了则二者一起确认<br/>2. 没来的话就发送ACK |
> > > | 有序到达<br/>无间隙<br/>有一个ACK在做延时 | 就是上述“下一段”，二者立刻一起确认ACK                        |
> > > | 乱序到达<br/>有间隙<br/>(如上图红色部分)  | 立即发ACK，内容为期待段的段号                                |
> > > | 乱序到达<br/>但填满了某些间隙             | 目的在于补齐gap，间隙成因有两种(期待段空缺+其他乱序段间空缺)<br/>1. 收到期待段(左灰)：连同右边连着的红段送给应用层，窗口右移<br/>2. 收到其他段(右灰)：收到段变红，返回ACK(内容为期待段段号) |
> > > | 收到段位于窗口左侧                        | <mark>丢弃段</mark>                                          |
> >
> > ### 4.3.5. TCP往返时间和超时
> >
> > > **1️⃣**一些概念
> > >
> > > 1. 超时时间间隔：数据发送后，在这个时间内还未收到ACK，就要重传
> > > 2. RTT：数据包的往返时间，理想超时时间间隔应该略大于RTT
> > > 3. 安全边际：略大于RTT，略大于的这部分就是安全边际
> > >
> > > **2️⃣**如何预测RTT：一般$\alpha=1/8,\beta{=1/4}$
> > >
> > > 1. $\text{sample}RTT$：策略从传输→收到ACK的时间差，缺点是波动大
> > >
> > > 2. $\text{estimate}RTT$：用EWMA平滑估计RTT
> > >
> > >    $\text{estimate}RTT_n=(1-\alpha)\text{estimate}RTT_{n-1}+\alpha{}\text{sample}RTT$
> > >
> > > 3. $\text{deviation}$：估计前两者的差距，来反映波动性大小
> > >
> > >    $\text{deviation}_n=(1-\beta)\text{deviation}_{n-1}+\beta{}|\text{sample}RTT-\text{estimate}RTT|$
> > >
> > > **3️⃣**超时时间间隔$=\text{estimate}RTT+4*\text{deviation}$
>
> ## 4.4. TCP流量控制
>
> > ### 4.4.1. 概述
> >
> > > **1️⃣**背景：发送太快，接收端应用程序读取太慢，就会造成接收窗口溢出
> > >
> > > **2️⃣**流量控制的含义：让发送方发送速率=接收方应用程序读取速率，防止溢出
> > >
> > > **3️⃣**核心机制：
> > >
> > > 1. TCP段头中有一个字段表示接收窗口大小
> > > 2. 接收窗口会给发送方指明，==接收方还有多少可用缓存==
> >
> > ### 4.4.2. 控制过程
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231216125716965.png" alt="image-20231216125716965" style="zoom: 50%;" />  
> > >
> > > **1️⃣**接收端行为：A通过TCP连接向B发文件，B为该连接分配接收缓存，B的应用不断从缓存取走数据
> > >
> > > **2️⃣**接收有关变量
> > >
> > > 1. `LBRead`：缓存中被读走的最后一个段的段号
> > > 2. `LBRcvd`：缓存中刚收到的段的段号
> > > 3. `RcvBuffer`：缓存大小，满足`LBRcvd-LBRead ≤ RcvBuffer`
> > > 4. `rwnd`：接收窗口(空闲缓存)，等于`RcvBuffer-[LBRcvd-LBRead]`，初始为`rwnd=RcvBuffer`
> > >
> > > ⚠️主机A需要明白B的`rwnd`还有多大，通过将`rwnd`放到B传回给A的报文的接收窗口字段即可
> > >
> > > **3️⃣**发送端有关变量
> > >
> > > 1. `LBSent`：最后一个被送出的字节
> > > 2. `LBAck`：最后一个被确认的字节，`LBAck-LBSent`就是发出但未收到确认的数据
> > >
> > > ==**4️⃣**流量控制的核心：在主机A的整个生命周期，保证LBAck-LBSent ≤ rwnd==
> >
> > ### 4.4.3. 零窗口探测
> >
> > > **1️⃣**Bug所在：
> > >
> > > 1. 当B端`rwnd=0`时，发送端A必定会停止发送
> > > 2. B然后不会向A反馈`rwnd=0`的变化，因为TCP只在发信/ACK时才发送报文
> > > 3. 之后B的应用程序会取走缓存使得`rwnd>0`，但是A就也无法得知了
> > >
> > > **2️⃣**Debug所在
> > >
> > > 1. 不论`rwnd=0`与否，A都定期发送只包含1字节的探测报文段
> > > 2. 接收了探测报文的B端，无论如何都不可能是零窗口了，即可恢复数据传输
>
> ## 4.5. TCP的连接管理
>
> > ### 4.5.1. 开启连接：三次握手
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231216135849718.png" alt="image-20231216135849718" style="zoom:50%;" /> 
> > >
> > > (Client=发送端，Serve=接收端)
> > >
> > > |  握手  | 方向 | 报文类型 | Client初始序列号 | Server初始序列号 | 确认号 |
> > > | :----: | :--: | :------: | :--------------: | :--------------: | :----: |
> > > | 第一次 | C→S  |   SYN    |       `J`        |        \         |   \    |
> > > | 第二次 | S→C  | SYN+ACK  |        \         |       `K`        | `J+1`  |
> > > | 第三次 | C→S  |   ACK    |        \         |        \         | `K+1`  |
> > >
> > > **1️⃣**三次握手后TCP连接建立，Clinet开辟缓存，开始传输
> > >
> > > **2️⃣**补充说明：`J`和`K`是随机生成，ACK/SYN/FIN报文的报头对应标志位为1
> > >
> > > **3️⃣**DDos攻击：永远吊在第三次握手未完成状态。服务器不断开辟内存，直到服务器崩溃
> >
> > ### 4.5.2. 关闭连接：四次握手
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231216145843631.png" alt="image-20231216145843631" style="zoom:50%;" /> 
> > >
> > > |  握手  | 方向 | 报文类型 |        C-S行为         |
> > > | :----: | :--: | :------: | :--------------------: |
> > > | 第一次 | C→S  |   FIN    | 所以爱会消失的，结束吧 |
> > > | 第二次 | S→C  |   ACK    |          好的          |
> > > | 第三次 | S→C  |   FIN    |       那就结束吧       |
> > > | 第四次 | C→S  |   ACK    |     好的，达成共识     |
> > >
> > > 四次握手后，要等一段时间TCP连接才正真关闭
>
> ## 4.6. 拥塞控制
>
> > ### 4.6.1. 拥塞控制概述
> >
> > > <img src="https://s2.loli.net/2023/12/16/9oMervkJyqpwch3.png" alt="image-20231216153417954" style="zoom: 50%;" />  
> > >
> > > **1️⃣**拥塞：是指路由器的拥塞
> > >
> > > **2️⃣**表现：丢包(路由器缓冲区溢出)，长延迟(一直在路由器缓冲区中排队)
> > >
> > > **3️⃣**成因：
> > >
> > > 1. 长延时：发送端发送总速度>路由器交换能力，**延时太大了会被误以为丢包，而进行无意义重传**
> > > 2. 丢包：发送端塞给路由器的数据>路由器有限的缓存
> > >
> > > **4️⃣**分类
> > >
> > > 1. 网络帮助的拥塞控制：交换机检测到拥塞后直接控制，可为交换机→发端，交换机→收端→发端
> > > 2. 端到端的拥塞控制：端系统功能强(路由器相对弱)，端根据网络反馈调节拥塞(超时/快速重传)
> >
> > ### 4.6.2. ATM(异步传输模式)的拥塞控制
> >
> > > **==Old Fashined==**
> > >
> > > **1️⃣**ATM业务类型
> > >
> > > | 类型 | 名称                 | 描述                       | 特点                   |
> > > | ---- | -------------------- | -------------------------- | ---------------------- |
> > > | ABR  | Available Bit Rate   | 有效位率服务，用于视频     | 可能丢包，保证最小带宽 |
> > > | CBR  | Constant Bit Rate    | 用于实时语音通信           | 不丢包，不拥塞控制     |
> > > | VBR  | Variable Bit Rate    | 变动位率服务               | 不丢包，不拥塞控制     |
> > > | UBR  | Unspecified Bit Rate | 有资源则使用，无资源则丢包 | 免费使用，无拥塞控制   |
> > >
> > > **2️⃣**信元：ATM的数据单元
> > >
> > > 1. 数据信元
> > > 2. 资源管理信元：存放拥塞信息，同工厂几十个信元里就有一个资源管理信元
> > >
> > > **3️⃣**ATM的ABR拥塞控制方法
> > >
> > > 1. 信元头部加CI(拥塞指示)和NI位(不增加速率)：拥塞后CI=1发端会降低发送速率，NI用于让发端速率不再增加
> > > 2. ER设置：这是在资源管理信元的字段，告诉发端可以按多大速率发数据，有多个则取最小
> > > 3. EFCI：位于数据信元，检测到拥塞后置1
> >
> > ### 4.6.3. TCP的拥塞控制
> >
> > > **1️⃣**两种判断：超时(重度拥塞)，收到三个相同ACK(轻度拥塞)
> > >
> > > **2️⃣**探测拥塞：慢启动(不断*2)+拥塞避免(改为+1)
> > >
> > > ```txt
> > > 第1个RTT：发1个探测段，收到1个ACK则没拥塞
> > > 第2个RTT：发2个探测段，收到2个ACK则没拥塞
> > > 第3个RTT：发4个探测段，收到4个ACK则没拥塞
> > > ........n次试探后还没拥塞.......
> > > 第n+1个RTT：发$2^n$+1个测试段
> > > ```
> > >
> > > **3️⃣**TCP慢启动
> > >
> > > 1. 慢启动过程
> > >
> > >    <img src="https://s2.loli.net/2023/12/16/4actJeTgGoEs92f.png" alt="image-20231216164931223" style="zoom:50%;" /> 
> > >
> > > 2. 慢启动伪代码
> > >
> > >    ```Cpp
> > >    threshold=适当的值(10、20...不要太大) //阈值，区分慢启动和拥塞避免
> > >    Congwin=1 //拥塞控制时，使用的窗口大小
> > >    for(每个确认段) //每收到一个ACK窗口就+1，第一轮1个ACK，第二轮2个，第三轮4个...
> > >    	Congwin++
> > >    until(丢包&&ngWin>=threshold)
> > >    ```
> > >
> > > **4️⃣**拥塞避免   
> > >
> > > 1. Tahoe拥塞避免算法伪代码：不合理的点在于没区分轻度/重度拥塞，一股脑将Congwin=1
> > >
> > >    ```Cpp
> > >    //慢启动结束
> > >    while (没有丢包) {
> > >      每w个段被确认:
> > >          Congwin++//每个RTT，窗口+1线性增加
> > >    }
> > >    //如果丢包则退出循环
> > >    threshold = Congwin/2
> > >    Congwin = 1
> > >    //重启慢启动
> > >    ```
> > >
> > > 2. Reno拥塞算法伪代码：吞吐率更高，震荡更小
> > >
> > >    ```Cpp
> > >    //慢启动结束
> > >    while (没有丢包) {
> > >      每w个段被确认:
> > >          Congwin++//每个RTT，窗口+1线性增加
> > >    }
> > >    //如果丢包则退出循环
> > >    threshold = Congwin/2
> > >    if(因为超时丢包){//重度拥塞
> > >        Congwin = 1
> > >    	重启慢启动
> > >    }
> > >    if(因为收到三个相同确认段丢包){//轻度拥塞，只需要快速恢复
> > >        Congwin = Congwin/2
> > >        goto: while循环
> > >    }
> > >    ```
> > >
> > > **5️⃣**平均吞吐率$\approx \cfrac{1.22MSS}{RTT\sqrt{L}}$，$L$为丢包率，$MSS$为最大段大小
> > >
> > > **6️⃣**算法特点：
> > >
> > > 1. 线性增加窗口，丢包后指数减少窗口
> > > 2. 有效，收敛，公正，友好

# 应用层

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter6.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter6.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter6.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/Chapter6.html)==**

**1️⃣**协议模式：传输层服务模式，C-S模式，P2P模式

**2️⃣**协议：HTTP，FTP，SMTP/pop3/imap，DNS

**3️⃣**网络编程：套接字socketAPI

# 1. 应用层协议原理

> 将app限制在端系统，研发网络应用的核心在于能在不同端系统运行+通信
>
> ## 1.1. 网络APP体系结构
>
> > **1️⃣**C-S结构：比如Web/FTP/电子邮件
> >
> > 1. 服务器：不间断的主机，有永久IP
> > 2. 客户端：与服务器(间歇)通信，有动态IP
> >
> > **2️⃣**P2P结构：适用于流量密集的APP，高可扩展但难管理
> >
> > 1. 服务器：妹有
> > 2. 端系统：实质上又当C又当S，互相直连通信，间歇式连接，IP变化
> >
> > **3️⃣**混合体系结构
> >
> > 1. Skype：一方面是基于IP的P2P应用，但是查找远程方地址时又用C-S
> > 2. Telegram：两用户聊天是P2P，但集中式服务基于C-S(用户上线请求注册IP，查找好友IP)
>
> ## 1.2. 进程通信
>
> > **1️⃣**两种进程通信：同一主机中的两进程(通过OS内核完成)，不同主机间进程(通过消息交换完成)
> >
> > **2️⃣**两种进程：客户端进程(发起通信)，服务器进程(等待被联系)
> >
> > **3️⃣**socket套接字：aka网络和APP间的API，一种软件接口，连接进程和网络(即应用层与传输层)
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231216193453049.png" alt="image-20231216193453049" style="zoom:50%;" /> 
> >
> > **4️⃣**进程寻址：
> >
> > 1. 即进程的标识，格式为IP(标识主机)+端口号(标识进程)
> > 2. 端口：例如HTTP服务端口为80，邮件服务端口为25
>
> ## 1.3. 应用层协议概述
>
> > **1️⃣**应用层协议定义了什么
> >
> > 1. 交换报文的类型：例如请求/响应
> > 2. 消息语法：消息中有什么字段&字段如何描述
> > 3. 字段语法：字段中消息的含义
> > 4. 规则：进程何时/如何响应报文
> >
> > **2️⃣**种类：
> >
> > 1. 公共协议：在RFC(请求注解)中定义，例如HTTP/SMTP/BitTorrent
> > 2. 专用协议：例如Skype
>
> ## 1.4. Internet的QoS(服务质量)要求
>
> > 丢包率，实时性(低时延)，吞吐量，安全性
> >
> > |    应用程序     | 允许丢包？ |                  吞吐量                  | 具有时间敏感性？ |
> > | :-------------: | :--------: | :--------------------------------------: | :--------------: |
> > |    文件传输     |     0      |                  弹性的                  |        0         |
> > |     e-mail      |     0      |                  弹性的                  |        0         |
> > |     Web文档     |     0      |                  弹性的                  |        0         |
> > |  实时音频/视频  |     1      | 音频: 5kbps-1Mbps<br />视频:10kbps-5Mbps |     1(100ms)     |
> > | 存储式音频/视频 |     1      | 音频: 5kbps-1Mbps<br />视频:10kbps-5Mbps |     1(几秒)      |
> > |    互动游戏     |     1      |                超过几kbs                 |     1(100ms)     |
> > |   实时发信息    |     0      |                  弹性的                  |     是或不是     |
>
> ## 1.5. Internet提供的传输服务
>
> > **1️⃣**TCP服务
> >
> > 1. 提供：连接管理，可靠性控制，流量控制，拥塞控制
> > 2. 不提供：实时性，最小吞吐保障，安全性
> > 3. TCP pro：安全套接字层(SSL)，是TCP在应用层上的强化
> >
> > **2️⃣**UDP服务：只提供不可靠数据传输
> >
> > **3️⃣**流行Internet APP所采用的应用层/传输层协议
> >
> > | 应用         | 应用层协议                          | 支撑的传输层协议      |
> > | ------------ | ----------------------------------- | --------------------- |
> > | email        | SMTP [RFC 2821]                     | TCP                   |
> > | 远程终端访问 | Telnet [RFC 854]                    | TCP                   |
> > | 网页         | HTTP [RFC 2616]                     | TCP                   |
> > | 文件传输     | FTP [RFC 959]                       | TCP                   |
> > | 流式多媒体   | HTTP (eg Youtube),   RTP [RFC 1889] | TCP or UDP(局域网内） |
> > | 网络电话     | SIP, RTP, proprietary               | 通常是UDP             |

# 2. Web和HTTP

> ## 2.1. Web&HTTP概述
>
> > ### 2.1.1. Web
> >
> > > **1️⃣**Web页面组成
> > >
> > > 1. 核心：基本HTML文件，包含主要内容结构+其他对象的引用
> > > 2. 其他对象：包括图像/Java小程序/音频等
> > >
> > > **2️⃣**每个对象都可以RUL寻址：以someschool.edu域名为例
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231216204321048.png" alt="image-20231216204321048" style="zoom: 50%;" /> 
> >
> > ### 2.1.2. HTTP(超文本传输协议)
> >
> > > **1️⃣**地位：是web在应用层的协议，用于通信
> > >
> > > **2️⃣**C-S模型：客户端浏览器(请求/接收/显示Web对象)，Web服务器(响应请求/发送对象)
> > >
> > > **3️⃣**HTTP的基础：TCP，过程如下
> > >
> > > 1. HTTP客户端：发起TCP连接→创建套字(端口80)→连接服务器
> > > 2. Web服务器：接收TCP连接请求
> > > 3. 交换数据，然后关闭TCP
> > >
> > > **4️⃣**性质：是一个无状态的协议，服务器不保存客户端以前的请求
>
> ## 2.2. 非连续/连续HTTP
>
> > ### 2.2.1. 非连续HTTP
> >
> > > **1️⃣**含义：建立一次TCP只传送一个文件，传一个文件耗时2RTT+文件发送时间
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231216211524856.png" alt="image-20231216211524856" style="zoom:50%;" /> 
> > >
> > > **2️⃣**示例：假设`www.xjtu.edu/dxxb/home.index`包含10张JPG+HTML文件，11个对象同在一服务器
> > >
> > > 过程为：
> > >
> > > 1. HTTP客户端：在端口80发起连接`www.xjtu.edu`的TCP连接
> > > 2. HTTP客户端：向服务器发出HTTP请求报文(包含路径名`/dxxb/home.index`)
> > > 3. HTTP服务器：收到请求，从磁盘找出对象`home.index`并封装为响应报文，通过套接字发出
> > > 4. HTTP服务器：其服务进程通知TCP断开TCP连接
> > > 5. HTTP客户端：完整收到报文后，断开TCP连接
> > >
> > > `home.index`是HTML文件(包含十张图片的索引)，根据索引再重复1-5来请求图片，共11次TCP连接
> > >
> > > **3️⃣**弊端：传输每个对象需要2RTT，浏览器总要打开并行TCP连接来获取对象
> >
> > ## 2.2.2. 持续的HTTP
> >
> > > **1️⃣**含义：建立一次TCP可以发送多个对象，初始对象需要2RTT/后续就只要1RTT了
> > >
> > > **2️⃣**实现方式
> > >
> > > 1. 服务器发送响应后==保持连接打开==，通过打开的连接传输后续HTTP消息
> > > 2. 客户端一遇引用的对象就发送请求
>
> ## 2.3. HTTP报文格式：开始行+首部行+实体主体
>
> > <img src="https://s2.loli.net/2023/12/16/y59xmF8IOaDnAGq.png" alt="image-20231216214237494" style="zoom:67%;" />  
> >
> > 分为HTTP请求/响应报文，区别在于开始行为请求行/响应状态行
>
> ## 2.4. 用户和服务器的交互：Cookie
>
> > **1️⃣**cookie是什么：存储在客户端本地的小文件，用于保存身份验证/用户偏好
> >
> > **2️⃣**cookie的四个组件：
> >
> > 1. 首部行cookie：在HTTP请求/响应报文的首部行中，都会有一行cookie
> > 2. 用户端的本地cookie：由浏览器管理，必要时发给服务器
> > 3. Web站点后端数据库的cookie：保存用户的身份信息/偏好/使用历史
> >
> > **3️⃣**示例：以使用Chrome访问https://pornhub.com/为例
> >
> > ==首次访问https://pornhub.com/网站==
> >
> > 1. https://pornhub.com/的Web站点：生成唯一识别码`<xxx>`，以此为索引项在后端数据库建立表项
> >
> > 2. https://pornhub.com/服务器：给Chrome响应一个HTTP报文(包含`Set-Cookie:<XXX>`首部)
> >
> > 3. Chrome：看到返回的`Set-Cookie:<XXX>`后，在特定cookie文件加一行
> >
> >    ```cookie
> >    <xvideo主机名> <识别码aaa>
> >    <missav主机名> <识别码bbb>
> >    ....新增以下....
> >    <pornhub主机名> <识别码xxx>
> >    ```
> >
> > ==继续访问https://pornhub.com/网站==
> >
> > 1. 每请求一个Web页面，浏览器就查询Cookie文件
> > 2. 抽取pornhub的识别码→将pornhub项加到HTTP请求报文的Cookie首部
> >
> > ==再次访问https://pornhub.com/网站==
> >
> > 1. Chrome：在请求报文中放入cookie首部行
> > 2. https://pornhub.com/服务器：会记住你喜欢看的猫娘
>
> ## 2.5. Web缓存&代理服务器
>
> > ### 2.5.1. Web缓存概述
> >
> > > **1️⃣**目的：减少客户端全球时间，节省流量
> > >
> > > **2️⃣**示例：假设Chrome请求xjtu.edu/temp.gif
> > >
> > > 1. 浏览器：建立xjtu.edu$\xleftrightarrow{TCP}$Web缓存器
> > > 2. Web缓存器：检查内部是否有temp.gif副本
> > >    - 有：将副本$\xrightarrow[返回给]{HTTP响应}$Chrome
> > >    - 没有：缓存器建立一个新的TCP连接，通过新连接获取该对象副本，再返回给Chrome
> > >
> > > **3️⃣**Web缓存类型：代理Cache，==客户端/服务端Cache==，分布式Cache
> > >
> > > <img src="https://s2.loli.net/2023/12/16/S6vw1T24pbkN8Rf.png" alt="image-20231216234811836" style="zoom:50%;" />  
> >
> > ### 2.5.2. 代理Cache
> >
> > > **1️⃣**目的：不涉及源服务器条件下，满足客户需求
> > >
> > > **2️⃣**工作机理
> > >
> > > 1. 用户设置浏览器：通过缓存访问Web
> > > 2. 浏览器：将所有HTTP请求发往代理缓存，缓存中有所需对象则直接访问缓存，没有的话再访问源服务器
> > >
> > > ⚠️访问代理获得服务的速度，远快于访问源服务器
> >
> > ### 2.5.3. 客户端Cache
> >
> > > **1️⃣**客户端Cache的形成：代理服务器将对象发浏览器时，浏览器会在本地缓存该对象+最后修改日期
> > >
> > > **2️⃣**何时使用本地Cache：再代理服务器中的对象被修改前，都是用本地缓存的对象
> > >
> > > **3️⃣**如何知道代理服务器的的对象是否被改：条件GET方法，条件GET报文满足
> > >
> > > 1. 请求报文使用GET请求报文
> > > 2. 请求报文包含If-Modified-Since首部
> >
> > ### 2.5.4. 分布式Cache
> >
> > > 缓存间互相合作，改缓存中无访问的对象→访问其邻居，邻居都没有→才访问源服务器
> >
> > ### 2.5.5. 服务器Cache
> >
> > > 多服务器集群，内容可相同/不同，通过其中的轻载服务器(缓存)响应HTTP请求，广泛采用

# 3. Email

> ## 3.1. FTP(File Transfer Protocol)
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231217011252900.png" alt="image-20231217011252900" style="zoom:50%;" /> 
> >
> > **1️⃣**概述：作用是向主机传文件，采用C-S模式，FTP的端口号是21(用于连接控制)
> >
> > **2️⃣**两种连接：控制连接(21, 用于传输控制命令)，数据连接(20, 传输实际的文件内容)
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231217012457842.png" alt="image-20231217012457842" style="zoom: 50%;" /> 
>
> ## 3.2. Email组成
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231217020112990.png" alt="image-20231217020112990" style="zoom:61%;" /> 
> >
> > ### 3.2.1. 用户代理
> >
> > > **1️⃣**比如Outlook/Gmail/Apple-mail
> > >
> > > **2️⃣**供用户读/写/发邮件，将邮件发往服务器的外出报文队列/从服务器中取邮件
> >
> > ### 3.2.2. 邮件服务器(核心)
> >
> > > **1️⃣**Email一般过程：发送方代理→发送方邮件服务器→接收方邮件服务器→分发给接收方代理
> > >
> > > **2️⃣**Email不成功时：报文还在邮件服务器的报文队列中，多次尝试，再不济就删除并通知发送方
> >
> > ### 3.2.3. SMTP(简单邮件传输协议，端口号25)
> >
> > > **1️⃣**功能：客户端$\xleftrightarrow[TCP]{输邮件消息}$服务器，发送服务器$\xleftrightarrow{直连}$接收服务器
> > >
> > > **2️⃣**特点：运行在邮件服务器上，邮件内容只能是ASCII字符
> > >
> > > **3️⃣**SMTP报文格式
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231217015701062.png" alt="image-20231217015701062" style="zoom:50%;" /> 
> > >
> > > **4️⃣**SMTP vs HTTP
> > >
> > > 1. 二者都是主机-主机传文件，都是用持续的连接
> > > 2. HTTP是拉协议(TCP连接由接收端发起)，SMTP是推协议(发送端发起)
> > > 3. HTTP一个对象就一个报文，SMTP所有对象塞一个报文里
> > >
> > > **5️⃣**非ASCII邮件的扩展：MIME(多用途互联网邮件扩展)
>
> ## 3.3. 邮件访问协议：服务器→代理
>
> > **1️⃣**POP3(端口110)：第三方邮局协议，内容为授权+下载，是无状态的
> >
> > **2️⃣**IMAP(端口143)：邮件访问协议，保持用户跨会话的状态(有状态的)
> >
> > **3️⃣**HTTP：如Gmail

# 4. DNS

> ## 4.1. 概述
>
> > **1️⃣**背景：主机除可用IP&域名标识，如我的域名xjtu.co.uk也是76.223.105.230，主机$\xleftrightarrow{多对多}$IP
> >
> > **2️⃣**DNS什么是：由分层DNS服务器实现的分布式数据库，也是供主机查询分布式数据库的应用层协议
> >
> > **3️⃣**<mark>DNS运行在UDP上，端口53</mark>
> >
> > **4️⃣**DNS提供什么服务？
> >
> > 1. 主机(别)名—IP的转换
> > 2. 邮件服务器的别名，如DNS会将发给dann_hiroaki@ieee.org的邮件指向IEEE的邮件服务器
> > 3. 负载分配：
> >    - 例如ieee.org运行在多个服务器上，对应多个IP，则DNS数据库会存储ieee.org的所有IP
> >    - 客户端请求ieee.org时，DNS按一定顺序返回其所有IP，客户端选择最前排的IP响应
>
> ## 4.2. 分布式分层数据库
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231217023051363.png" alt="image-20231217023051363" style="zoom:50%;" /> 
> >
> > **1️⃣**根域名服务器：管理所有顶级域名，不直接将域名转为IP，而是告诉本地域名服务器该去找哪个顶级域名服务器
> >
> > **2️⃣**顶级域名服务器
> >
> > **3️⃣**注册DNS服务器：不欠费就一直会记住你的域名，负责一个区
> >
> > **4️⃣**本地域名服务器：不在图中，一般和主机在同一个局域网
>
> ## 4.3. DNS域名解析
>
> > **1️⃣**查找过程：主机先==递归查询==本地域名服务器，没查到则再==以DNS客户==身份迭代查询其他域名服务器
> >
> > **2️⃣**两种查询方式：以在纽约大学查询Massachusetts大学为例
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231217024936506.png" alt="image-20231217024936506" style="zoom: 40%;" />  
> >
> > 1. 递归式(深度优先)：左边，本地域名服务器只向根域名服务器查询一次
> > 2. 迭代式(广度优先)：右边，根域名服务器收到本地域名服务器请求，返回IP/下一步要查哪个服务器
> >
> > **3️⃣**补充：
> >
> > 1. 由于底层及DNS服务器缓存的存在，跟服务器基本被绕开了
> > 2. 实际上经常两种查询方式一起使用
>
> ## 4.4. DNS记录和报文
>
> > **1️⃣**RR：即资源记录，存储在DNS服务器，格式为`<Name，Value，Type，TTL>`，具体含义见下
> >
> > 1. TTL：记录存在的生命周期
> >
> > 2. 其他：见下表，注意ieee.org的邮件其实使用的是Gmail，这点在MX里体现
> >
> >    | Type  | Name(实例)         | Value(实例)                       | 说明             |
> >    | ----- | ------------------ | --------------------------------- | ---------------- |
> >    | A     | 主机名(xjtu.co.uk) | IP(76.223.105.230)                | 主机名到IP的映射 |
> >    | NS    | 域名               | 可获得该域IP的DNS主机             | 用于DNS查询      |
> >    | CNAME | 主机名             | 规范化的主机名                    | 查找规范主机名   |
> >    | MX    | 邮送域(ieee.org)   | 邮件服务器的规范主机名(gmail.com) |                  |
> >
> > **2️⃣**DNS协议报文：注意前12字节是报头
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231217030706382.png" alt="image-20231217030706382" style="zoom: 67%;" />  

# 5. 搜索引擎

> **1️⃣**www可以视为图：页面是结点/URL是边，URL可以让一个页面跳转到另一个页面，好比两点用边相连
>
> **2️⃣**www中页面的索引
>
> 1. 关键字：URL
> 2. 数据结构：线性表(存储URL指针+页面指针)，堆(存储可变长的标题+URL)，HASH表(避免重复访问)
>
> **3️⃣**索引创建过程
>
> 1. 广度优先搜索：输入/散列/尝试放入URL，若URL已在表中则处理下个URL，不在的话就访问URL并加入表中
> 2. 对表中每个URL，提取页面/标题的关键词

# 6. Socket编程

> **1️⃣**服务器：要有一个Socket，通过它来收发段
>
> **2️⃣**客户端：要有一套接字(在本地由端口号识别)，客户端需要知道服务器的IP+Socket端口号







