# $\textbf{ER Modelling}$  

# $\textbf{1. Introduction}$ 

> ## $\textbf{1.1. Data→DBMS}$ 
>
> > **1️⃣**$\text{Data vs. Information:}$​ 
> >
> > |   $\textbf{Item}$    |                   定义                   |          描述           |        示例        |
> > | :------------------: | :--------------------------------------: | :---------------------: | :----------------: |
> > |    $\text{Data}$     | $\text{Known facts stored and recorded}$ |    $\text{Raw Data}$    |    $\text{123}$    |
> > | $\text{Information}$ |    $\text{Data presented in context}$    | $\text{Processed Data}$ | $\text{StuID=123}$ |
> >
> > **2️⃣**$\text{Metadata: }$ 
> >
> > 1. 含义：描述数据的数据，提供数据的背景和结构信息
> > 2. 示例：书籍的标题/作者/出版年份/$\text{ISBN}$​等信息
> >
> > **3️⃣**$\text{Database: }\textbf{Large integrated} \text{ and } \textbf{structured } \text{collection of data }$ 
> >
> > **4️⃣**$\text{DBMS (Database Management System)}$ 
> >
> > 1. 定义：$\text{Software designed to } \textbf{store/manage/facilitate access}\text{ to databases.}$ 
> > 2. 比如$\text{MySQL}$​​ 
>
> ## $\textbf{1.2. DB Development Process}$ 
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/97829699510.png" alt="97829699510" style="zoom: 52%;" /> 
> >
> > ### $\textbf{1.2.1. High Level Design}$
> >
> > > **1️⃣**$\text{Database Planning:}$ 比如企划银行的结构，有客户/账户/员工等以及对应关系
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/52230798001.png" alt="52230798001" style="zoom:33%;" /> 
> > >
> > > **2️⃣**$\text{System Definition:}$ 确定系统的边界与接口；比如抵押系统如何从客户系统获取必要信息
> > >
> > > **3️⃣**$\text{Requirements Definition/Analysis:}$​​ 确定系统需求(能实现什么)，比如银行系统能否汇率转换
> >
> > ### $\textbf{1.2.2. Core Design}$ 
> >
> > > **1️⃣**==$\text{Conceptual Design/ER Modelling}$== 
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240320014726037.png" alt="image-20240320014726037" style="zoom:56%;" /> 
> > >
> > > 1. 独立于物理实现的数据模型
> > > 2. 最常见的概念设计方法为$\text{ER Modelling}$
> > >    - 包含$\text{Entity(Employee)+Attributes(ssn/name/age)}$​​ 
> > >    - 常见的$\text{ER Diagram}$有$\text{Chen's}$还有$\text{Crow's Foot}$
> > >
> > > **2️⃣**==$\text{Logical Design/Relational Model}$==  
> > >
> > > ```sql
> > > Employee (ssn, name, age) -- Employee为关系，(ssn, name, age)为其三个属性
> > > ```
> > >
> > > 1. 独立于具体数据库的逻辑模型
> > >
> > > 2. 最常见的逻辑设计方法为$\text{Relational Model}$​
> > >
> > >    $\text{ER Modelling}\xrightarrow{\begin{cases}\text{Entity}\to{}\text{Reation(表)}\\\\\text{Attribute}\to\text{Attribute(列)}\end{cases}}\text{Relational Model}$
> > >
> > > **3️⃣**$\text{Physical Design:}$​​​​ 
> > >
> > > ```sql
> > > Employee (ssn CHAR(11), name VARCHAR(20), age INTEGER)
> > > ```
> > >
> > > 1. 实现具体数据库的物理模型
> > > 2. 其实就是$\text{Logical}\xrightarrow{\text{Choose data type}}\text{Physical}$​ 
> > >
> > > **4️⃣**$\text{Implementation \& Instance:}$ 
> > >
> > > 1. $\text{Implementation:}$ 通过$\text{MySQL Workbench}$创建表格
> > >
> > >    ```sql
> > >    CREATE TABLE Employee (
> > >       ssn CHAR(11),
> > >       name VARCHAR(20), 
> > >       age INTEGER, 
> > >       PRIMARY KEY (ssn)
> > >    );
> > >    ```
> > >
> > > 2. $\text{Instance:}$ 往实现好了的$\text{SQL}$​表格中填充数据
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240523012348666.png" alt="image-20240523012348666" style="zoom:23%;" />  
> >
> > ### $\textbf{1.2.3. Other Design}$ 
> >
> > > **1️⃣**$\text{Application Design:}$ 设计使用数据库的用户界面$\text{APP}$
> > >
> > > **2️⃣**测试和维护

# $\textbf{2. ER Modelling (Chen's)}$ 

> ## $\textbf{2.1. Basic Concepts}$  
>
> > **1️⃣**概述
> >
> > |     $\textbf{Concept}$     |           解释            |                      备注                      |
> > | :------------------------: | :-----------------------: | :--------------------------------------------: |
> > |    $\text{Entity(Set)}$    |  真实世界中的对象(集合)   |             单个实体由多个属性描述             |
> > |     $\text{Attribute}$     |    对于一个实体的描述     | 实体的属性中必有一个$\text{Key}$(区分每个个体) |
> > | $\text{Relationship(Set)}$ | 两个/多个实体的联结(集合) |  关系也可能有$\text{(Descriptive)Attribute}$   |
> >
> > **2️⃣**综合示例($\text{(Chen's Model)}\begin{cases}\text{Entity: Employee/Department}\\\\\text{Relation: Works in}\end{cases}$ 
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240521142334082.png" alt="image-20240521142334082" style="zoom: 50%;" /> 
> >
> > - $\text{Primary Key}$要用下划线标出
> >
> > **3️⃣**注意事项： 
> >
> > 1. 同一实体可出现在不同关系
> > 2. 同一实体可有不同角色(员工的上下级)
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240319013123774.png" alt="image-20240319013123774" style="zoom: 50%;" /> 
>
> ## $\textbf{2.2. Relation}$ 
>
> > ### $\textbf{2.2.1. Binary: Relation Constraints}$ 
> >
> > > **0️⃣**关系基数：$\text{1-1/1-M/M-M}$三种
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240319171748574.png" alt="image-20240319171748574" style="zoom:50%;" /> 
> > >
> > > **1️⃣**$\text{Key/Cardinalitiy Constraints:}$ 确定了数量的==上限$\text{1/N}$== 
> > >
> > > |   关系类型   |   $\textbf{Employee(Manager)}$   | 员工键约束 |     $\textbf{Department}$      | 部门键约束 |
> > > | :----------: | :------------------------------: | :--------: | :----------------------------: | :--------: |
> > > | $\text{M-M}$ |  $\text{N}$(一部门有==多==员工)  |     ❌      | $\text{N}$(一员工在==多==部门) |     ❌      |
> > > | $\text{1-M}$ | $\text{1}$(一部门只有==一==经理) |     ✔️      | $\text{N}$(一经理管==多==部门) |     ❌      |
> > > | $\text{1-1}$ | $\text{1}$(一部门只有==一==经理) |     ✔️      | $\text{1}$(一经理管==一==部门) |     ✔️      |
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240521204353371.png" alt="image-20240521204353371" style="zoom:38%;" /> 
> > >
> > > **2️⃣**$\text{Participation Constraints:}$ 确定了数量的==下限$\text{0/1}$== 
> > >
> > > 1. $\text{Total/Partial Participation:}$​​  一个实体集中所有实体必须/非必须参与到关系中
> > >
> > > 2. $\text{Chen's}$表示：$\text{Total participation is represented by bold line}$​
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240319185302286.png" alt="image-20240319185302286" style="zoom:50%;" /> 
> > >
> > > **3️⃣**两种限制的组合：确定了数量的==上下限== 
> > >
> > > |     $\textbf{Type}$     |         $\textbf{Participation}$ | $\textbf{Key Constraint}$ | $\textbf{E.g. Prof may teach\_lecture}$ |
> > > | :---------------------: | -------------------------------: | :-----------------------: | :-------------------------------------: |
> > > | $\text{Optional Many}$  | $\text{Partial}$(下限$\text{0}$) |     ❌(上限$\text{N}$)     |             $\text{0/1/N}$              |
> > > | $\text{Mandatory Many}$ |   $\text{Total}$(下限$\text{1}$) |     ❌(上限$\text{N}$)     |              $\text{1/N}$               |
> > > |  $\text{Optional One}$  | $\text{Partial}$(下限$\text{0}$) |     ✔️(上限$\text{1}$)     |              $\text{0/1}$               |
> > > | $\text{Mandatory One}$  |   $\text{Total}$(下限$\text{1}$) |     ✔️(上限$\text{1}$)     |               $\text{1}$                |
> > >
> > > - 注意$\text{Chen's}$模型中，靠近一方实体的线$\begin{cases}决定这一方实体的\text{Optional/Mandatory}\\\\决定另一方实体的\text{One/Many}(箭头指向\text{One})\end{cases}$ 
> >
> > ### $\textbf{2.2.2. Ternary Relationships}$
> >
> > > **1️⃣**含义：三个实体同时参与一个关系 
> > >
> > > **2️⃣**示例：
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240319194238726.png" alt="image-20240319194238726" style="zoom:50%;" /> 
> > >
> > > 1. 部门($\text{Depaertment}$)/供应商($\text{Supplier}$)之间，建立了一个有关组件($\text{Part}$​)的合同
> > > 2. 关系的属性包含了合同中组件的数量
>
> ## $\textbf{2.3. Entity: Weak Entity}$ 
>
> > **1️⃣**弱实体基本要素
> >
> > 1. 强弱实体
> >
> >    |      $\textbf{Entity}$       |           描述           |
> >    | :--------------------------: | :----------------------: |
> >    | $\text{Owner/Strong Entity}$ |  弱实体所赖以存在的实体  |
> >    |     $\text{Weak Entity}$     | 依赖于强实体而存在的实体 |
> >
> > 2. $\text{Identifying/Weak Relationship:}$​​ 连接强弱实体的关系，所有弱实体必定有一个弱关系
> >
> > **2️⃣**关于$\text{Weak Entity}$的$\text{Key}$ 
> >
> > |           $\textbf{Key}$           | 描述                                                         |
> > | :--------------------------------: | :----------------------------------------------------------- |
> > | $\text{Weak Entity}$的$\text{PK}$  | 又称为$\text{Partial Key}$，在$\text{Chen's}$中用虚下滑线表示 |
> > | $\text{Owner Entity}$的$\text{PK}$ | 塞进$\text{Weak Entity}$当$\text{PFK}$，识别弱实体要==自身$\text{PK+}$强实体$\text{PK(PFK)}$== |
> >
> > **3️⃣**如何辨认$\text{Weak Entity}$ 
> >
> > 1. 如果$\text{A}$不存在$\text{B}$也不能存在，则$\text{B}$是$\text{A}$的$\text{Weak Entity}$ 
> > 2. 如果需要识别出$\text{A}$，不仅要$\text{A}$的$\text{PK}$还需要$\text{B}$的$\text{PK}$，则$\text{B}$是$\text{A}$的$\text{Weak Entity}$
> > 3. $\text{Weak Entity}$和$\text{Owner Entity}$通常是$\text{1-M}$关系，且弱对强==一定是$\text{Mandatory One}$(粗箭头)== 
> >    - 弱实体必定有赖于强实体而存在($\text{Mandatory}$)
> >    - 弱实体也只能依赖唯一的强实体($\text{One}$)
> >
> > **4️⃣**$\text{Chen's ER Diagram:}$ 员工家属$\text{(Dependent)}$​是弱实体
> >
> > 1. 弱实体/弱关系边框**加粗** 
> > 2. $\text{Partial Key}$需要用==虚线==下划线标记
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240319192431916.png" alt="image-20240319192431916" style="zoom:50%;" /> 
>
> ## $\textbf{2.4. Attribute (Special Type)}$
>
> > ### $\textbf{2.4.1. Multi-Valued Attributes}$
> >
> > > **1️⃣**概念：一个属性拥有多个(但非无限)个同类型值，比如一个员工拥有多个电话
> > >
> > > **2️⃣**$\text{Chen's ER Diagram:}$​ 用镶嵌气泡表示
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240319195306061.png" alt="image-20240319195306061" style="zoom: 40%;" /> 
> >
> > ### $\textbf{2.4.2. Composite Attributes}$
> >
> > > **1️⃣**概念：拥有内部结构的属性，比如员工地址内还包含邮政编码/街道名/街道号
> > >
> > > **2️⃣**$\text{Chen's ER Diagram:}$ 气泡插到气泡上，
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240319200455024.png" alt="image-20240319200455024" style="zoom: 50%;" /> 
> >
> > ### $\textbf{2.4.3. Derived Attributes}$
> >
> > > **1️⃣**含义：从别的属性派生出来的属性
> > >
> > > **2️⃣**特点：并不会在物理层面存储该属性，所以在物理设计阶段就会消失
> > >
> > > **3️⃣**$\text{Chen's ER Diagram:}$​ 用虚框表示
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240325215010330.png" alt="image-20240325215010330" style="zoom:65%;" /> 
> > >
> > > - $\text{Years Employeed}$可以由以下规则派生
> > >
> > >   ```sql
> > >   DATE.now - Contact.start
> > >   ```
>
> ## $\textbf{2.5. Conceptual Design: Entity or Attribute?}$​ 
>
> > **1️⃣**通常情况下，选择设计成$\text{Entity}$比设计成$\text{Attribute}$灵活性更高，也是首选
> >
> > **2️⃣**示例：用户($\text{UserID}$订阅$\text{Plan}$及其$\text{Type}$ 
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240522011321373.png" alt="image-20240522011321373" style="zoom:30%;" /> 
> >
> > 1. 当$\text{Type}$为$\text{Attribute:}$ 如果要新增$\text{TypeX}$，则需强制增加一个使用$\text{TypeX}$的$\text{UserID}$，明显不行
> >
> >    | $\textbf{Plan}$表 | $\textbf{UserID}$ | $\textbf{Type}$ |
> >    | :---------------: | :---------------: | :-------------: |
> >    |    $\text{\\}$    |    $\text{1}$     | $\text{TypeA}$  |
> >    |    $\text{\\}$    |    $\text{2}$     | $\text{TypeB}$  |
> >    |    $\text{\\}$    |    $\text{3}$     | $\text{TypeC}$  |
> >    |    $\text{\\}$    |    $\text{?}$     | $\text{TypeX}$  |
> >
> > 2. 当$\text{Type}$为$\text{Entity:}$ 可以灵活新增$\text{TypeX}$，不鸟$\text{UserID}$如何独立存在
> >
> >    | $\textbf{Plan}$表 | $\textbf{UserID}$ | $\textbf{Plan}$表 | $\textbf{TypeID}$ |
> >    | :---------------: | :---------------: | :---------------: | :---------------: |
> >    |    $\text{\\}$    |    $\text{1}$     |    $\text{\\}$    |    $\text{A}$     |
> >    |    $\text{\\}$    |    $\text{2}$     |    $\text{\\}$    |    $\text{B}$     |
> >    |    $\text{\\}$    |    $\text{3}$     |    $\text{\\}$    |    $\text{C}$     |
> >    |    $\text{\\}$    |    $\text{\\}$    |    $\text{\\}$    |    $\text{X}$     |

# $\textbf{3. ER Modelling (Crow's Foot)}$  

> ## $\textbf{3.1. Basic Component}$ 
>
> > **1️⃣**$\text{Entity}$ ​
> >
> > |  $\textbf{Concept}$  |                  $\textbf{Chen's Notation}$                  |               $\textbf{Crow's Foot Notation}$                |
> > | :------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> > |   $\text{Entity}$    | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518163501986.png" alt="image-20240518163501986" style="zoom:33%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518163515870.png" alt="image-20240518163515870" style="zoom:33%;" /> |
> > | $\text{Weak Entity}$ | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518163508676.png" alt="image-20240518163508676" style="zoom:33%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518163516766.png" alt="image-20240518163516766" style="zoom:33%;" /> |
> >
> > **2️⃣**$\text{Attributes}$​ 
> >
> > 1. 各种类型的属性
> >
> >    |  $\textbf{Concept}$   |                  $\textbf{Chen's Notation}$                  |               $\textbf{Crow's Foot Notation}$                |
> >    | :-------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> >    |  $\text{Attribute}$   | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518164028012.png" alt="image-20240518164028012" style="zoom:43%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518164202668.png" alt="image-20240518164202668" style="zoom:48%;" /> |
> >    | $\text{Mutivalue A.}$ | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518164035655.png" alt="image-20240518164035655" style="zoom:43%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518164213482.png" alt="image-20240518164213482" style="zoom:48%;" /> |
> >    | $\text{Composote A.}$ | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518164057870.png" alt="image-20240518164057870" style="zoom:43%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518164232122.png" alt="image-20240518164232122" style="zoom:48%;" /> |
> >    |  $\text{Derived A.}$  | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518164107217.png" alt="image-20240518164107217" style="zoom:43%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518164239905.png" alt="image-20240518164239905" style="zoom:48%;" /> |
> >
> > 2. $\text{Key(Covered Later in Relational Model)}$​ 
> >
> >    |      $\textbf{Concept}$      |                  $\textbf{Chen's Notation}$                  |               $\textbf{Crow's Foot Notation}$                |
> >    | :--------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> >    |       $\text{Key A.}$        | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518164627582.png" alt="image-20240518164627582" style="zoom:45%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518164645733.png" alt="image-20240518164645733" style="zoom:46%;" /> |
> >    | $\text{Weak/Partial Key A.}$ | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518164636943.png" alt="image-20240518164636943" style="zoom:45%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518164655854.png" alt="image-20240518164655854" style="zoom:46%;" /> |
> >
> > 3. 示例($\text{In Workbench}$​​​)
> >
> >    | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240522133429885.png" alt="image-20240522133429885" style="zoom:42%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/94345676140.png" alt="94345676140" style="zoom:2.66666666666666666666%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240522133437015.png" alt="image-20240522133437015" style="zoom:42%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240522133450052.png" alt="image-20240522133450052" style="zoom:42%;" /> |
> >    | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> >    |                     $\text{Primary Key}$                     |                     $\text{Foreign Key}$                     |                $\text{Mandatory}$/`NOT NULL`                 |                   $\text{Optional}$/`NULL`                   |
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/83875134128.png" alt="83875134128" style="zoom:30%;" /> 
> >
> > **3️⃣**$\text{Relationship}$​ 
> >
> > 1. 强弱关系
> >
> >    |               $\textbf{Concept}$               |                      $\textbf{Chen's}$                       |                    $\textbf{Crow's Foot}$                    |
> >    | :--------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> >    |             $\text{Relationship}$              | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518165011981.png" alt="image-20240518165011981" style="zoom:50%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518165040391.png" alt="image-20240518165040391" style="zoom:50%;" /> |
> >    | $\text{Relationship/Identifying Relationship}$ | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518165021699.png" alt="image-20240518165021699" style="zoom:50%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518165050138.png" alt="image-20240518165050138" style="zoom: 50%;" /> |
> >
> > 2. 示例   
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/94996180436.png" alt="94996180436" style="zoom:43%;" /> 
>
> ## $\textbf{3.2. Relationship Constraints}$ 
>
> > **1️⃣**$\text{Constraints}$​ 
> >
> > |     $\textbf{Type}$     |              $\textbf{Chen's Vs. Crow's Foot}$               |                 $\textbf{Crow's Foot E.g.}$                  |
> > | :---------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> > | $\text{Optional Many}$  | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518171505689.png" alt="image-20240518171505689" style="zoom: 35%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240522134319756.png" alt="image-20240522134319756" style="zoom: 20%;" /> |
> > | $\text{Mandatory Many}$ | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518171514714.png" alt="image-20240518171514714" style="zoom:35%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240522134524459.png" alt="image-20240522134524459" style="zoom:20%;" /> |
> > |  $\text{Optional One}$  | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518171524051.png" alt="image-20240518171524051" style="zoom:35%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240522134423007.png" alt="image-20240522134423007" style="zoom:20%;" /> |
> > | $\text{Mandatory One}$  | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518171531204.png" alt="image-20240518171531204" style="zoom:35%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240522134439743.png" alt="image-20240522134439743" style="zoom:20%;" /> |
> >
> > **2️⃣**$\text{Relationship (Cardinalitiy Only)}$​​ 
> >
> > | $\textbf{Type}$ |                      $\textbf{Chen's}$                       |                    $\textbf{Crow's Foot}$                    |
> > | :-------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> > |  $\text{M-M}$   | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518171742431.png" alt="image-20240518171742431" style="zoom: 40%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518171825584.png" alt="image-20240518171825584" style="zoom:40%;" /> |
> > |  $\text{1-M}$   | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518171751329.png" alt="image-20240518171751329" style="zoom:40%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518171844711.png" alt="image-20240518171844711" style="zoom:40%;" /> |
> > |  $\text{1-1}$   | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518171758048.png" alt="image-20240518171758048" style="zoom:40%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518171854779.png" alt="image-20240518171854779" style="zoom:40%;" /> |
>
> ## ==$\textbf{3.3. Chen's}\xleftrightarrow{转换}\text{Crow's Foot}$==
>
> > **1️⃣**转换的核心规则：$\text{Crow's Foot}$一侧的鸦足标记$\xleftrightarrow{对应}\text{Chen's}$另一侧的线/箭头
> >
> > **2️⃣**示例
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240523000452409.png" alt="image-20240523000452409" style="zoom:45%;" /> 

# $\textbf{4. Relational Model}$ 

> ## $\textbf{4.1. Basic Conception}$ 
>
> > **1️⃣**$\text{Relational Data Model}$ 
> >
> > 1. $\text{Data Model:}$ 将$\text{Real-World}$实体转化为计算机$\text{Readable}$的结构，比如$\text{Relational Model}$ 
> >
> > 2. $\text{Relational Model}$​​​的基本要素: 
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240319210614082.png" alt="image-20240319210614082" style="zoom:50%;" /> 
> >
> >    - $\text{Schema: }$关系(表格)的名称$\text{+}$表格每列的属性名/属性类型
> >    - $\text{Instance: }$表格每行的$\text{Tuple}$  
> >
> > 3. $\text{Data→Relational Model}$转换
> >
> >    $\text{Data}\xrightarrow[\text{Represent Data With Table}]{\begin{cases}\text{Tuple/Record}\to{}\text{Row}\\\\\text{Attribute}\to{}\text{Column}\end{cases}}\text{Relational Model}$  
> >
> > **2️⃣**$\text{Relational Databases: }$利用$\text{Relation}$存储数据的数据库 
> >
> > 1. $\text{Records}\xrightarrow[组成]{\text{一系列记录}}\text{Relations}\xrightarrow[组成]{\text{一系列关系}}\text{Relational Databases}$ 
> > 2. $\text{Relations}\xrightarrow{\text{Populated With Actual Data}}\text{Instance/Table}$​ 
> >
> > **3️⃣**$\text{Cardinality/Degree}$ 
> >
> > 1. 含义
> >
> >    |                      |                   含义                    |            备注            |
> >    | :------------------: | :---------------------------------------: | :------------------------: |
> >    | $\text{Cardinality}$ |   表中$\text{Rows/Records/Tuples}$数量    | 表中记录可以无序，但要唯一 |
> >    |   $\text{Degree}$    | 表中$\text{Column/Attributes/Fields}$数量 |        $\text{N/A}$        |
> >
> > 2. 示例：$\text{Cardinality=3/Degree=5/All Rows Distinct}$ 
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518181216754.png" alt="image-20240518181216754" style="zoom:60%;" />     
>
> ## $\textbf{4.2. Key}$ 
>
> > **1️⃣**$\text{Super Key:}$ 
> >
> > 1. 含义：$\text{A set of attributes that uniquely identifies each tuple}$(一个/多个属性都行)
> >
> > 2. 特点：
> >
> >    - $\text{Super Key Value}\xleftrightarrow{一一对应}\text{Tuple}$ 
> >    - 每个关系必定有一组属性组成超键(因为关系中每行必唯一)
> >    - 假设属性集$\text{A}$是$\text{Super Key}$，则$\text{A+}$任意其他$\text{Attributes}$也是$\text{Super Key}$ 
> >
> > 3. 示例：$\text{Super Key}$​为`names+login+age`
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518184312707.png" alt="image-20240518184312707" style="zoom: 23%;" />    
> >
> > **2️⃣**$\text{Primary Key(PK)}$​   
> >
> > 1. $\text{Key in a Relationship:}$ 
> >
> >    - 最小化的$\text{Super Ksy}$，用最少的信息区分每一个$\text{Tuple}$​ 
> >    - 即使是最小化，但也不一定只有一个属性
> >
> > 2. 两种键类型
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240615164114655.png" alt="image-20240615164114655" style="zoom: 20%;" />   
> >
> >    | $\textbf{Key Type}$ |            含义            |         备注         |  示例   |
> >    | :-----------------: | :------------------------: | :------------------: | :-----: |
> >    |  $\text{Primary}$   | 唯一标识每个记录的属性(集) | 每个关系只有一个主键 |  `sid`  |
> >    | $\text{Candidate}$  | 所有可能作为主键的属性(集) |  基本和主键混为一谈  | `login` |
> >
> > 3. 特殊键类型
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518190205425.png" alt="image-20240518190205425" style="zoom:34%;" /> 
> >
> >    | $\textbf{Key Type}$ |        含义        |            备注            |     示例     |
> >    | :-----------------: | :----------------: | :------------------------: | :----------: |
> >    | $\text{Composite}$  | 多个属性组成的主键 |    无单一属性主键时适用    |  `sid+name`  |
> >    | $\text{Surrogate}$  | 自定义的(代理)主键 | 无任何属性当主键，就自定义 | $\text{N/A}$ |
> >
> >    - 代理键在$\text{MySQL}$中的值，默认为$\text{1/2/3.....}$即$\text{Auto-Incremented}$  
> >
> > **3️⃣**$\text{Foreign Key(FK)}$ 
> >
> > 1. $\text{Foreign Key(FK)}$​
> >
> >    - 含义
> >
> >      |   $\textbf{Type}$    |                概念                 | 示例                      |
> >      | :------------------: | :---------------------------------: | :------------------------ |
> >      | $\text{Primary key}$ | 确保表中每个记录都唯一，能唯一定位  | `course.cid, Student.sid` |
> >      | $\text{Foreign Key}$ | 指向另一个表格中$\text{Data Entry}$ | `course.sid`              |
> >
> >    - 示例
> >
> >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240320032739617.png" alt="image-20240320032739617" style="zoom: 60%;" /> 
> >
> > 2. $\text{Primary Foreign Key(PFK)}$
> >
> >    - 含义：既是自的$\text{PK}$又是别的关系的$\text{FK}$，常见于$\text{Associative Entity}$ / $\text{Weak Entity}$ 
> >
> >    - 示例：中间联结表的两个键
> >
> >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240522022647965.png" alt="image-20240522022647965" style="zoom: 39.9%;" /> 
>
> ## $\textbf{4.3. Integrity}$(完整性)
>
> > **1️⃣**$\text{Integrity Constraint:}$​​ 建立表格所要满足一下所有条件
> >
> > | $\textbf{Integrity Constraint}$ | 描述                                                         |
> > | :-----------------------------: | :----------------------------------------------------------- |
> > |          $\text{Key}$           | 关系的$\text{Primary Key}$必须唯一                           |
> > | $\text{Referential Integrity}$  | 所有$\text{Foreign Key}$(引用)必须有效                       |
> > |    $\text{Domain Integrity}$    | 作$\text{Data Type}$的区分，比如只给整数属性上输入整数数据   |
> > |    $\text{Entity Integrity}$    | 属性值可以$\text{Optional}$($\text{NULL}$)，或者必须有值($\text{NOT NULL}$) |
> >
> > **2️⃣**示例
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240320032739617.png" alt="image-20240320032739617" style="zoom: 60%;" /> 
> >
> > |      操作对象      |                  操作行为                   |                  结果                   |
> > | :----------------: | :-----------------------------------------: | :-------------------------------------: |
> > | $\text{Enroll}$表  | 插入记录(其`sid`不存在于$\text{Student}$表) |        违反完整性约束$\to{}$拒绝        |
> > | $\text{Student}$表 |                删除一个记录                 | 同时也删除对应$\text{Enroll}$表中的数据 |

# $\textbf{5. ER→Relational Model}$ 

> ## $\textbf{5.1. Entity Conversion}$ 
>
> > ### $\textbf{5.1.1. Single Entity}$​ 
> >
> > > **1️⃣**转换原理
> > >
> > > |         $\textbf{Entity}$的$\textbf{Attributes}$类型         |               操作               |
> > > | :----------------------------------------------------------: | :------------------------------: |
> > > |                           普通情况                           |             正常转换             |
> > > |                $\text{Composite Attributes}$                 | 把复合属性展开($\text{Flatten}$) |
> > > | $\text{Multi-Valued Attributes (Small/Fixed Number of Values)}$ |               展开               |
> > > |  $\text{Multi-Valued Attributes (Large Number of Values)}$   |         创建新表(弱实体)         |
> > > |                 $\text{Derived Attributes}$                  |             直接忽略             |
> > >
> > > **2️⃣**$\text{Chen's}$的转换示例
> > >
> > > 1. 普通情况：
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518212734566.png" alt="image-20240518212734566" style="zoom:50%;" /> 
> > >
> > >    ```sql
> > >    Employee(SSN(Key),Name,Age)
> > >    ```
> > >
> > > 2. $\text{Composite Attributes:}$ 去除原有复合属性，展开内部的属性​
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518213915791.png" alt="image-20240518213915791" style="zoom: 44%;" />  
> > >
> > >    ```sql
> > >    Employee(SSN(Key),Name,Age,Postcode,Street_name,Street_num)
> > >    ```
> > >
> > > 3. $\text{Multi-Valued Attribute:}$ 去除原有多值属性，展开内部的属性
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518213705102.png" alt="image-20240518213705102" style="zoom:42%;" />   
> > >
> > >    ```sql
> > >    Employee(SSN(Key),Name,Age,Num_1,Num_2)
> > >    ```
> > >
> > > **3️⃣**$\text{Crow's Foot}$​示例
> > >
> > > 1. $\text{Composite Attributes:}$ 去掉复合属性本身，展开复合属性内部的属性​ 
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/2370265737.png" alt="2370265737" style="zoom:29%;" /> $\Longrightarrow$​<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/65116322242.png" alt="65116322242" style="zoom:30%;" />  
> > >
> > > 2. $\text{Multi-Valued Attributes (Small/Fixed Number of Values)}\to{}$​​直接展开​
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/57949231549.png" alt="57949231549" style="zoom: 15%;" />$\Longrightarrow$ <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518220637689.png" alt="image-20240518220637689" style="zoom:20%;" />  
> > >
> > > 3. $\text{Multi-Valued Attributes (Large Number of Values)}$​    
> > >
> > >    - 建立$\text{1-N}$关系：$\text{1-Employee}\xrightarrow{\text{Plays}}\text{N-Roles}$，建立$\text{Role}$弱实体
> > >
> > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/57949231549.png" alt="57949231549" style="zoom: 13%;" /> $\Longrightarrow$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240327042206853.png" alt="image-20240327042206853" style="zoom:46%;" /> 
> > >
> > >    - 建立$\text{N-N}$关系：$\text{N-Employee}\xrightarrow{\text{Plays}}\text{N-Roles}$，建立$\text{Role}$弱实体$+$一个联结表
> > >
> > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/57949231549.png" alt="57949231549" style="zoom: 13%;" /> $\Longrightarrow$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240523153539118.png" alt="image-20240523153539118" style="zoom:23%;" />   
> >
> > ### $\textbf{5.1.2. Weak Entity}$
> >
> > > **1️⃣**规则：其实也就是说辨认一个$\text{Weak Entity}$需要——自身$\text{PK+Strong Entity}$的$\text{PK}$
> > >
> > > |  弱实体的键  | 规则                                 | 备注                     |
> > > | :----------: | ------------------------------------ | ------------------------ |
> > > | 弱实体的主键 | 强实体的主键$+$弱实体自身一/多个属性 | $\text{N/A}$             |
> > > | 弱实体的外键 | 强实体的主键                         | $\text{Aka PFK}$(外主键) |
> > >
> > > **2️⃣**$\text{Chen's}$示例：箭头指向一侧的$\text{PK}$过来，到箭头的另一端当==$\text{PFK}$==
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240320054233153.png" alt="image-20240320054233153" style="zoom:50%;" /> 
> > >
> > > ```sql
> > > CREATE TABLE Dependent (
> > > dname CHAR(20) NOT NULL,
> > > age INTEGER NULL,
> > > cost DECIMAL(7,2) NOT NULL,
> > > ssn CHAR(11) NOT NULL,
> > > PRIMARY KEY (dname, ssn), -- weak+owner key as composite primary key
> > > FOREIGN KEY (ssn) REFERENCES Employees   -- refer to owner entity
> > > ON DELETE CASCADE -- Owner deleted, all weak entities deleted(确保完整性)
> > > );
> > > ```
> > >
> > > - 注意`ON DELETE CASCADE`，意思是主实体删除时，弱实体也随之删除
> > >
> > > **3️⃣**$\text{Crow's Foot}$​示例
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240331220340189.png" alt="image-20240331220340189" style="zoom: 45%;" />  
>
> ## $\textbf{5.2. Relationship Conversion}$
>
> > ### $\textbf{5.2.1. Unary Relationship}$
> >
> > > |       $\textbf{Typle}$       |                  处理方法                  |
> > > | :--------------------------: | :----------------------------------------: |
> > > |         $\text{1-1}$         | $\text{Put a Foreign key in the relation}$ |
> > > | $\text{1-N(Key Constrains)}$ | $\text{Put a Foreign key in the relation}$ |
> > > |         $\text{N-N}$         |  $\text{Generate an Associative Entity}$   |
> > >
> > > **1️⃣**$\text{1-1}$关系示例：婚姻关系，一个人的主键变成另一个人的外键，即增加一个配偶$\text{ID}$外键
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240327070444793.png" alt="image-20240327070444793" style="zoom:60%;" /> $\Longrightarrow$​<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240327070603097.png" alt="image-20240327070603097" style="zoom:60%;" /> 
> > >
> > > **2️⃣**$\text{1-N}$​关系示例：员工(包含部分管理者)关系，管理者的主键成为员工的外键
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240331203754056.png" alt="image-20240331203754056" style="zoom: 70%;" /> $\Longrightarrow$​<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240331203901858.png" alt="image-20240331203901858" style="zoom: 70%;" /> 
> > >
> > > **3️⃣**$\text{N-N}$关系示例：$\text{Item}$(包括各种$\text{Componment}$成分)关系，建立$\text{Componment}$​弱实体
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240523011423047.png" alt="image-20240523011423047" style="zoom: 29%;" /> $\Longrightarrow$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240523011503080.png" alt="image-20240523011503080" style="zoom:30%;" />  
> > >
> > > 1. 弱实体的两个外键成为复合主键
> > > 2. 弱实体要包含关系的描述属性($\text{Descriptive Attributes}$​)
> >
> > ### $\textbf{5.2.2. Binary Relationship}$ 
> >
> > > **1️⃣**$\text{N-N}$关系：
> > >
> > > 1. 规则：
> > >
> > >    - 建立$\text{Associative Entity}\xrightarrow{包含}\text{Descriptive Attributes+}$两边的$\text{PK}$(作为自身$\text{PFK}$)
> > >
> > >    - $\text{Associative Entity}$是原有两实体的$\text{Weak Entity}$ 
> > >    - $\text{Crow's Foot}$转换时，关系种类交叉处理==(详见示例<font color="red">**红虚线**</font>)== 
> > >
> > > 2. $\text{Chen's}$示例：创建新关系`Works_In(ssn, did, since)`
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240320042219262.png" alt="image-20240320042219262" style="zoom: 60%;" />  
> > >
> > >    |       $\textbf{Relations}$       | $\textbf{PK}$ | $\textbf{FK}$ |
> > >    | :------------------------------: | :-----------: | :-----------: |
> > >    |    `Employee(ssn, name, age)`    |     `ssn`     |     `N/A`     |
> > >    | `Department(did, dname, budget)` |     `did`     |     `N/A`     |
> > >    |   `Works_In(ssn, did, since)`    |   `ssn,did`   |   `ssn,did`   |
> > >
> > > 3. $\text{Crow's Foot}$示例：$\text{Conceptual}\to{}\text{Physical}$​​​ 
> > >
> > >    - 注意联结实体实质上是一个弱实体(实线)，联结实体的行数是联结两端的行数乘积
> > >
> > >    - 原有的$\text{Crow's Foot}$标志需要交叉放置
> > >
> > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240523010523138.png" alt="image-20240523010523138" style="zoom: 38%;" /> 
> > >
> > > 4. $\text{Implemetation}$ 
> > >
> > >    ```sql
> > >    CREATE TABLE Customer (
> > >      CustomerID INT PRIMARY KEY, -- 此处记得空两格，记得逗号; 可以在此处就定义PK
> > >      CustFirstName VARCHAR(45)
> > >    );
> > >    CREATE TABLE Address (
> > >      AddressID INT,
> > >      StreetNumber VARCHAR(45),
> > >      PRIMARY KEY (AddressID)  -- 也可以在最末尾定义PK
> > >    );
> > >    CREATE TABLE Address_has_Customer (
> > >      AddressID INT,
> > >      CustomerID INT,
> > >      AddressDateFrom VARCHAR(45),
> > >      AddressDateTo VARCHAR(45),
> > >      PRIMARY KEY (AddressID, CustomerID),
> > >      FOREIGN KEY (AddressID) REFERENCES Address(AddressID),  -- 指明FK的起始
> > >      FOREIGN KEY (CustomerID) REFERENCES Customer(CustomerID)
> > >    );
> > >    ```
> > >
> > > **2️⃣**$\text{1-N}$​关系($\text{Key Constraints}$) 
> > >
> > > |         类型         |                             规则                             |
> > > | :------------------: | :----------------------------------------------------------: |
> > > | $\text{Crow's Foot}$ |     $\text{PK from ONE side}\to{}\text{FK at MANY side}$     |
> > > |   $\text{Chen's}$    | 箭头指向一侧的$\text{PK}$过来，到箭头的另一端当==$\text{FK}$==，同时描述属性也过来 |
> > >
> > > 1. $\text{Crow's Foot}$示例：一个客户有多个账户
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240518235315127.png" alt="image-20240518235315127" style="zoom:40%;" /> 
> > >
> > > 2. $\text{Chen's}$​示例
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240320051340819.png" alt="image-20240320051340819" style="zoom: 67%;" /> 
> > >
> > >    ```sql
> > >    Employee (ssn, name, age)                   -- PK ssn
> > >    Department (did, dname, budget, ssn, since) -- PK did + FK ssn
> > >    ```
> > >
> > > **3️⃣**$\text{1-1}$关系
> > >
> > > 1. 规则
> > >
> > >    | 关系的$\textbf{Participation}$限制 |              $\textbf{Move the Key to the\_\_}$              |
> > >    | :--------------------------------: | :----------------------------------------------------------: |
> > >    |     $\text{Optional-Optional}$     |        随意将一方的$\text{PK}$移到另一方作$\text{FK}$        |
> > >    |    $\text{Mandatory-Mandatory}$    |        随意将一方的$\text{PK}$移到另一方作$\text{FK}$        |
> > >    |    $\text{Mandatory-Optional}$     | 将$\text{Mandatory}$的$\text{PK}$移动到$\text{Optional}$作$\text{FK}$ |
> > >
> > > 2. 示例
> > >
> > >    - 概念设计
> > >
> > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240523012825726.png" alt="image-20240523012825726" style="zoom: 47%;" /> 
> > >
> > >    - 逻辑设计
> > >
> > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240327063020177.png" alt="image-20240327063020177" style="zoom: 40%;" /> 
> >
> > ### $\textbf{5.2.3. Ternary Relationship}$
> >
> >
> > >    **1️⃣**规则：
> > >
> > >    1. 更具关系创建新实体，关系描述属性成为新实体的属性
> > >    2. 关系中三个实体的$\text{PK}\to{}$新实体中的$\text{PFK}$
> > >
> > >    **2️⃣**$\text{Chen's}$示例
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240320045513507.png" alt="image-20240320045513507" style="zoom:40%;" /> 
> > >
> > >    ```sql
> > >    Contracts   (supplier_id,part_id,department_id) -- three of each are PFKs
> > >    Suppliers   (id,name)                           -- id(PK)
> > >    Parts       (id,name)                           -- id(PK)
> > >    Departments (id,name)                           -- id(PK)
> > >    ```
> > >
> > >    **3️⃣**$\text{Crow's Foot}$​示例
> > >
> > >    1. 概念设计
> > >
> > >       <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240331214447731.png" alt="image-20240331214447731" style="zoom: 67%;" /> 
> > >
> > >
> > >    2. 逻辑设计
> > >
> > >       <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240331214523119.png" alt="image-20240331214523119" style="zoom: 40%;" /> 
>
> ## $\textbf{5.3. Participation Constraint}$
>
> > **1️⃣**转为逻辑设计时，要指定属性$\text{NULL/NOT NULL}$，以确定是$\text{Optional/Mandatory}$​
> >
> > **2️⃣**示例：$\text{Eevery department MUST have a manager}$
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240320054202193.png" alt="image-20240320054202193" style="zoom: 77%;" /> 
> >
> > ```sql
> > CREATE TABLE Department (
> >    did INTEGER NOT NULL,
> >    dname CHAR(20) NOT NULL,
> >    budget FLOAT NULL,
> >    ssn CHAR(11) NOT NULL,   -- ssn 表示每一个Department必须有一个Employee
> >    since DATE NULL,
> >    PRIMARY KEY (did),
> >    FOREIGN KEY (ssn) REFERENCES Employee
> >    ON DELETE NO ACTION
> > );
> > ```
> >
> > :three:$\text{PK}$一定是$\text{NOT NULL}$的

# $\textbf{SQL (Structured Query Language)}$ 

# $\textbf{1. Relational Algebra}$ ​ 

> ## $\textbf{1.0. Overview}$ 
>
> > **1️⃣**关系操作：包括五个==$\text{Basic Operation}$== 
> >
> > |       $\textbf{Operations}$       |   符号    |       原关系        |                       操作(得到新关系)                       |
> > | :-------------------------------: | :-------: | :-----------------: | :----------------------------------------------------------: |
> > |      ==$\text{Projection}$==      |   $\pi$   |       原关系        | $\large\xrightarrow[2. 去除重复行]{1. 保留想要的列(竖直过滤)}$ |
> > |      ==$\text{Selection}$==       | $\sigma$  |       原关系        |        $\large\xrightarrow[]{保留想要的行(水平过滤)}$        |
> > |        ==$\text{Union}$==         |  $\cup$   | 原关系$1+$原关系$2$ | $\large\xrightarrow[2. 去除重复项]{1. 合并两表所有\text{Tuple}}$ |
> > |       $\text{Intersection}$       |  $\cap$   | 原关系$1+$原关系$2$ | $\large\xrightarrow[2. 去除重复项]{1. 提取两个表都出现的\text{Tuple}}$ |
> > | ==$\text{Set-difference/Minus}$== |    $-$    | 原关系$1+$原关系$2$ | $\large\xrightarrow[]{移除关系2所含\text{Tuple}(在关系1中)}$ |
> > |    ==$\text{Cross-product}$==     |    $×$    | 原关系$1+$原关系$2$ | $\large\xrightarrow[]{\text{Tuple}无条件互相组合(笛卡尔积)}$ |
> > |           $\text{Join}$           | $\bowtie$ | 原关系$1+$原关系$2$ | $\large\xrightarrow[2. 按条件\text{Selection}]{1.\text{Tuple}无条件互相组合}$ |
> >
> > **2️⃣**$\text{Condition Expressions:}$ 
> >
> > |              类型               |         符号          |
> > | :-----------------------------: | :-------------------: |
> > | $\text{Arithmetic Expressions}$ | `>, <, >=, <=, =, !=` |
> > |     $\text{AND/OR Clauses}$     |   `AND → Λ, OR → V`   |
> >
> > 1. 示例：$\sigma_{\text{rating}\geq{}9\text{ }\land{}\text{ age<50}}(\text{S}_2)$​​ 
> >
> >    ```sql
> >    SELECT * FROM S2 
> >    WHERE rating >= 9 AND age < 50;
> >    ```
> >
> > 2. 注意事项
> >
> >    - $\text{SQL}$与$\text{C++}$等不同，等于就是$\text{=/}$不是$\text{==}$ 
> >    - 不等于的两种表达：`!=`或者`<>`  
>
> ## $\textbf{1.1. Projection}(\pi{})\textbf{ \& Selection}(\sigma{})$  
>
> > **1️⃣**$\text{Projection}(\pi{})$ 
> >
> > 1. 操作：仅保留$\text{Projection List}$中的列$\to{}$去除重复的行
> >
> > 2. 特点：$\text{Projection is a costly operation, DB won't operate it by default.}$ 
> >
> > 3. 示例：注意$\text{SQL}$中可控制投影后去不去出重复项，但$\text{Relational Algebra}$里==默认去除==重复项
> >
> >    ```sql
> >    SELECT * FROM Student; -- 选中所有列(左表)
> >    SELECT age FROM Student; -- 选中年龄这一列，但是SQL操作中默认不去除重复项(中表)
> >    SELECT DISTINCT age FROM Student; -- 选中年龄这一列，删除重复项(右表)
> >    ```
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711891750690.jpg" alt="1711891750690" style="zoom:67%;" /> $\Large\xrightarrow{\pi_{\text{age}}(\text{S})}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401023305604.png" alt="image-20240401023305604" style="zoom:60%;" /> $\large\large \xrightarrow{\text{Removed duplicates}}$​<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401023545442.png" alt="image-20240401023545442" style="zoom: 57%;" /> 
> >
> > **2️⃣**$\text{Selection}(\sigma{})$ 
> >
> > 1. 操作：仅保留$\text{Selection}$条件的行，并且不会有任何重复行
> >
> > 2. 示例：在$\text{SQL}$​中体现在`WHERE`上
> >
> >    ```sql
> >    SELECT * FROM Student WHERE Student.rating >= 9;
> >    ```
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401025827011.png" alt="image-20240401025827011" style="zoom:40%;" /> $\Large\xrightarrow{\sigma_{\text{rating}\geq{}9}(\text{S})}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/39f6ffcb25a774de649e5fdbcbbf97c6.png" alt="39f6ffcb25a774de649e5fdbcbbf97c6" style="zoom:50%;" />     
> >
> > **3️⃣**$\text{Projection}(\pi{})\text{ \& Selection}(\sigma{})$​
> >
> > 1. 注意事项
> >    - 一般先$\text{Selection}$后$\text{Projection}$的$(\pi{_{\text{A}}}(\sigma{_{\text{B}}}))$结构，这是因为$\text{Selection}$不会改变表格结构
> >    - 
> >
> > ```sql
> > SELECT sname, rating FROM Student WHERE Student.rating >= 9;
> > ```
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401031241564.png" alt="image-20240401031241564" style="zoom:50%;" /> $\Large\xrightarrow{\pi_{\text{sname, rating}}(\sigma_{\text{rating}\geq{}9}(\text{S}))}$​​<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401031348650.png" alt="image-20240401031348650" style="zoom:50%;" />  
> >
> > 1. 
> > 2. 如果一定要用先$\text{Projection}$再$\text{Selection}$的$(\sigma{_{\text{A}}}(\pi{_{\text{B}}}))$结构，要确保$\text{A}\subseteq\text{B}$ 
>
> ## $\textbf{1.2. Union/Set-Difference/Intersection}$ 
>
> > ==对应的$\text{SQL}$操作叫做$\text{Set Operations}$== 
> >
> > **0️⃣**条件($\text{Union-Compatible}$​)：
> >
> > 1. 两表$\text{Column}$数一致，相应的列的$\text{Data Type}$​相同 
> >    - <span style="color:red;">两表属性名不一定要相同，$\text{SQL}$默认取上表的名</span>
> > 2. 该条件适用$\text{Union/Set Difference/Intersection}$三者
> >
> > **1️⃣**$\text{Union:}$ 
> >
> > 1. 操作：将两表==上下拼接==在一起，并在$\text{Relational Algebra}$​中默认消除重复项
> >
> > 2. 特性：对称性($\text{Symmetric}$)
> >
> > 3. 示例：在$\text{SQL}$代码中体现在`UNION`上(但不默认消除重复项)
> >
> >    ```sql
> >    SELECT sid, sname, rating, age FROM S1 -- 此操作去除重复行
> >    UNION
> >    SELECT sid, sname, rating, age FROM S2;
> >    SELECT sid, sname, rating, age FROM S1 -- 此操作保留重复行
> >    UNION ALL
> >    SELECT sid, sname, rating, age FROM S2;
> >    ```
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902909279.jpg" alt="1711902909279" style="zoom: 40%;" /> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902927676.jpg" alt="1711902927676" style="zoom: 40%;" /> $\large\xrightarrow[\text{or }\\ \text{S}_2\cup{\text{S}_1}]{\text{S}_1\cup{\text{S}_2}}$​​<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711903012794.jpg" alt="1711903012794" style="zoom: 40%;" />  
> >
> > **2️⃣**$\text{Set-Difference:}$ 
> >
> > 1. 操作：从一个关系中，删除另一个关系中存在的$\text{Tuple}$​ 
> >
> > 2. 特性：无对称性($\text{Asymmetric}$)
> >
> > 3. 示例：$\text{SQL}$中并==没有直接的求差集子句==，可以通过子查询变相实现
> >
> >    ```sql
> >    SELECT sid, sname, rating, age
> >    FROM S1
> >    WHERE (sid, sname, rating, age) NOT IN (
> >        SELECT sid, sname, rating, age
> >        FROM S2
> >    );
> >    ```
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902909279.jpg" alt="1711902909279" style="zoom: 40%;" /> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902927676.jpg" alt="1711902927676" style="zoom: 40%;" /> $\large\xrightarrow{\text{S}_1-{\text{S}_2}}$​ <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711903146343.jpg" style="zoom:40%;" />  
> >
> > **3️⃣**$\text{Intersection: Compound Operator}$   
> >
> > 1. 操作：找出两个关系中共存的$\text{Tuples}$，本质上是混合运算$\text{R}\cap{}\text{S}\equiv\text{R}-(\text{R}-\text{S})$ 
> >
> > 2. 示例：注意操作有对称性；同样也需要用$\text{SQL}$子查询变相实现
> >
> >    ```sql
> >    SELECT sid, sname, rating, age
> >    FROM S1
> >    WHERE (sid, sname, rating, age) IN (
> >        SELECT sid, sname, rating, age
> >        FROM S2
> >    );
> >    ```
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902909279.jpg" alt="1711902909279" style="zoom: 40%;" /> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902927676.jpg" alt="1711902927676" style="zoom: 40%;" /> $\large\xrightarrow[\text{or }\\ \text{S}_2\cap{\text{S}_1}]{\text{S}_1\cap{\text{S}_2}}$​<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908164999.jpg" alt="1711908164999" style="zoom:40%;" />  
>
> ## $\textbf{1.3. Cross product \& Joins}$ 
>
> > ==$\text{SQL Inter Table Operations}$== 
> >
> > ### $\textbf{1.3.1. Cross Product}(×)$ 
> >
> > > **1️⃣**操作：
> > >
> > > 1. 用一个表的每行，依次去扫描另一个表的每一行，输出组合
> > >
> > > 2. 结果会保留所有的列(即使重名了，也不要紧)
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902909279.jpg" alt="1711902909279" style="zoom: 40%;" /> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908857220.jpg" alt="1711908857220" style="zoom:35%;" /> $\large\xrightarrow{\text{R}×{\text{S}}}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908813683.jpg" alt="1711908813683" style="zoom:40%;" />   
> > >
> > > **2️⃣**重命名$\rho{}$：
> > >
> > > 1. 合并后的属性名称可能一样，由此需要重命名
> > >
> > > 2. 比如$\rho{(\text{C}(1\to{\text{sid1}},5\to{\text{sid2}}),\text{R}×\text{S}})$ 
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908813683.jpg" alt="1711908813683" style="zoom:40%;" /> $\longrightarrow{}$​​<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240519203220727.png" alt="image-20240519203220727" style="zoom:27%;" /> 
> > >
> > >    - $1\to{\text{sid1}}$的意思是：第一列改成$\text{sid1}$ 
> > >
> > > **3️⃣**$\text{SQL}$代码
> > >
> > > ```sql
> > > SELECT * FROM R, S;	-- Cross product between R, S
> > > ```
> >
> > ### $\textbf{1.3.2. Inner Join}(\bowtie): \textbf{Conditional Cross-Product}$ 
> >
> > >  **1️⃣**$\text{Inner Join(AKA Condition Join):}$  $\text{R}\bowtie{_{\text{Condition}}}\text{S} = \sigma_{\text{Condition}}(\text{R×S})$ 
> > >
> > >  1. $\text{R}\bowtie_{\text{(S}\text{.sid<R}\text{.sid)}}\text{S}$中，先计算$\text{R}×\text{S}$  
> > >
> > >     <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902909279.jpg" alt="1711902909279" style="zoom: 35%;" /> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908857220.jpg" alt="1711908857220" style="zoom:35%;" /> $\large\xrightarrow{\text{R}×{\text{S}}}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908813683.jpg" alt="1711908813683" style="zoom:43%;" />   
> > >
> > >  2. 再筛选满足${\text{(R}\text{.sid<S}\text{.sid)}}\text{}$的行
> > >
> > >     <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908813683.jpg" alt="1711908813683" style="zoom:42%;" /> $\longrightarrow{}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711911148407.jpg" alt="1711911148407" style="zoom:35%;" /> 
> > >
> > >  3. $\text{SQL: }$⚠️⚠️⚠️当两表中有$\text{Column}$名撞了，应该在$\text{Column}$名前加上表名
> > >
> > >     ```sql
> > >     SELECT * FROM R INNER JOIN S ON R.sid < S.sid;
> > >     ```
> > >
> > >  **2️⃣**$\text{Natural Join(AKA Join):}$ 一种隐式的$\text{Inner Join}$​  
> > >
> > >  <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401231354398.png" alt="image-20240401231354398" style="zoom:50%;" /> 
> > >
> > >  1. 原理/计算步骤
> > >
> > >     - 先计算$\text{R}×\text{S}$，找到两组(一组一或多个)名字相同的$\text{Column}$(此处为$\text{sid}$)
> > >
> > >       <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711902909279.jpg" alt="1711902909279" style="zoom: 38%;" /> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908857220.jpg" alt="1711908857220" style="zoom:35%;" /> $\large\xrightarrow{\text{R}×{\text{S}}}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711908813683.jpg" alt="1711908813683" style="zoom:42%;" />   
> > >
> > >     - 筛选两同名列值相同的行，然后只保留其中一列。即为$\text{R}\bowtie{}\text{S}\equiv\text{R}\bowtie{_{\text{R.sid=S.sid}}}\text{S}$​ 
> > >
> > >       <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401054601363.png" alt="image-20240401054601363" style="zoom:46%;" /> $\large\xrightarrow{\text{R}\bowtie{\text{S}}}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1711909823605.jpg" alt="1711909823605" style="zoom: 38%;" /> 
> > >
> > >  2. 注意事项：多个$\text{Column}$相同匹配时，`NATURAL JOIN`要多列相等
> > >
> > >     <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240616094428222.png" alt="image-20240616094428222" style="zoom: 25%;" /> 
> > >
> > >     即为$\text{R}\bowtie{}\text{S}\equiv\text{R}\bowtie{_{\text{R.sid=S.sid }\land{}\text{ R.bid=S.bid}}}\text{S}$ 
> > >
> > >  3. $\text{SQL: }$⚠️⚠️⚠️没有$\text{Column}$相同匹配时，`NATURAL JOIN`语句会被执行为$\text{Cross Product}$ 
> > >
> > >     ```sql
> > >     SELECT * FROM R NATURAL JOIN S
> > >     ```
> > >
> > >  **3️⃣**$\text{Equi Join:}$ 一种$\text{Inner Join}$的特殊情况，比如$\text{R}\bowtie_{\text{(S}_1\text{.sid=R}_2\text{.sid)}}\text{S}$​(条件是等式) 
> > >
> > >  <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240401231354398.png" alt="image-20240401231354398" style="zoom:50%;" /> 
> > >
> > >  ```sql
> > >  SELECT * FROM R INNER JOIN S ON R.sid = S.sid;
> > >  ```
> >
> > ### $\textbf{1.3.3. Outer Join}: \textbf{Include Every Record}$ 
> >
> > > **1️⃣**概述
> > >
> > > |   $\textbf{Outer Join}$   | 操作                                                      |
> > > | :-----------------------: | :-------------------------------------------------------- |
> > > | $\text{Left Outer Join}$  | 保留左表中所有记录，右表中不匹配的用$\text{NULL}$代替     |
> > > | $\text{Right Outer Join}$ | 保留右表中所有记录，左表中不匹配的用$\text{NULL}$代替     |
> > > | $\text{Full Outer Join}$  | 保留左右两表中所有记录，两表中不匹配的用$\text{NULL}$代替 |
> > >
> > > **2️⃣**示意图：$\text{Left/Right/Full}$
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240519224425895.png" alt="image-20240519224425895" style="zoom:53%;" /> 
> > >
> > > **3️⃣**示例 
> > >
> > > | ==客户表==  | $\textbf{CID}$ | 属性$\textbf{1}$ | 属性$\textbf{2}$ | ==账户表==  | $\textbf{CID}$ | $\textbf{AID}$ | 属性$\textbf{3}$ |
> > > | :---------: | :------------: | :--------------: | :--------------: | :---------: | :------------: | :------------: | :--------------: |
> > > | $\text{\\}$ |   $\text{1}$   |   $\text{X1}$    |   $\text{Y1}$    | $\text{\\}$ |   $\text{1}$   |   $\text{1}$   |   $\text{Z1}$    |
> > > | $\text{\\}$ |   $\text{2}$   |   $\text{X2}$    |   $\text{Y2}$    | $\text{\\}$ |   $\text{1}$   |   $\text{2}$   |   $\text{Z2}$    |
> > > | $\text{\\}$ |   $\text{3}$   |   $\text{X3}$    |   $\text{Y3}$    | $\text{\\}$ |   $\text{2}$   |   $\text{3}$   |   $\text{Z3}$    |
> > > | $\text{\\}$ |  $\text{\\}$   |   $\text{\\}$    |   $\text{\\}$    | $\text{\\}$ |   $\text{4}$   |   $\text{4}$   |   $\text{Z4}$    |
> > >
> > > 1. $\text{Left Outer Join:}$ `Customer.CustomerID = 3`时有表无匹配，所以代之以$\text{NULL}$​​ 
> > >
> > >    ```sql
> > >     SELECT * FROM Customer LEFT OUTER JOIN Account
> > >    ON Customer.CustomerID = Account.CustomerID; -- 左外联，保留左表所有CustomerID
> > >    ```
> > >
> > >    | $\textbf{CID}$ | 属性$\textbf{1}$ | 属性$\textbf{2}$ | $\textbf{AID}$ | 属性$\textbf{3}$ |
> > >    | :------------: | :--------------: | :--------------: | :------------: | :--------------: |
> > >    |   $\text{1}$   |   $\text{X1}$    |   $\text{Y1}$    |   $\text{1}$   |   $\text{Z1}$    |
> > >    |   $\text{1}$   |   $\text{X1}$    |   $\text{Y1}$    |   $\text{2}$   |   $\text{Z2}$    |
> > >    |   $\text{2}$   |   $\text{X2}$    |   $\text{Y2}$    |   $\text{3}$   |   $\text{Z3}$    |
> > >    |   $\text{3}$   |   $\text{X3}$    |   $\text{Y3}$    | $\text{NULL}$  |  $\text{NULL}$   |
> > >
> > > 2. $\text{Right Outer Join:}$  `Account.CustomerID = 4`时有表无匹配，所以代之以$\text{NULL}$ 
> > >
> > >    ```sql
> > >     SELECT * FROM Customer RIGHT OUTER JOIN Account
> > >    ON Customer.CustomerID = Account.CustomerID; -- 右外联，保留右表所有CustomerID
> > >    ```
> > >
> > >    | $\textbf{CID}$ | 属性$\textbf{1}$ | 属性$\textbf{2}$ | $\textbf{AID}$ | 属性$\textbf{3}$ |
> > >    | :------------: | :--------------: | :--------------: | :------------: | :--------------: |
> > >    |   $\text{1}$   |   $\text{X1}$    |   $\text{Y1}$    |   $\text{1}$   |   $\text{Z1}$    |
> > >    |   $\text{1}$   |   $\text{X1}$    |   $\text{Y1}$    |   $\text{2}$   |   $\text{Z2}$    |
> > >    |   $\text{2}$   |   $\text{X2}$    |   $\text{Y2}$    |   $\text{3}$   |   $\text{Z3}$    |
> > >    |   $\text{4}$   |  $\text{NULL}$   |  $\text{NULL}$   |   $\text{4}$   |   $\text{Z4}$    |
> > >
> > > 3. $\text{Full Outer Join:}$ 也可以认为是$\text{Right Outer Join结果}\cup\text{Leftt Outer Join结果}$ 
> > >
> > >    ```sql
> > >     SELECT * FROM Customer FULL OUTER JOIN Account
> > >    ON Customer.CustomerID = Account.CustomerID; -- 全外联，保留两表所有CustomerID
> > >    ```
> > >
> > >    | $\textbf{CID}$ | 属性$\textbf{1}$ | 属性$\textbf{2}$ | $\textbf{AID}$ | 属性$\textbf{3}$ |
> > >    | :------------: | :--------------: | :--------------: | :------------: | :--------------: |
> > >    |   $\text{1}$   |   $\text{X1}$    |   $\text{Y1}$    |   $\text{1}$   |   $\text{Z1}$    |
> > >    |   $\text{1}$   |   $\text{X1}$    |   $\text{Y1}$    |   $\text{2}$   |   $\text{Z2}$    |
> > >    |   $\text{2}$   |   $\text{X2}$    |   $\text{Y2}$    |   $\text{3}$   |   $\text{Z3}$    |
> > >    |   $\text{3}$   |   $\text{X3}$    |   $\text{Y3}$    | $\text{NULL}$  |  $\text{NULL}$   |
> > >    |   $\text{4}$   |  $\text{NULL}$   |  $\text{NULL}$   |   $\text{4}$   |   $\text{Z4}$    |
> >
> > ### $\textbf{1.3.4. }$复合$\textbf{Join}$ 
> >
> > > **1️⃣**示例的$\text{ABC}$表格
> > >
> > > | $\small\textbf{A}$ | $\small\textbf{AID}$ | $\small\textbf{AName}$ | $\small\textbf{B}$ | $\small\textbf{BID}$ | $\small\textbf{AID}$ | $\small\textbf{BName}$ | $\small\textbf{C}$ | $\small\textbf{CID}$ | $\small\textbf{CType}$ | $\small\textbf{BName}$ |
> > > | :----------------: | :------------------: | :--------------------: | :----------------: | :------------------: | :------------------: | :--------------------: | :----------------: | :------------------: | :--------------------: | :--------------------: |
> > > |    $\text{\\}$     |      $\text{1}$      |        `AName1`        |    $\text{\\}$     |     $\text{101}$     |      $\text{1}$      |        `BName1`        |    $\text{\\}$     |    $\text{1001}$     |        `CType1`        |        `BName2`        |
> > > |    $\text{\\}$     |      $\text{2}$      |        `AName2`        |    $\text{\\}$     |     $\text{102}$     |      $\text{1}$      |        `BName2`        |    $\text{\\}$     |    $\text{1002}$     |        `CType2`        |        `BName3`        |
> > > |    $\text{\\}$     |     $\text{\\}$      |      $\text{\\}$       |    $\text{\\}$     |     $\text{201}$     |      $\text{2}$      |        `BName3`        |    $\text{\\}$     |     $\text{\\}$      |      $\text{\\}$       |      $\text{\\}$       |
> > >
> > > **2️⃣**$\text{Inner Join}$ 
> > >
> > > ```sql
> > > A INNER JOIN B ON A.AID = B.AID
> > > ```
> > >
> > > | $\textbf{A.AID}$ | $\textbf{A.AName}$ | $\textbf{B.ID}$ | $\textbf{B.AID}$ | $\textbf{B.BName}$ |
> > > | :--------------: | :----------------: | :-------------: | :--------------: | :----------------: |
> > > |    $\text{1}$    |      `AName1`      |  $\text{101}$   |    $\text{1}$    |      `BName1`      |
> > > |    $\text{1}$    |      `AName1`      |  $\text{102}$   |    $\text{1}$    |      `BName2`      |
> > > |    $\text{2}$    |      `AName2`      |  $\text{201}$   |    $\text{2}$    |      `BName3`      |
> > >
> > > **2️⃣**复合$\text{Inner Join:}$ 拿上面那个$\text{Join}$的结果再去$\text{Join}$​ 
> > >
> > > ```sql
> > > A INNER JOIN B ON A.AID = B.AID INNER JOIN C ON B.BName = C.BName
> > > ```
> > >
> > > | $\small\textbf{A.AID}$ | $\small\textbf{A.AName}$ | $\small\textbf{B.ID}$ | $\small\textbf{B.AID}$ | $\small\textbf{B.BName}$ | $\small\textbf{C.CID}$ | $\small\textbf{C.CType}$ | $\small\textbf{C.BName}$ |
> > > | :--------------------: | :----------------------: | :-------------------: | :--------------------: | :----------------------: | :--------------------: | :----------------------: | :----------------------: |
> > > |       $\text{1}$       |         `AName1`         |     $\text{101}$      |       $\text{1}$       |         `BName2`         |     $\text{1001}$      |         `CType1`         |         `BName2`         |
> > > |       $\text{2}$       |         `AName2`         |     $\text{201}$      |       $\text{2}$       |         `BName3`         |     $\text{1002}$      |         `CType2`         |         `BName3`         |

# $\textbf{2. SQL Overview}$ 

> ## $\textbf{2.1. CRUD Commends}$ 
>
> > $\text{Create/Read/Update/Delete Commands}$ 
> >
> > | $\textbf{Command Type}$ |         功能          | $\textbf{Description}$                       |
> > | :---------------------: | :-------------------: | -------------------------------------------- |
> > |      $\text{DDL}$       |  $\text{Definition}$  | 定义并建立数据库                             |
> > |      $\text{DML}$       | $\text{Manipulation}$ | 维护并使用(查询)数据库，获取数据的价值与信息 |
> > |      $\text{DCL}$       |   $\text{Control}$    | 控制用户对数据的访问权                       |
> > |     $\text{Other}$      |     $\text{N/A}$      | 管理数据库                                   |
> >
> > ### $\textbf{2.1.1. DDL Commands: Set up DB}$​  
> >
> > > **1️⃣**创建表格操作`CREAT`，==其实也就是$\text{Implementation}$操作== 
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240520005817353.png" alt="image-20240520005817353" style="zoom:48%;" /> 
> > >
> > > ```sql
> > > -- 创建Customer表
> > > CREATE TABLE Customer (
> > >    CustomerID INT PRIMARY KEY,
> > >    CustFirstName VARCHAR(45)
> > > );
> > > -- 创建Account表
> > > CREATE TABLE Account (
> > >    -- 若表中现有最后一行ID是1001，插入的新ID自动变成1002
> > >    AccountID INT AUTO_INCREMENT PRIMARY KEY, 
> > >    -- 枚举数据类型，只允许账户号码为三者之一
> > >    AccountNumber ENUM('Num1', 'Num2', 'Num3');
> > >    Customer_CustomerID INT,
> > >    FOREIGN KEY (Customer_CustomerID) REFERENCES Customer(CustomerID)
> > > );
> > > ```
> > >
> > > 1. 关于$\text{Key}$
> > >    - 要用`PRIMARY KEY`指定哪个变量时主键
> > >    - 要用`FOREIGN KEY REFERENCES`指定$\text{Foreign Key}$引用的哪个变量，==否则会$\text{Syntax Error}$==
> > > 2. 补充事项
> > >    - `AUTO_INCREMENT`: 用来标记主键字段，插入一个记录后被标记字段自动$\text{+1}$​ 
> > >    - `ENUM`: 枚举数据类型类型，只允许属性为预设值
> > >
> > > **2️⃣**修改表格系列操作
> > >
> > > |                    操作                    | 关键字                                        |
> > > | :----------------------------------------: | :-------------------------------------------- |
> > > |       增加表格的$\text{Attributes}$        | `ALTER TABLE <表名> ADD <属性名> <属性类型> ` |
> > > |       减少表格的$\text{Attributes}$        | `ALTER TABLE <表名> DROP <属性名>`            |
> > > |                 表格重命名                 | `RENAME TABLE  <旧表名> TO <新表名>`          |
> > > | 快速清空表格记录($\text{Can't Roll Back}$) | `TRUNCATE TABLE <表名> `                      |
> > > |  慢速清空表格记录($\text{Can Roll Back}$)  | `DELETE * FROM <表名>`                        |
> > > |           彻底删除(杀死)一个表格           | `DROP * FROM <表名>`                          |
> > >
> > > ```sql
> > > -- 添加属性: 客户表中添加CustLastName属性
> > > ALTER TABLE Customer ADD CustLastName VARCHAR(45); 
> > > -- 减少属性: 账户表中删除AccountNumber属性
> > > ALTER TABLE Account DROP AccountNumber;   
> > > -- 重命名: 将Customer表重命名为NewCustomers
> > > RENAME TABLE Customer TO NewCustomers 
> > > -- 快速清空表记录: 清空所有客户的数据，不回退
> > > TRUNCATE TABLE Customer
> > > -- 慢速清空表记录: 清空所有客户的数据，可回退
> > > DELETE * FROM  Customer
> > > -- 彻底删除表格: 把客户表的数据/客户表都根除
> > > DROP TABLE Customer
> > > ```
> > >
> > > **3️⃣**查看表格操作: `VIEW` 视图，只是一种虚拟表(不存储在内存中)
> > >
> > > ```sql
> > > -- 创建虚拟表格CustomerAccountView视图
> > > CREATE VIEW CustomerAccountView AS
> > > SELECT Customer.CustomerID, Account.AccountNumber
> > > FROM Customer JOIN Account 
> > > ON Customer.CustomerID = Account.Customer_CustomerID;
> > > 
> > > -- 通过视图来查询数据，就像查询普通表格一样，简化了查询
> > > SELECT * FROM CustomerAccountView;
> > > ```
> >
> > ### $\textbf{2.1.2. DCL Commands:}$ 用户与权限
> >
> > > **1️⃣**创建/删除用户: `CREATE USER/DROP USER`
> > >
> > > ```sql
> > > -- 创建用户，初始密码为123
> > > CREATE USER 'john'@'localhost' IDENTIFIED BY '123';
> > > -- 删除john用户
> > > DROP USER 'john'@'localhost';
> > > ```
> > >
> > > **2️⃣**分配/撤销用户权限: `GRANT / REVOKE`
> > >
> > > ```sql
> > > -- 授予john在mydatabase数据库Table1表的SELECT和INSERT权限
> > > GRANT SELECT,INSERT ON mydatabase.Table1 TO 'john'@'localhost';
> > > -- 撤销john在mydatabase数据库Table1表的INSERT权限
> > > REVOKE INSERT ON mydatabase.Table1 FROM 'john'@'localhost';
> > > ```
> > >
> > > **3️⃣**设置密码: `SET PASSWORD`
> > >
> > > ```sql
> > > -- 设置新密码为0123
> > > SET PASSWORD FOR 'john'@'localhost' = PASSWORD('0123');
> > > ```
> >
> >
> > ### $\textbf{2.1.3. Other: Database Administration}$ 
> >
> > > **1️⃣**意外删除的恢复: `BACKUP TABLE/RESTORE TABLE`(二者其实并非标准$\text{SQL}$​命令)
> > >
> > > **2️⃣**展示表格模式($\text{Scheme}$): `DESCRIBE <表名>` 
> > >
> > > ```sql
> > > CREATE TABLE Customer (
> > >    CustomerID INT AUTO_INCREMENT PRIMARY KEY,
> > >    CustFirstName VARCHAR(45),
> > >    DateOfBirth DATE
> > > );
> > > -- 查看Customer表的结构，结果如下表
> > > DESCRIBE Customer
> > > ```
> > >
> > > |    $\textbf{Field}$    |   $\textbf{Type}$    | $\textbf{Null}$ | $\textbf{Key}$ | $\textbf{Default}$ |     $\textbf{Extra}$     |
> > > | :--------------------: | :------------------: | :-------------: | :------------: | :----------------: | :----------------------: |
> > > |  $\text{CustomerID}$   |     $\text{INT}$     |   $\text{NO}$   |  $\text{PRI}$  |   $\text{NULL}$    | $\text{auto\_increment}$ |
> > > | $\text{CustFirstName}$ | $\text{VARCHAR(45)}$ |  $\text{YES}$   |                |   $\text{NULL}$    |                          |
> > > |  $\text{DateOfBirth}$  |    $\text{DATE}$     |  $\text{YES}$   |                |   $\text{NULL}$    |                          |
> > >
> > > **3️⃣**`USE <db_name>`: 挑选进入哪个数据库来操作
>
> ## $\textbf{2.2. SQL}$ 语法特点(大小写问题)
>
> > **1️⃣**$\text{SQL}$​的属性名大小/关键词写不敏感($\text{Case Inseneitive}$)，但一般大写。如下两段查询含义相同
> >
> > ```sql
> > SELECT * FROM Furniture WHERE 
> > (Type = 'Chair' AND Colour = 'Black') OR (Type = 'Lamp' AND Colour = 'Black');
> > select * from furniture where 
> > (type = 'Chair' and colour = 'Black') or (type = 'Lamp' and colour = 'Black');
> > ```
> >
> > **3️⃣**$\text{SQL}$的表名区分大小写

# $\textbf{3. SQL Core: DML Commands}$  

> ## $\textbf{3.1. }$变更表中内容
>
> > ### $\textbf{3.1.1. Insert Data:}$ `Insert Into` 
> >
> > > **0️⃣**示例表格
> > >
> > > | $\textbf{CustID}$ | $\textbf{FirstName}$ | $\textbf{MiddleName}$ | $\textbf{LastName}$ | $\textbf{BusinessName}$ | $\textbf{CustType}$ |
> > > | :---------------: | :------------------: | :-------------------: | :-----------------: | :---------------------: | :-----------------: |
> > > |    $\text{1}$     |    $\text{Peter}$    |     $\text{NULL}$     |   $\text{Smith}$    |      $\text{NULL}$      |  $\text{Personal}$  |
> > > |    $\text{2}$     |    $\text{James}$    |     $\text{NULL}$     |   $\text{Jones}$    |       $\text{JJ}$       |  $\text{Company}$   |
> > > |    $\text{3}$     |    $\text{NULL}$     |     $\text{NULL}$     |   $\text{Smythe}$   |      $\text{NULL}$      |  $\text{Company}$   |
> > >
> > > **1️⃣**显式插入：指名要给哪几个属性插入数据
> > >
> > > ```sql
> > > -- 一次性可以插入一条数据
> > > INSERT INTO Customer (FirstName, LastName, CustType) VALUES 
> > > ("Peter", "Smith", 'Personal');
> > > 
> > > -- 也可以多条
> > > INSERT INTO Customer (FirstName, LastName, CustType) VALUES 
> > > ("Peter" , "Smith" , 'Personal'),
> > > ("Jamnes", "Jones" , 'Company' ),
> > > (""      , "Smythe", 'Company' );
> > > ```
> > >
> > > **2️⃣**隐式插入：省略具体的属性，将提供的值按顺序依次插入属性
> > >
> > > ```sql
> > > -- 插入第一条数据，DEFAULT子句会让CustID从0开始自动+1(此处+1后CustID=1)
> > > INSERT INTO Customer VALUES 
> > > (DEFAULT, "Peter", "", "Smith", "", 'Personal');
> > > 
> > > -- 一次性插入多条数据
> > > INSERT INTO Customer VALUES  
> > > (DEFAULT, "Peter", ""  , "Smith" , ""  , 'Personal');
> > > (DEFAULT, "James", NULL, "Jones" , "JJ", 'Company' );
> > > (DEFAULT, ""     , NULL, "Smythe", ""  , 'Company' );
> > > ```
> > >
> > > **3️⃣**从其他表格插入数据
> > >
> > > ```sql
> > > -- 将所有Customer中的记录，全部插入NewCustomer中
> > > INSERT INTO NewCustomer SELECT * FROM Customer;
> > > ```
> > >
> > > 👽`REPLACE`和`INSERT`功能几乎一致，区别仅仅在于，当待插入记录的$\text{PK}\xleftrightarrow[冲突]{相同}$已存在记录的$\text{PK}$ 
> > >
> > > 1. `INSERT`：操作费费，插入失败
> > > 2. `REPLACE`：操作合法，并且待插入记录覆盖冲突的已存在记录
> >
> > ### $\textbf{3.1.2. Changes Existing Data:}$ `UPDATESET` 结构
> >
> > > **1️⃣**`UPDATE` 示例
> > >
> > > ```sql
> > > -- Block1: 所有薪水小于100000的涨薪5%
> > > UPDATE Salaried SET AnnualSalary = AnnualSalary * 1.05
> > > WHERE AnnualSalary <= 100000;
> > > -- Block2: 所有薪水大于100000的涨薪10%
> > > UPDATE Salaried SET AnnualSalary = AnnualSalary * 1.10
> > > WHERE AnnualSalary > 100000;
> > > ```
> > >
> > > 1. 子句执行的顺序会影响结果
> > > 2. 没有`WHERE`子句时，更新会应用到表格的每一行
> > >
> > > **2️⃣**`CASE` $\text{Command}$​优化示例
> > >
> > > ```sql
> > > UPDATE Salaried SET AnnualSalary = 
> > > CASE 
> > >     WHEN AnnualSalary <= 100000 THEN AnnualSalary * 1.05
> > >     ELSE AnnualSalary * 1.10    
> > > END;
> > > ```
> >
> > ### $\textbf{3.1.3. Deleting Existing Data:}$ `DELETE`
> >
> > > **1️⃣**简答例子
> > >
> > > ```sql
> > > -- 删除表中所有记录，危险操作
> > > DELETE FROM Employee
> > > -- 删除表中满足条件的操作
> > > DELETE FROM Employee WHERE Name = "Grace"
> > > ```
> > >
> > > **2️⃣**删除的外键约束
> > >
> > > |       约束子句       |         尝试操作         |                   执行操作                   |
> > > | :------------------: | :----------------------: | :------------------------------------------: |
> > > | `ON DELETE CASCADE ` | $\text{A}$表尝试删除一行 | 操作总被允许，引用该行的$\text{B}$表行都删除 |
> > > | `ON DELETE RESTRICT` | $\text{A}$表尝试删除一行 | 如果改行被$\text{B}$表引用，则删除操作被禁止 |
> > >
> > > ```sql
> > > CREATE TABLE B (
> > >    Bid INT PRIMARY KEY,
> > >    Bname VARCHAR(50),
> > >    Aid INT,
> > >    FOREIGN KEY (Aid) REFERENCES A(Aid) ON DELETE CASCADE
> > >    FOREIGN KEY (Aid) REFERENCES A(Aid) ON DELETE RESTRICT  -- 二选一
> > > );
> > > ```
>
> ## $\textbf{3.2. }$​查询表中内容: `SELECT FROM + XXX`
>
> > ### $\textbf{3.2.1. }$​`SELECT`有关结构
> >
> > > **1️⃣**最基本结构：
> > >
> > > 1. 投影，原理详见关系代数
> > >
> > >    ```sql
> > >    SELECT * FROM Student; -- 选中所有列, Heap Scan
> > >    SELECT age FROM Student; -- 选中年龄这一列，但是SQL操作中默认不去除重复项
> > >    ```
> > >
> > > 2. 关于`DISTINCT`，其后所有属性都要删除重复项
> > >
> > >    ```sql
> > >    SELECT DISTINCT age FROM Student; -- 选中年龄这一列，删除重复项
> > >    SELECT DISTINCT age,name FROM Student; -- 年龄+姓名的组合要DISTINCT,删除重复项
> > >    ```
> > >
> > > **2️⃣**聚合函数$\text{Aggregare Function}$​ 
> > >
> > > 1. 概述
> > >
> > >    | $\textbf{Function}$ |     $\textbf{Description}$      |
> > >    | :-----------------: | :-----------------------------: |
> > >    |       `AVG()`       |     $\text{Average Value}$      |
> > >    |       `MIN()`       |     $\text{Minimum Value}$      |
> > >    |       `MAX()`       |     $\text{Maximum Value}$      |
> > >    |      `COUNT()`      | $\text{Number of Values}$(行数) |
> > >    |       `SUM()`       |     $\text{Sum of Values}$      |
> > >
> > > 2. 示例
> > >
> > >    | $\textbf{CustomerID}$ | $\textbf{AccountID}$ | $\textbf{Balance}$ |
> > >    | :-------------------: | :------------------: | :----------------: |
> > >    |      $\text{1}$       |      $\text{1}$      |    $\text{200}$    |
> > >    |      $\text{1}$       |      $\text{2}$      |    $\text{100}$    |
> > >    |      $\text{2}$       |      $\text{1}$      |    $\text{400}$    |
> > >    |      $\text{3}$       |      $\text{1}$      |    $\text{300}$    |
> > >
> > >    - `COUNT`示例
> > >
> > >      ```sql
> > >      SELECT COUNT(*) FROM Customer; -- 表中有多少Tuples
> > >      SELECT COUNT(CustomerID) FROM Customer; -- 多少个CustomerID
> > >      SELECT COUNT(DISTINCT CustomerID) FROM Customer; -- 多少个Uniqe的ID
> > >      ```
> > >
> > >      | $\textbf{COUNT(CustomerID)}$ |  \   | $\textbf{COUNT(DISTINCT CustomerID)}$ |
> > >      | :--------------------------: | :--: | :-----------------------------------: |
> > >      |          $\text{4}$          |  \   |              $\text{3}$               |
> > >
> > >    - `AVG/MAX/MAX`示例   
> > >
> > >      ```sql
> > >      SELECT AVG(Balance) FROM Account; -- 所有账户余额的平均
> > >      SELECT MAX(Balance) FROM Account WHERE CustomerID=1; -- 用户1最高账户余额
> > >      SELECT SUM(Balance) FROM Account GROUP BY CustomerID; -- 各用户账户总余额
> > >      ```
> > >
> > >      | $\textbf{AVG(Balance)}$ | $\text{\\}$ | $\textbf{MAX(Balance)}$ | $\text{\\}$ | $\textbf{SUM(Balance)}$ |
> > >      | :---------------------: | :---------: | :---------------------: | :---------: | :---------------------: |
> > >      |      $\text{250}$       | $\text{\\}$ |      $\text{200}$       | $\text{\\}$ |      $\text{300}$       |
> > >      |       $\text{\\}$       | $\text{\\}$ |       $\text{\\}$       | $\text{\\}$ |      $\text{400}$       |
> > >      |       $\text{\\}$       | $\text{\\}$ |       $\text{\\}$       | $\text{\\}$ |      $\text{300}$       |
> > >
> > > 3. `SUM()`补充：
> > >
> > >    - 当用于数值类型属性时，会遍历每行求出并返回总和
> > >    - 当用于布尔类型属性时，会遍历每行(布尔真$\text{=1/}$布尔假$\text{=0}$)，返回总和
> > >
> > > **3️⃣**重命名子句`AS` $\text{Clause}$ 
> > >
> > > ```sql
> > > SELECT CustType, COUNT(CustomerID) FROM Customer -- 不重命名
> > > SELECT CustType, COUNT(CustomerID) AS Count FROM Customer -- 重命名为Count
> > > ```
> > >
> > > |  不重命名   | $\textbf{CustType}$ | $\textbf{Count(CustomerID)}$ |   重命名    | $\textbf{CustType}$ | $\textbf{Count}$ |
> > > | :---------: | :-----------------: | :--------------------------: | :---------: | :-----------------: | :--------------: |
> > > | $\text{\\}$ |   $\text{Type1}$    |          $\text{3}$          | $\text{\\}$ |   $\text{Type1}$    |    $\text{3}$    |
> > > | $\text{\\}$ |   $\text{Type2}$    |          $\text{6}$          | $\text{\\}$ |   $\text{Type2}$    |    $\text{6}$    |
> > >
> > > :four:合并列子句`CONCAT`: 将两个不同的列，合并为一列
> > >
> > > ```sql
> > > SELECT CONCAT(FirstName, LastName) AS FullName
> > > FROM Name
> > > ```
> >
> > ### $\textbf{3.2.2. }$`FROM`有关结构
> >
> > > **1️⃣**最基本功能：选定要操作的表格
> > >
> > > ```sql
> > > SELECT * FROM R
> > > ```
> > >
> > > **2️⃣**跨表格操作：$\text{Cross-Product/Join}$，==原理详见关系代数部分==
> > >
> > > 1. $\text{Cross-Product}$​ 
> > >
> > >    ```sql
> > >    SELECT * FROM R, S;	-- Cross product between R, S
> > >    ```
> > >
> > > 2. $\text{Join}$ 
> > >
> > >    ```sql
> > >    SELECT * FROM R NATURAL JOIN S -- Nature Join
> > >    
> > >    SELECT * FROM R INNER JOIN S ON R.sid < S.sid; -- Inner Join
> > >    SELECT * FROM R INNER JOIN S ON R.sid = S.sid; -- Equi Join
> > >    
> > >    SELECT * FROM R LEFT OUTER JOIN S ON R.sid = S.sid;  -- Left Outer Join 
> > >    SELECT * FROM R RIGHT OUTER JOIN S ON R.sid = S.sid; -- Right Outer Join 
> > >    SELECT * FROM R FULL OUTER JOIN S ON R.sid = S.sid;  -- Full Outer Join 
> > >    ```
> >
> > ### $\textbf{3.2.3. }$`+XXX`有关结构
> >
> > > #### $\textbf{3.2.3.1. }$`WHERE` 有关结构
> > >
> > > > **1️⃣**`WHERE` $\text{Clause:}$ 本是上是一种$\text{Selection}$​操作，过滤满足条件
> > > >
> > > > ```sql
> > > > SELECT * FROM Student WHERE Student.rating >= 9;
> > > > ```
> > > >
> > > > **2️⃣**`LIKE` $\text{Clause:}$​​ 与`WHERE`配合使用，实现字符串的匹配==(约等于)== 
> > > >
> > > > 1. 匹配的关键字
> > > >
> > > >    | $\textbf{1}$个不确定的字符 | $\textbf{0-M}$个不确定的字符 |
> > > >    | :------------------------: | :--------------------------: |
> > > >    |      ==$\text{\_}$==       |       ==$\text{\%}$==        |
> > > >
> > > > 2. 匹配子句示例
> > > >
> > > >    | $\textbf{Clause}$                 | `CustomerName` $\textbf{Maches}$ |    示例    |
> > > >    | :-------------------------------- | :------------------------------: | :--------: |
> > > >    | `WHERE CustomerName LIKE 'a%'`    |        以$\text{a}$开始的        |  `axxxxx`  |
> > > >    | `WHERE CustomerName LIKE '%a'`    |        以$\text{a}$结束的        |  `xxxxxa`  |
> > > >    | `WHERE CustomerName LIKE '%a%'`   |         包含$\text{a}$的         |  `xxaxxx`  |
> > > >    | `WHERE CustomerName LIKE '_a%'`   |       $\text{a}$在第二位的       |  `xaxxxx`  |
> > > >    | `WHERE CustomerName LIKE 'a_%_%'` |  以$\text{a}$开始，后至少两字符  | `axx/axxx` |
> > > >    | `WHERE CustomerName LIKE 'a%o'`   |  以$\text{a}$开始$\text{o}$结尾  |  `axxxxo`  |
> > > >
> > > > 3. $\text{SQL}$示例
> > > >
> > > >    ```sql
> > > >    SELECT CustLastName FROM Customer WHERE CustLastName LIKE "Sm%"
> > > >    -- 匹配的会有Smith/Smyth/Smize......
> > > >    ```
> > >
> > > #### $\textbf{3.2.3.2. }$`GROUP BY`有关结构
> > >
> > > > **1️⃣**`GROUP BY` $\text{Clause:}$​ 
> > > >
> > > > 1. 讲记录根据一个/多个属性，分为若干小组
> > > >
> > > > 2. 通常和聚合函数结合使用，为每个小组计算出独立结果
> > > >
> > > > 3. 示例
> > > >
> > > >    ```sql
> > > >    SELECT CustID, AVG(Balance) AS AveBalance
> > > >    FROM Account
> > > >    GROUP BY CustID;
> > > >    ```
> > > >
> > > >    | $\textbf{CustID}$ | $\textbf{Account}$ | $\textbf{Balance}$ | $\xrightarrow[查询]{结果}$ | $\textbf{CustID}$ | $\textbf{AveBalance}$ |
> > > >    | :---------------: | :----------------: | :----------------: | :------------------------: | :---------------: | :-------------------: |
> > > >    |    $\text{1}$     |    $\text{101}$    |    $\text{500}$    |        $\text{\\}$         |    $\text{1}$     |     $\text{325}$      |
> > > >    |    $\text{1}$     |    $\text{102}$    |    $\text{150}$    |        $\text{\\}$         |    $\text{2}$     |     $\text{250}$      |
> > > >    |    $\text{2}$     |    $\text{103}$    |    $\text{200}$    |        $\text{\\}$         |    $\text{3}$     |     $\text{450}$      |
> > > >    |    $\text{2}$     |    $\text{104}$    |    $\text{300}$    |        $\text{\\}$         |    $\text{\\}$    |      $\text{\\}$      |
> > > >    |    $\text{3}$     |    $\text{105}$    |    $\text{450}$    |        $\text{\\}$         |    $\text{\\}$    |      $\text{\\}$      |
> > > >
> > > > 4. 复杂一些的例子：`GROUP BY <复合属性>`  
> > > >
> > > >    ```sql
> > > >    SELECT Subject, Semester, COUNT(*) FROM Example_Table
> > > >    GROUP BY Subject, Semester; -- Subject, Semester都相同才能分为一类
> > > >    ```
> > > >
> > > >    | $\small\textbf{Subject}$ | $\small\textbf{Semester}$ | $\small\textbf{Attendee}$ | $\xrightarrow[查询]{结果}$ | $\small\textbf{Subject}$ | $\small\textbf{Semester}$ | $\small\textbf{COUNT(*)}$ |
> > > >    | :----------------------: | :-----------------------: | :-----------------------: | :------------------------: | :----------------------: | :-----------------------: | :-----------------------: |
> > > >    |  $\small\text{ITB001}$   |        $\text{1}$         |    $\small\text{John}$    |        $\text{\\}$         |  $\small\text{ITB001}$   |        $\text{1}$         |        $\text{3}$         |
> > > >    |  $\small\text{ITB001}$   |        $\text{1}$         |    $\small\text{Bob}$     |        $\text{\\}$         |  $\small\text{ITB001}$   |        $\text{2}$         |        $\text{2}$         |
> > > >    |  $\small\text{ITB001}$   |        $\text{1}$         |   $\small\text{Mickey}$   |        $\text{\\}$         |  $\small\text{IMK114}$   |        $\text{1}$         |        $\text{2}$         |
> > > >    |  $\small\text{ITB001}$   |        $\text{2}$         |   $\small\text{Jenny}$    |        $\text{\\}$         |       $\text{\\}$        |        $\text{\\}$        |        $\text{\\}$        |
> > > >    |  $\small\text{ITB001}$   |        $\text{2}$         |   $\small\text{James}$    |        $\text{\\}$         |       $\text{\\}$        |        $\text{\\}$        |        $\text{\\}$        |
> > > >    |  $\small\text{IMK114}$   |        $\text{1}$         |    $\small\text{John}$    |        $\text{\\}$         |       $\text{\\}$        |        $\text{\\}$        |        $\text{\\}$        |
> > > >    |  $\small\text{IMK114}$   |        $\text{1}$         |   $\small\text{Erica}$    |        $\text{\\}$         |       $\text{\\}$        |        $\text{\\}$        |        $\text{\\}$        |
> > > >
> > > > **2️⃣**`HAVING` $\text{Clause:}$ 适用于`GROUP BY`体质的`WHERE`，==只能和`GROUP BY`一起出现== 
> > > >
> > > > 1. 作用：作为聚合函数的补充，用于筛选`GROUP BY`出来的组
> > > >
> > > > 2. 对比：
> > > >
> > > >    |     `HAVING` $\textbf{Clause}$     |  `WHERE` $\textbf{Clause}$   |
> > > >    | :--------------------------------: | :--------------------------: |
> > > >    | 后接关系$\text{Attribute}$有关条件 | 后接聚合函数(数结)果有关条件 |
> > > >
> > > > 3. 示例：注意区分`WHERE`和`HAVING`
> > > >
> > > >    | $\textbf{CustID}$ | $\textbf{Account}$ | $\textbf{Balance}$ |
> > > >    | :---------------: | :----------------: | :----------------: |
> > > >    |    $\text{1}$     |    $\text{101}$    |    $\text{500}$    |
> > > >    |    $\text{1}$     |    $\text{102}$    |    $\text{150}$    |
> > > >    |    $\text{2}$     |    $\text{103}$    |    $\text{200}$    |
> > > >    |    $\text{2}$     |    $\text{104}$    |    $\text{300}$    |
> > > >    |    $\text{3}$     |    $\text{105}$    |    $\text{450}$    |
> > > >
> > > >    - `WHERE <条件表达式>`：直接过滤原始的数据(过滤数据)
> > > >
> > > >      ```sql
> > > >      SELECT CustID, Balance FROM Customer WHERE Balance > 400;
> > > >      ```
> > > >
> > > >    - `HAVING <条件表达式>`：对分组的结果进行过滤(过滤组)
> > > >
> > > >      |    查询     | $\small\textbf{CustID}$ | $\small\textbf{AveBalance}$ | `HAVING`后  | $\small\textbf{CustID}$ | $\small\textbf{AveBalance}$ |
> > > >      | :---------: | :---------------------: | :-------------------------: | :---------: | :---------------------: | :-------------------------: |
> > > >      | $\text{\\}$ |       $\text{1}$        |        $\text{325}$         | $\text{\\}$ |       $\text{1}$        |        $\text{325}$         |
> > > >      | $\text{\\}$ |       $\text{2}$        |        $\text{250}$         | $\text{\\}$ |       $\text{3}$        |        $\text{450}$         |
> > > >      | $\text{\\}$ |       $\text{3}$        |        $\text{450}$         | $\text{\\}$ |       $\text{\\}$       |         $\text{\\}$         |
> > > >
> > > >      ```sql
> > > >      SELECT CustID, AVG(Balance) AS AveBalance FROM Account
> > > >      GROUP BY CustID HAVING AveBalance > 300;
> > > >      ```
> > >
> > > #### $\textbf{3.2.3.3. }$`ORDER BY` 有关结构
> > >
> > > > **1️⃣**`ORDER BY` $\text{Clause:}$ 
> > > >
> > > > 1. 将查询得到的结果按照某一属性排序
> > > >
> > > >    ```sql
> > > >    SELECT Name, Type FROM Customer ORDER BY Name; -- 按名字(字典序)默认升序
> > > >    SELECT Name, Type FROM Customer ORDER BY Name ASC;  -- 升序
> > > >    SELECT Name, Type FROM Customer ORDER BY Name DESC; -- 降序
> > > >    ```
> > > >
> > > > 2. 将查询得到的结果按照符合属性排序
> > > >
> > > >    ```sql
> > > >    SELECT Name, Type FROM Customer
> > > >    ORDER BY Name DESC, Type ASC;
> > > >     -- 先按Name降序排序
> > > >     -- 再对于Name相同的Tuple，按照Type升序排序
> > > >    ```
> > > >
> > > > **2️⃣**`LIMIT/OFFSET` $\text{Clause:}$​ 
> > > >
> > > > 1. 含义
> > > >
> > > >    | $\textbf{Clause}$  |                             功能                             |
> > > >    | :----------------: | :----------------------------------------------------------: |
> > > >    |     `LIMIT N`      | <span style="color: red;">选取排序结果的前$\text{N}$个</span> |
> > > >    |     `OFFSET M`     |                   跳过$\text{M}$个排序结果                   |
> > > >    | `LIMIT N OFFSET M` | <font color='grenn'>跳过排序结果的前$\text{M}$个，依次选取后面的$\text{N}$个</font> |
> > > >
> > > > 2. 示例：
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/40817826335.png" alt="40817826335" style="zoom:25%;" /> 
> > > >
> > > >    ```sql
> > > >    SELECT Name, Type FROM Customer ORDER BY Name LIMIT 5; -- 红色
> > > >    SELECT Name, Type FROM Customer ORDER BY Name LIMIT 5 OFFSET 3; -- 绿色
> > > >    ```
>
> ## $\textbf{3.3. }$查询表中内容: $\textbf{Sub/Nesting Query}$ 
>
> > ### $\textbf{3.3.1. Subquery}$结构
> >
> > > **0️⃣**概述
> > >
> > > 1. `SELECT`结构相当于一个查询，在一个`SELECT`中插入另一个`SELECT`，则后者就是前者子查询
> > > 2. 执行顺序：先执行子查询$\to{}$将子查询结果传给主查询$\to{}$​执行主查询
> > > 3. 相关子查询：子查询可以直接使用主(外层)查询的列/值
> > >
> > > **1️⃣**在`SELECT`字句中插入子查询，==一般使用`AS`重命名子查询返回的列==
> > >
> > > ```sql
> > > SELECT 
> > >     name,
> > >     (SELECT COUNT(*) FROM orders) AS order_count
> > > FROM customers;
> > > ```
> > >
> > > **2️⃣**在`FROM`字句中插入子查询，==子查询此时相当于一个临时表，所以<span style="color: red;">**必须**</span>使用`AS`重命名==
> > >
> > > ```sql
> > > SELECT tmp.average_sales
> > > FROM  (SELECT AVG(amount) AS average_sales FROM sales) AS tmp;
> > > ```
> > >
> > > **3️⃣**在`WHERE`子句中
> > >
> > > ```sql
> > > SELECT name, age
> > > FROM employees
> > > WHERE salary > (SELECT AVG(salary) FROM employees);
> > > ```
> > >
> > > **4️⃣**在`EXISTS`中，返回布尔值的特殊类子查询
> > >
> > > ```sql
> > > SELECT name
> > > FROM products
> > > WHERE EXISTS (SELECT 1 FROM inventory WHERE inventory.quantity > 0);
> > > ```
> >
> > ### $\textbf{3.3.2. Subquery}$有关子句
> >
> > > **0️⃣**示例表格
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240402032453333.png" alt="image-20240402032453333" style="zoom:33%;" /> 
> > >
> > > 1. $\text{Artefact/Seller/Buyer}$表
> > >
> > >    | $\small\textbf{AID}$ | $\small\textbf{Name}$ |       $描述$       | $\small\text{\\}$ | $\small\textbf{SID}$ | $\small\text{Name}$ | $\small\textbf{Phone}$ | $\small\text{\\}$ | $\small\textbf{BID}$ | $\small\textbf{Name}$ |       $电话$        |
> > >    | :------------------: | :-------------------: | :----------------: | :---------------: | :------------------: | :-----------------: | :--------------------: | :---------------: | :------------------: | :-------------------: | :-----------------: |
> > >    |   $\small\text{1}$   |  $\small\text{Vase}$  | $\small\text{Old}$ | $\small\text{\\}$ |   $\small\text{1}$   | $\small\text{Abby}$ |  $\small\text{0232}$   | $\small\text{\\}$ |   $\small\text{1}$   |  $\small\text{Magg}$  | $\small\text{0333}$ |
> > >    |   $\small\text{2}$   | $\small\text{Knife}$  | $\small\text{Old}$ | $\small\text{\\}$ |   $\small\text{2}$   | $\small\text{Ben}$  |  $\small\text{0311}$   | $\small\text{\\}$ |   $\small\text{2}$   | $\small\text{Nicole}$ | $\small\text{0444}$ |
> > >    |   $\small\text{3}$   |  $\small\text{Pot}$   | $\small\text{Old}$ | $\small\text{\\}$ |   $\small\text{3}$   | $\small\text{Carl}$ |  $\small\text{0333}$   | $\small\text{\\}$ |   $\small\text{3}$   |  $\small\text{Oleg}$  | $\small\text{0555}$ |
> > >
> > > 2. $\text{Offer}$表
> > >
> > >    | $\small\textbf{AID}$ | $\small\textbf{SID}$ | $\small\textbf{BID}$ |   $\small\textbf{Date}$   | $\small\textbf{Amount}$ | $\small\textbf{Acceptance}$ |
> > >    | :------------------: | :------------------: | :------------------: | :-----------------------: | :---------------------: | :-------------------------: |
> > >    |   $\small\text{1}$   |   $\small\text{1}$   |   $\small\text{1}$   | $\small\text{2012-06-20}$ | $\small\text{81223.23}$ |      $\small\text{N}$       |
> > >    |   $\small\text{1}$   |   $\small\text{1}$   |   $\small\text{2}$   | $\small\text{2012-06-20}$ | $\small\text{82223.23}$ |      $\small\text{N}$       |
> > >    |   $\small\text{1}$   |   $\small\text{2}$   |   $\small\text{1}$   | $\small\text{2012-06-20}$ |  $\small\text{19.95}$   |      $\small\text{N}$       |
> > >    |   $\small\text{2}$   |   $\small\text{2}$   |   $\small\text{2}$   | $\small\text{2012-06-20}$ |  $\small\text{23.00}$   |      $\small\text{N}$       |
> > >
> > > **1️⃣**`IN/NOT IN` $\text{Clause:}$​  记录是否在子查询的结果中
> > >
> > > ```sql
> > > SELECT * FROM Buyer
> > > WHERE BID IN (SELECT BID FROM Offer WHERE AID = 1)
> > > ```
> > >
> > > 1. 子查询结果：`BuyerID = 1/2`，主查询结果
> > >
> > >    | $\textbf{BID}$ | $\textbf{Name}$ | $\textbf{Phone}$ |
> > >    | :------------: | :-------------: | :--------------: |
> > >    |   $\text{1}$   |  $\text{Magg}$  |  $\text{0333}$   |
> > >    |   $\text{2}$   | $\text{Nicole}$ |  $\text{0444}$   |
> > >
> > > 2. 基于$\text{Join}$的优化：执行的效率会更高
> > >
> > >    ```sql
> > >    ELECT Buyer.*
> > >    FROM Buyer JOIN Offer ON Buyer.BID = Offer.BID
> > >    WHERE Offer.AID = 1;
> > >    ```
> > >
> > > **2️⃣**`ANY/ALL/EXISTS`
> > >
> > > 1. `ANY`：满足至少一个内部条件，==实际上可以把所有的`IN`改为`=ANY`(至少一个等于)==
> > >
> > >    ```sql
> > >    SELECT empno, sal FROM emp
> > >    WHERE sal > ANY (SELECT....返回:Tuple1, Tuple2, Tuple3);
> > >    
> > >    -- equals to
> > >    SELECT empno, sal FROM emp
> > >    WHERE sal > Tuple1 OR sal > Tuple2 OR sal> Tuple3;
> > >    ```
> > >
> > > 2. `ALL`：满足所有内部条件
> > >
> > >    ```sql
> > >    SELECT empno, sal FROM emp
> > >    WHERE sal > ALL (SELECT....返回:Tuple1, Tuple2, Tuple3);
> > >    
> > >    -- equals to
> > >    SELECT empno, sal FROM emp
> > >    WHERE sal > Tuple1 AND sal > Tuple2 AND sal> Tuple3;
> > >    ```
> > >
> > > **3️⃣**`EXISIS`：内部查询会返回$\text{True/False}$，从而决定外查询执行/不执行
> > >
> > >    ```sql
> > > SELECT * FROM Buyer WHERE EXISTS(
> > >    SELECT * FROM Offer -- 内查询中，SELECT什么不重要，因为最后只会输出True/False
> > >    WHERE Buyer.BuyerID = Offer.BuyerID AND ArtefactID = 1
> > > )
> > >    ```
> > >
> > > 1. 先遍历`Buyer`(外表)，对其每一行向内`Offer`(内表)表查询是否有行满足条件
> > >
> > >    ```sql
> > >     Buyer.BuyerID = Offer.BuyerID AND ArtefactID = 1
> > >    ```
> > >
> > > 2. 如果至少有一行条件满足，则执行下列外查询，把满足条件的行打印出来
> > >
> > >    ```sql
> > >     SELECT * FROM Buyer
> > >    ```
> > >
> > > 3. 一行行遍历$\text{+}$​打印后，结果为: 
> > >
> > >    | $\textbf{BID}$ | $\textbf{Name}$ | $\textbf{Phone}$ |
> > >    | :------------: | :-------------: | :--------------: |
> > >    |   $\text{1}$   |  $\text{Magg}$  |  $\text{0333}$   |
> > >    |   $\text{2}$   | $\text{Nicole}$ |  $\text{0444}$   |
>
> ## $\textbf{3.4. }$其他$\textbf{SQL}$子句
>
> > **1️⃣**`COALESCE()`: 返回列表中第一个非NULL值
> >
> > ```sql
> > -- 遍历每一行，如果A2非空则返回A2，如果A2空则返回''(首个非空值)
> > SELECT A1, COALESCE(A2, '') AS A2New, A3 FROM users;
> > ```
> >
> > |  初始表格   | $\textbf{A1}$  | $\textbf{A2}$ | $\textbf{A3}$  |  查询结果   | $\textbf{A1}$  | $\textbf{A2New}$ | $\textbf{A3}$  |
> > | :---------: | :------------: | :-----------: | :------------: | :---------: | :------------: | :--------------: | :------------: |
> > | $\text{\\}$ | $\text{John}$  | $\text{NULL}$ |  $\text{Doe}$  | $\text{\\}$ | $\text{John}$  |                  |  $\text{Doe}$  |
> > | $\text{\\}$ | $\text{Jane}$  |  $\text{A.}$  | $\text{Smith}$ | $\text{\\}$ | $\text{Jane}$  |   $\text{A.}$    | $\text{Smith}$ |
> > | $\text{\\}$ | $\text{Emily}$ | $\text{NULL}$ | $\text{Davis}$ | $\text{\\}$ | $\text{Emily}$ |                  | $\text{Davis}$ |
> >
> > **2️⃣**`LENGTH()`: 求出一段字符串的长度
> >
> > ```sql
> > ORDER BY LENGTH(Steing)      -- String长度从小到大排列
> > ORDER BY LENGTH(Steing) ASC  -- String长度从小到大排列
> > ORDER BY LENGTH(Steing) DEC  -- String长度从大到小排列
> > ```
> >
> > **3️⃣**`CASE WHEN`语法
> >
> > 1. 语法
> >
> >    ```sql
> >    CASE WHEN <条件表达式> THEN <条件满足时返回这个值> <条件不满足时返回这个值> END
> >    ```
> >
> > 2. 不重命名示例
> >
> >    ```sql
> >    SELECT 
> >    	id,
> >    	amount,
> >    	CASE WHEN amount > 100 THEN 'High' ELSE 'Low' END
> >    	CASE WHEN amount > 100 THEN 'High' ELSE 'Low' END AS class -- 重命名
> >    FROM orders;
> >    ```
> >
> >    |  不重命名   |    `id`    |    `CASE`     |   `amount`   |   重命名    |    `id`    |    `CASE`     |   `class`    |
> >    | :---------: | :--------: | :-----------: | :----------: | :---------: | :--------: | :-----------: | :----------: |
> >    | $\text{\\}$ | $\text{1}$ | $\text{High}$ | $\text{150}$ | $\text{\\}$ | $\text{1}$ | $\text{High}$ | $\text{150}$ |
> >    | $\text{\\}$ | $\text{2}$ | $\text{Low}$  | $\text{80}$  | $\text{\\}$ | $\text{2}$ | $\text{Low}$  | $\text{80}$  |
> >    | $\text{\\}$ | $\text{3}$ | $\text{High}$ | $\text{120}$ | $\text{\\}$ | $\text{3}$ | $\text{High}$ | $\text{120}$ |
> >
> > **4️⃣**$\text{Set Operation:}$ 目的是合并两个查询结果，原理详见关系代数
> >
> > ```sql
> > SELECT sid, sname, rating, age FROM S1 -- 此操作去除重复行
> > UNION
> > SELECT sid, sname, rating, age FROM S2;
> > SELECT sid, sname, rating, age FROM S1 -- 此操作保留重复行
> > UNION ALL
> > SELECT sid, sname, rating, age FROM S2;
> > ```

# $\textbf{4. }补充\textbf{Data Type}$ 

> ## $\textbf{4.1. }$字符类型
>
> > :one:概述
> >
> > |       类型       |          存储          | 备注                                                         |
> > | :--------------: | :--------------------: | :----------------------------------------------------------- |
> > |    `CHAR(M)`     |       定长字符串       | $\text{M∈(0,255)}$表示字符长度                               |
> > |   `VARCHAR(M)`   |       变长字符串       | $\text{M∈(1,65535)}$                                         |
> > | `BIT/BOOL/CHAR`  |      同`CHAR(1)`       | $\text{N/A}$                                                 |
> > |      `BLOB`      | 二进制文件==(音视频)== | 存储最多$\text{65535}$字节的$\text{0/1}$序列                 |
> > |      `TEXT`      |        大段文字        | 最多$\text{65535}$个字符                                     |
> > | `ENUM(a,b,c...)` |      列表(多选一)      | 列表中最多$\text{65535}$个成员，索引从左到右/从$\text{0}$开始 |
> > | `SET(a,b,c...)`  |      列表(多选多)      | 列表中最多$\text{64}$个成员                                  |
> >
> > :two:补充
> >
> > 1. `CHAR(M)`中对于定长字符，如果长度不够则会用空格填充
> >
> >    ```sql
> >    Name CHAR(5) -- 如果赋值Name='Kan'则实际存储Name='Kan<空格><空格>'
> >    ```
> >
> > 2. `TEXT`中说的是最多$\text{65535}$字符，不是字节；一个字符可占$\text{1-4}$​字节
> >
> > 3. `SET(a,b,c...)`示例
> >
> >    ```sql
> >    SET(a1,a2,a3) -- 可存储<空>/a1/a1a2/a1a2a3
> >    ```
>
> ## $\textbf{4.2. }$​整数类型
>
> > :one:概述
> >
> > |     $\textbf{Type}$     | $\textbf{Signed Range}$ | $\textbf{Unsigned Range}$ |
> > | :---------------------: | :---------------------: | :-----------------------: |
> > |     `TINYINT[(M)]`      |      $-128\to127$       |         $0\to255$         |
> > |     `SMALLINT[(M)]`     |    $-32768\to32767$     |        $0\to65535$        |
> > | `INT[(M)]/INTEGER[(M)]` |        ........         |         ........          |
> > |      `BIGINT[(M)]`      |        ........         |         ........          |
> >
> > :two:示例：`TINYINT(4)` 
> >
> > 1. 数字显示宽度为$\text{4}$
> > 2. 如果存储的数字为$\text{12}$，则会显示为$\text{0012}$ 
>
> ## $\textbf{4.3. }$​实数类型
>
> > :one:概述
> >
> > |  $\textbf{Type}$   | $\textbf{Precision}$ |    存储类型     |
> > | :----------------: | :------------------: | :-------------: |
> > |   `FLOAT[(M,D)]`   |        单精度        | $\text{Binary}$ |
> > |  `DOUBLE[(M,D)]`   |   双精度(范围更大)   | $\text{Binary}$ |
> > |   `REAL[(M,D)]`    |   双精度(范围更大)   | $\text{Binary}$ |
> > | `DECIMAL[(M[,D])]` |       定点类型       |     字符串      |
> >
> > :two:参数含义
> >
> > 1. `M`: 小数点左右加起来，一共有多少位
> > 2. `D`: 小数位数
>
> ## $\textbf{4.4. Data \& Time Type}$​ 
>
> > | $\textbf{Type}$ |         $\textbf{Format}$          | $\textbf{Range}$                                          |
> > | :-------------: | :--------------------------------: | :-------------------------------------------------------- |
> > |     `DATA`      |     $\small\text{YYYY-MM-DD}$      | $\text{1000-01-01}\to\text{9999-12-31}$                   |
> > |     `TIME`      |      $\small\text{HH:MM:SS}$       | $\text{-838:59:59}\to\text{838:59:59}$                    |
> > |   `DATETIME`    | $\small\text{YYYY-MM-DD HH:MM:SS}$ | $\text{1000-01-01 00:00:00}\to\text{9999-12-31 23:59:59}$ |
> > |   `TIMESTAMP`   | $\small\text{YYYY-MM-DD HH:MM:SS}$ | $\text{1970-01-01 00:00:00 UTC}\to\text{2037}$            |
> > |    `YEAR[4]`    |        $\small\text{YYYY}$         | $\text{1901}\to\text{2155}$                               |
> >
> > :one:`TIMESTAMP`是$\text{DB}$记录的时间点，会将时间转换为当地时间
> >
> > :two:`NOW()`函数会以$\text{YYYY-MM-DD HH:MM:SS}$格式返回当前时间

# $\textbf{Query Optimization}$ 

# $\textbf{1. Storage}$​ 

> ## $\textbf{1.1. File Hierarchy}$  
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1043190004.png" alt="1043190004" style="zoom: 30%;" /> 
> >
> > |         术语          |                             描述                             |
> > | :-------------------: | :----------------------------------------------------------: |
> > | $\text{Record/Tuple}$ |                         表格中的一行                         |
> > |     $\text{Page}$     | $\text{Fixed-size}$的数据块($\text{MySQL}$中为$\text{16KB}$) |
> > |     $\text{File}$     |                  包含若干多的$\text{Page}$                   |
>
> ## $\textbf{1.2. File Orgnisation}$​
>
> > |       文件类型       |        存放         |      记录的排列方式      |             适用情况             |
> > | :------------------: | :-----------------: | :----------------------: | :------------------------------: |
> > |  $\text{Heap file}$  | $\text{Data File}$  |     记录间无特定顺序     | 检索所有记录($\text{Heap Scan}$) |
> > | $\text{Sorted file}$ | $\text{Data File}$  |   页和记录按某条件排序   |        按特定顺序检索记录        |
> > | $\text{Index file}$  | $\text{Index File}$ | 存放目录，某顺序检索最快 |      快速检索特定顺序的记录      |
> >
> > **1️⃣**$\text{Heap File}$ 
> >
> > 1. $\text{Data File}$结构：$\text{Tuple}$按顺序填满一个个$\text{Page}$ 
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/18238755500.png" alt="18238755500" style="zoom: 39%;" /> 
> >
> > 2. 特点：
> >
> >    - 插入快：插入记录时，随便插入哪里
> >    - 扫描快：即快速扫描所有页($\text{Heap Scan}$)
> >    - 查找慢：要想找到一个$\text{Record}$，需要查看每条记录
> >
> > 3. $\text{Heap Scan / Sequential Scan: }$扫描表格中所有的$\text{Tuple}$ 
> >
> >    ```sql
> >    SELECT * FROM Table;
> >    ```
> >
> > **2️⃣**$\text{Sorted File}$
> >
> > 1. $\text{Data File}$结构：$\text{Pages and records are sorted}$, 上图是根据年龄-薪水复合排序
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1218859907.png" alt="1218859907" style="zoom: 33%;" /> 
> >
> > 2. 特性：
> >
> >    - 查找快：对于有序序列，可以用二分查找
> >    - 插入慢：为了保证顺序，就不能随便插入
> >
> > **3️⃣**$\text{Index File}$ 
>
> ## $\textbf{1.3. Cost}$评估标准
>
> > **1️⃣**$\text{DBMS}$评估$\text{Transactions/Buffer Pool}$等操作需要开销，但最主要的开销是$\text{IO}$操作
> >
> > **2️⃣**开销衡量(忽略$\text{IO}$开销以外的开销)：
> >
> > 1. $\text{DBMS}$的数据存储方式
> >
> >    | 执行查询 |                存储方式                 |           介质           |
> >    | :------: | :-------------------------------------: | :----------------------: |
> >    |    ❌     | 存储在$\text{Non-Volatile}$(非活性)介质 | $\text{Hard Disk / SSD}$ |
> >    |    ✔️     |    存储在$\text{Volatile}$(活性)介质    |       $\text{RAM}$       |
> >
> > 2. 衡量：
> >
> >    - 粗略认为开销$\text{=IO}$开销
> >    - $\text{IO}$开销$\text{ }\propto{}\text{(}$硬盘$\xrightarrow{\text{Data}}$主存$\text{IO}$的页数$\text{)}$ 
>
> ## $\textbf{1.4. Index and Index File}$详解
>
> > ### $\textbf{1.4.1. Index}$概述
> >
> > > **1️⃣**$\text{Index: }$相当于一个目录/指针，每个$\text{Index}$指向一个$\text{Data}$​ 
> > >
> > > :two:$\text{Index File: }$
> > >
> > > 1. 存储$\text{Index}$的文件，建立在$\text{Data File}$​之上
> > > 2. 允许快速检索
> > > 3. 相比$\text{Sorted File}$，$\text{Index}$可以在不改变$\text{Data File}$的情况下，建立多种排序方式
> > >
> > > :three:$\text{Index Key}$
> > >
> > > 1. $\text{Search Key Field}$​(搜索关键字字段): 
> > >
> > >    - 其实就是选取自表格的$\text{Column}$ 
> > >
> > >    - 用于建立索引的特定字段($\text{Fields}$)，比如按年龄排序
> > >
> > > 2. ==$\text{Composite Search Key}$== 
> > >
> > >    - 以比如`<Age, Sal, Name>`先按`Age`排序再按`Sal`排序最后按`Name`排序
> > >
> > >    - 重点关注$\text{Index}$​的顺序
> >
> > ### $\textbf{1.4.2. Indexing Implementation: Hash/B}^{+}\textbf{Tree Index}$ 
> >
> > > **==决定$\text{Index File}$​的顺序==**
> > >
> > > **1️⃣**$\text{B}^{+}\text{Tree Index}$: 
> > >
> > > 1. $\text{Index File}$​结构结构
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421165933628.png" alt="image-20240421165933628" style="zoom:49%;" />  
> > >
> > >    | $\textbf{Index File}$结构结构 |                            特点                             |
> > >    | :---------------------------: | :---------------------------------------------------------: |
> > >    |  $\text{Leaf Node}$(最底层)   | 包含==所有==可能的值$\text{Data Entries}$(这点不同于二叉树) |
> > >    |           中间节点            |     相当于$\text{Guiding}$的作用，包含指向下一层的指针      |
> > >
> > > 2. 特点：
> > >
> > >    - $\text{Index File}$有序
> > >    - 对$\text{Range Search}$和$\text{Equality Search}$效果都很好
> > >
> > > **2️⃣**$\text{Hash Index}$
> > >
> > > 1. 哈希是什么：$\text{Key(Record)}\xrightarrow{\text{Hash函数}}\text{Hash值}\xrightarrow{\text{一个Hash值对应一个Bucket}}放入对应桶$ 
> > >
> > >    | $\textbf{Record}$ | $\textbf{Key}$ | $\textbf{Hash}$ | $\textbf{Bucket}$  |
> > >    | :---------------: | :------------: | :-------------: | :----------------: |
> > >    |  $\text{Alice}$   |   $\text{A}$   |   $\text{1}$    | $\text{1}$对应的桶 |
> > >    |   $\text{Bob}$    |   $\text{B}$   |   $\text{2}$    | $\text{2}$对应的桶 |
> > >    |  $\text{David}$   |   $\text{D}$   |   $\text{4}$    | $\text{4}$对应的桶 |
> > >
> > > 2. $\text{Hash Index}$​原理：哈希函数$\text{H=Sal(Mod4)}$ ​
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image.png" alt="image" style="zoom:50%;" /> 
> > >
> > >    - 先确定要查找的数在哪个$\text{Bucket}$中
> > >    - 再到相应$\text{Bucket}$​中寻找，找到后再索引到$\text{Data File}$中
> > >
> > > 3. 特点：$\text{Index File}$按$\text{Bucket}$排列$\text{→Index File}$无序
> > >
> > >    - 极难作$\text{Range Search}$(<span style="color:red;">还不如直接$\text{Heap Scan}$</span>)，==只能作$\text{Equality Search}$​== 
> > >
> > >      ```sql
> > >      SELECT * FROM A>10 -- 若A建立在HASH索引上，这一行效率最高的恰恰是Heap Scan
> > >      ```
> > >
> > >    - 再去让$\text{Hash Index}$作$\text{Cluster}$无意义，因为$\text{Data}$顺序等于/不等于无序的$\text{Index}$都无意义 
> >
> > ### $\textbf{1.4.3. Index Storage: Cluster/Uncluster Index}$ 
> >
> > > **==决定$\text{Data File}$顺序(无序/与$\text{Index File}$​顺序一致)==**
> > >
> > > **1️⃣**$\text{Cluster/Uncluster Index}$​概述
> > >
> > > 1. 原理
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240421162644005.png" alt="image-20240421162644005" style="zoom:55%;" />   
> > >
> > >
> > > |     $\textbf{Type}$      |        $\textbf{Data File}$        |
> > > | :----------------------: | :--------------------------------: |
> > > |  $\text{Cluster Index}$  | 有序，且==按照$\text{Index}$排序== |
> > > | $\text{Uncluster Index}$ |     无序，即$\text{Heap File}$     |
> > >
> > > 2. 注意事项：
> > >
> > >    - 一个表格的$\text{Cluster Index}$必须是唯一的，因为其按照$\text{Index}$​排序
> > >    - $\text{Cluster/Uncluster Index}$的概念很大程度是只应用在$\text{B}^{+}\text{Tree Index}$，而非$\text{Hash}$上的
> > >
> > > **2️⃣**$\text{Cluster/Uncluster Index}$的$\text{Range Scan}$开销：例如要搜索成绩在$\text{10→50}$的学生 
> > >
> > > |  $\textbf{Type}$   |              开销               |                     示例                      |
> > > | :----------------: | :-----------------------------: | :-------------------------------------------: |
> > > |  $\text{Cluster}$  |     存放所需范围数据的页数      | 假设$\text{10→50}$存放在$3$页中$\to$开销是$3$ |
> > > | $\text{Uncluster}$ | 符合要求的$\text{Data Entry}$数 |               最坏情况$40(41)$                |
> > >
> > > 1. $\text{Cluster Index}$开销原理
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240510140340276.png" alt="image-20240510140340276" style="zoom: 50%;" />  
> > >
> > > 2. $\text{Uncluster Index}$开销原理：最坏的情况，每读一个数据都要$\text{IO}$一页
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240510141358438.png" alt="image-20240510141358438" style="zoom:50%;" /> 
> >
> > ### $\textbf{1.4.3. Index Role: Primary/Secondary Index}$
> >
> > > |  $\textbf{Type}$   |   $\textbf{Search Key}$    | $\textbf{Duplicates}$ |             示例              |
> > > | :----------------: | :------------------------: | :-------------------: | :---------------------------: |
> > > |  $\text{Primary}$  |  包含$\text{Primary Key}$  |        不存在         | 按照`Student.ID`排序建立索引  |
> > > | $\text{Secondary}$ | 不包含$\text{Primary Key}$ |       可能存在        | 按照`Student.Age`排序建立索引 |

# $\textbf{2. Query Processing}$

> ## $\textbf{2.1. SELECTION Processing}$
>
> > ### $\textbf{2.1.1. }$有关参数：==高亮为$\text{SELECTION}$开销决定参数== 
> >
> > > :one:基础参数
> > >
> > > |         $\textbf{Factor}$         | 含义                                 |
> > > | :-------------------------------: | :----------------------------------- |
> > > |      ==$\text{NPages(I)}$==       | $\text{Index File}$一共有多少页      |
> > > |        $\text{NTuples(R)}$        | $\text{Data File}$一共有多少条数据   |
> > > |        $\text{NPages(R)}$         | $\text{Data File}$一共有多少页       |
> > > | $\text{NTuplesPerPage}\text{(R)}$ | $\text{Data File}$每页存放多少条数据 |
> > >
> > > - $\text{NTuples(R)=}\text{NPages(R)}\times\text{NTuplesPerPage}\text{(R)}$ 
> > >
> > > **2️⃣**查询优化参数
> > >
> > > |             $\textbf{Factor}$             | 含义                                         |
> > > | :---------------------------------------: | :------------------------------------------- |
> > > |       ==$\text{Result Size(RS)}$==        | $\text{Data File}$一共有多少页**是需要的**   |
> > > | $\text{Reduction Factor(RF)/Selectivity}$ | 有多少百分比的数据符合$\text{SELECTION}$条件 |
> > >
> > > 1. 原理：$\text{NPages(R)(关系大小)}\xrightarrow[剩下的]{经过\text{WHERE + Condition}筛选}\text{RS}$，即$\text{RS = NPages(R)×RF}$  
> > > 2. 示例：整个表格有$\text{100}$页，经过`WHERE+condition`筛选后只有$\text{20}$页，那$\text{RS=20, RF=0.2}$ 
> >
> > ### $\textbf{2.1.2. SELECTION Cost}$
> >
> > > **1️⃣**非索引情况下的开销($\text{Sorted File}$基本不考)
> > >
> > > | $\textbf{File Structure}$ |     $\textbf{Cost}$(单位是$\textbf{IO}$次数)     |               原理               |
> > > | :-----------------------: | :----------------------------------------------: | :------------------------------: |
> > > |    $\text{Heap File}$     |                $\text{NPages(R)}$                | $\text{Heap Scan}$读取表中每一页 |
> > > |   $\text{Sorted File}$    | $\log_{2}\text{[NPages(R)]+RF×}\text{NPages(R)}$ |   二分查找定位$+$所需读多少页    |
> > >
> > > **2️⃣**索引情况下的开销
> > >
> > > |   $\textbf{Index}$实现    |   $\textbf{Index}$存储/角色    |                             开销                             |
> > > | :-----------------------: | :----------------------------: | :----------------------------------------------------------: |
> > > | $\text{B}^{+}\text{Tree}$ |     $\text{Primary Index}$     |                 $\text{树高Height(Index)+1}$                 |
> > > |       $\text{Hash}$       |     $\text{Primary Index}$     |     $\text{ProbeCost(Index)+1}\xrightarrow{默认为}1.2+1$     |
> > > | $\text{B}^{+}\text{Tree}$ | ==$\text{Unclustered index}$== | $\text{[NPages(I)+N\textcolor{red}{Tuples}(R)]×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}$ |
> > > | $\text{B}^{+}\text{Tree}$ |  ==$\text{Clustered index}$==  | $\text{[NPages(I)+N\textcolor{red}{Pages}(R)]×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}$ |
> > > |       $\text{Hash}$       |   $\text{Unclustered index}$   | $\text{N\textcolor{red}{Tuples}(R)×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}\times{}2.2$ |
> > > |       $\text{Hash}$       |    $\text{Clustered index}$    | $\text{N\textcolor{red}{Pages}(R)×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}\times{}2.2$ |
> > >
> > > 1. $\text{Unclustered/Clustered index}$的两部分开销为读取所需$\text{Index+Page}$
> > > 2. $\text{Unclustered index}$中$\text{NTuples(R)}$是因为此时读取需要反复回到$\text{Index File}$​
> > > 3. 多个$\text{RF}$​都需要乘起来，至于有多少个，取决于`WHERE`子句后面是什么
> >
> > ### $\textbf{2.1.3. SELECTION Cost}$补充：$\textbf{RF Estimate}$ 
> >
> > > #### $\textbf{2.1.3.1. }$基本假设: $\textbf{Assume Uniform Distribution}$ 
> > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/82928265853.png" alt="82928265853" style="zoom: 38%;" /> 
> > >
> > > #### $\textbf{2.1.3.2. }$$\textbf{RF Estimate}$ 
> > >
> > > > **1️⃣**简单情况下的$\text{RF}$估算
> > > >
> > > > 1. 参数含义
> > > >
> > > >    |        参数         |                    含义                    |
> > > >    | :-----------------: | :----------------------------------------: |
> > > >    | $\text{NKeys(Col)}$ | 一列中含有多少种独一无二的值，即`DISTINCT` |
> > > >    | $\text{High(Col)}$  |               一列种的最高值               |
> > > >    |  $\text{Low(Col)}$  |               一列种的最低值               |
> > > >
> > > > 2. 离散变量的$\text{RF}$​估算：`WHERE Col=Value`
> > > >
> > > >    - ${}\text{Col=Value}$对应单个值时，$\text{RF=}\cfrac{\text{1}}{\text{NKeys(Col)}}$ 
> > > >
> > > >      ```sql
> > > >      WHERE level=5;
> > > >      ```
> > > >
> > > >    - ${}\text{Col=Value}$可对应多个值，比如以下情况有$\text{X}$个$\text{Value}$，则$\text{RF=}\cfrac{\text{X}}{\text{NKeys(Col)}}$ 
> > > >
> > > >      ```sql
> > > >      WHERE level=1 AND level=2 AND ... AND level=X;
> > > >      ```
> > > >
> > > >    - 离散变量的不等$\xrightarrow{转化}$相等，如下$\text{Level>7}\Rightarrow\text{Level=8,9,10}\Rightarrow\text{Num=3}$ 
> > > >
> > > >      ```sql
> > > >      WHERE level>1 -- 共10个level
> > > >      ```
> > > >
> > > >      比如​ 
> > > >
> > > > 3. 连续变量的$\text{RF}$估算：`WHERE Col>Value / WHERE Col<Value ` 
> > > >
> > > >    |        条件        |                      $\textbf{RF}$等于                       | $\textbf{SQL}$示例 |
> > > >    | :----------------: | :----------------------------------------------------------: | :----------------: |
> > > >    | $\text{Col>Value}$ | $\cfrac{\text{High(Col)}-\text{Value}}{\text{High(Col)}-\text{Low(Col)}}$ |      `time>8`      |
> > > >    | $\text{Col<Value}$ | $\cfrac{\text{Value}-\text{Low(Col)}}{\text{High(Col)}-\text{Low(Col)}}$ |      `time<8`      |
> > > >
> > > > **2️⃣**$\text{Join}$操作下的$\text{RF}$估算：$\text{RF}=\cfrac{1}{\text{Max[NKeys(JoinCol\_A), NKeys(JoinCol\_B)]}}$ 
> > > >
> > > > 1. 示例：$\text{Student/Subject}$是两个$\text{JoinCol}$
> > > >
> > > >    ```sql
> > > >    Student INNER JOIN Subject ON Student.stuid=Subject.stuid
> > > >    ```
> > > >
> > > >
> > > > 2. 核心：$\text{Primary Key}$所在列$\text{JoinCol}$​唯一值更多​
> > > >
> > > >    - 假设`stuid`在$\text{Student}$处为$\text{PK}$，在$\text{Subject}$处为$\text{FK}$ 
> > > >
> > > >    - 则：$\text{RF}=\cfrac{1}{\text{NTuples(Student)}}$ 
> > > >
> > > > 3. 特殊情况：若$\text{Student}$筛选剩下$\text{20\%}$再去$\text{Join}$，$\text{RF}$计算无需$\text{×20\%}$，永远保持原来的大小
> > > >
> > > >    - 原理：$\text{Subject}$中还有未被筛选的那$\text{80\% Student}$​数据，即这些值是被筛掉而不是删掉
> > > >
> > > >    - 如下例子中：两种情况下$\text{NLJ}$都有$\text{RF}=\text{RF(Test}\bowtie{}\text{DTR)}$​   
> > > >
> > > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/41570539127.png" alt="41570539127" style="zoom:39.9%;" /> 
> > > >
> > > > **3️⃣**玄学情况：比如告诉你`age=5`但是不告诉你`DISTINCT age`的数量，则默认$\text{RF=}\cfrac{1}{10}$
> > >
> > > #### $\textbf{2.1.3.3. }$$\textbf{RF Estimate}$优化 
> > >
> > > > :one:存在的问题：数据不可能是平均分布的，如果数据集中向一个方向靠近，误差就会很大
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240512175609718.png" alt="image-20240512175609718" style="zoom: 43%;" /> 
> > > >
> > > > :two:误差分析
> > > >
> > > > 1. 方法$\text{1: Variable-Width Histogram}$​(柱状图)
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240512180432571.png" alt="image-20240512180432571" style="zoom:40%;" /> 
> > > >
> > > >    - 分$\text{Bucket}\to{}$尽量每个$\text{Bucket}$中数量差不多$\to{}$再去用$\text{Bucket}$估计
> > > >
> > > >    - 估算`age=5`(在$\text{Bucket1}$里)：$\text{RF=}\cfrac{1}{共4个\text{Bucket}\times{}\text{Bucket1}里有5个值}=\cfrac{1}{20}$
> > > >
> > > > 2. 方法$\text{2: }$取样出一部分数据，得出大致的数据分布
> >
> > ### ==$\textbf{2.1.4. SELECTION Condition: }$如何处理`WHERE`子句==
> >
> > > **1️⃣**原理
> >
> > > 1. 寻找最便宜的$\text{Access Path}$：估算成本($\text{IO}$次数)
> > >    - 利用==索引匹配的谓词==来计算$\text{RF}$，从而达到简化效果​
> > >    - $\text{Apply other predicates on-the-fly}$(实时)
> > > 2. 选取成本最小的方式($\text{Index}$或$\text{File Scan}$)
> > >
> > > **2️⃣**索引匹配的谓词：$\text{Composite Search Key}$与`WHERE + Condition`匹配
> > >
> > > 1. 匹配条件：
> > >
> > >    - `WHERE + Condition`要包含$\text{Composite Search Key}$的$\text{Prefix}$​
> > >    - `WHERE + Condition`中`AND`的顺序不重要
> > >
> > > 2. 匹配示例：`<a,b,c>`的$\text{Prefix}$包含`a/ab/abc`
> > >
> > >    | $\textbf{Composite Search Key}$ | $\textbf{ WHERE Conditions}$ | 匹配的$\textbf{Prefix}$ |
> > >    | :-----------------------------: | :--------------------------- | :---------------------- |
> > >    |            `<a,b,c>`            | `WHERE a=1`                  | `a`                     |
> > >    |            `<a,b,c>`            | `WHERE a=1 AND b=2`          | `a,b`                   |
> > >    |            `<a,b,c>`            | `WHERE a=1 AND b=2 AND c=3`  | `a,b,c`                 |
> > >    |            `<a,b,c>`            | `WHERE a=1 AND b=2 AND d=3`  | `a,b`                   |
> > >    |            `<a,b,c>`            | `WHERE a=1 AND c=2`          | `a`                     |
> > >    |            `<a,b,c>`            | `WHERE b=2 AND c=3`          | `NULL`                  |
> > >
> > > **3️⃣**基于索引匹配的谓词的$\text{RF}$​计算示例
> > >
> > > | $\textbf{Composite Search Key}$ | $\textbf{ WHERE Conditions }$ | $\textbf{Prefix}$ |    $\textbf{RF}$    |
> > > | :-----------------------------: | :---------------------------- | :---------------: | :-----------------: |
> > > |            `<a,b,c>`            | `WHERE a AND c`               |        `a`        |   $\text{RF(a)}$    |
> > > |             `<a,c>`             | `WHERE a AND b AND c`         |       `a,c`       | $\text{RF(a)RF(c)}$ |
> > >
> > > **4️⃣**其他注意事项：$\text{Hash}不能作\text{Range Search}$，见如下的综合示例中$\text{Day}$是$\text{Range Search}$
> > >
> > > ```sql
> > > WHERE day<8/9/94 AND bid=5 AND sid=3
> > > ```
> > >
> > > |      $\textbf{Type}$      | $\textbf{Index}$ | $\textbf{Prefix}$ |      是否适用于示例的查询       |      $\textbf{RF}$       |
> > > | :-----------------------: | :--------------: | :---------------: | :-----------------------------: | :----------------------: |
> > > | $\text{B}^{+}\text{Tree}$ |  `<rname,day>`   |   $\text{N/A}$    | $\text{N}(无匹配\text{Prefix})$ |        $\text{1}$        |
> > > | $\text{B}^{+}\text{Tree}$ |  `<day,rname>`   |       `day`       |           $\text{Y}$            |     $\text{RF(day)}$     |
> > > | $\text{B}^{+}\text{Tree}$ |   `<day,sid>`    |     `day,sid`     |           $\text{Y}$            | $\text{RF(day)*RF(sid)}$ |
> > > |       $\text{Hash}$       |  `<day,rname>`   |       `day`       |  $\text{N(Hash不能范围搜索)}$   |        $\text{1}$        |
> > >
> > > - 注意一个细节：这里的$\text{B}^{+}\text{Tree}$无论是$\text{Cluster/Uncluster}$，都无关紧要
>
> ## $\textbf{2.2. Projection}$(很少考)
>
> > ### $\textbf{2.2.1. Overview}$ 
> >
> > > **1️⃣**投影$\text{Process}$的流程
> > >
> > > |             场所             | 操作                                         |
> > > | :--------------------------: | -------------------------------------------- |
> > > |       磁盘$\to{}$内存        | 读取$\text{Data File}$中所有要处理的页到内存 |
> > > |       内存$\to{}$磁盘        | 在内存中投影(筛掉一些页)，剩下页写回磁盘     |
> > > | 磁盘(但排序时不断和内存交换) | 对投影后的页进行排序                         |
> > > |       磁盘$\to{}$内存        | 将投影+排序后的页，重新读回内存              |
> > >
> > > **2️⃣**为何$\text{Projection}$操作中需要$\text{Sort}$
> > >
> > > |                  原因                   | 解释                                                         |
> > > | :-------------------------------------: | ------------------------------------------------------------ |
> > > |            支持`DISTICT`操作            | ==去重时==，如果数据已经排序，那么合并相邻的相同记录即可     |
> > > | 提高$\text{B}^{+}\text{Tree}$的加载效率 | 已排序的数据插入$\text{B}^{+}\text{Tree}$时，不太可能导致大量的节点重新分配 |
> > > |           优化`GROUP BY`操作            | 比如按照`Age`分类，需要直到有几种`Age`，那就需要排序         |
> > >
> > > - 关于==去重==：$\text{Projection}$可能会$\text{Removing duplicates}$，例如假设$\text{20}$个员工隶属于$\text{4}$​个部门
> > >
> > >   ```sql
> > >   SELECT Depart FROM Employees;         -- 返回20个员工的20个部门(共20行)
> > >   SELECT DISTINCT Depart FROM Employees;-- 返回20个员工的4种部门(共4行)
> > >   ```
> > >
> > > **3️⃣**$\text{Projection Factor(PF)}$ 
> > >
> > > 1. 是投影处理的决定因素
> > > 2. 即选取的$\text{Column}$占$\text{Column}$总数的比，例如总共十个属性$\text{Project}$两个，则$\text{PF=0.2}$ 
> >
> > ### $\textbf{2.2.2. External Merge Sort: Divide \& Conquer}$(分治)
> >
> > > **1️⃣**排序原理
> > >
> > > |  $\textbf{Trem}$   |                   含义                    |
> > > | :----------------: | :---------------------------------------: |
> > > |  $\text{Passes}$   |     排序过程中数据读写硬盘的循环次数      |
> > > | $\text{NumPasses}$ | $\text{Passes}$数量(分多少次可以完成排序) |
> > > |   $\text{Runs}$    |            已排序的有序数据段             |
> > > |   $\text{N-Way}$   |     每次合并$\text{N}$个$\text{Runs}$     |
> > >
> > > 1. 分割整个数据集为多个小$\text{Runs}\to{}$每个$\text{Runs}$加载进内存排好序$\to{}$排序后的$\text{Runs}$写回磁盘
> > > 2. 将磁盘中的$\text{Runs}$有序合并为有关大的$\text{Runs}$​
> > >
> > > 😭采用$\text{External}$排序的原因在于内存不够大，需要轮换进入内存
> > >
> > > **2️⃣**$\text{2-Way External Merge Sort}$示例
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/33983312621.png" alt="33983312621" style="zoom:55%;" />  
> > >
> > > |    $\textbf{Trem}$     |               $\textbf{Value}$               |                      $\textbf{E.g.}$                       |
> > > | :--------------------: | :------------------------------------------: | :--------------------------------------------------------: |
> > > |   $\text{NumPasses}$   | $1 + \lceil \log_2 [\text{NPages(R)]}\rceil$ | $1 + \lceil \log_2 \text{7}\rceil=1 + \lceil 2.3\rceil=3 $ |
> > > | $\text{Total IO Cost}$ |        $\text{2×NPages(R)×NumPasses}$        |              $\text{2}\times{}7\times{}3=42$               |
> > >
> > > **3️⃣**基于外归并排序的$\text{Projection}$开销：等于以下每列之和(==记下即可==)
> > >
> > > | 步骤 | 操作                                             | $\textbf{Cost}$值                 |
> > > | :--: | ------------------------------------------------ | :-------------------------------- |
> > > | 读取 | 读取表($\text{Data File}$)中所有要排序的页到内存 | $\text{NPages(R)}$                |
> > > | 投影 | 投影筛掉一些页，将投影后的页写回磁盘             | $\text{NPages(R)×PF}$             |
> > > | 排序 | 对投影后的数据排序(每轮都要读写一次)             | $\text{NPages(R)×PF×2×NumPasses}$ |
> > > | 写回 | 将投影+排序后的页，重新读回内存                  | $\text{NPages(R)×PF}$             |
> >
> > ### $\textbf{2.2.3. External Hashing}$
> >
> > > **1️⃣**原理
> > >
> > > 1. 第一轮：内存有限$\to{}1$页用作缓存$+$剩下$\text{B-1}$页当作$\text{Bucket}$​
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/30913827511.png" alt="image-20240511073935359" style="zoom: 47%;" />  
> > >
> > >    - 硬盘的每页$\xrightarrow[缓存]{读取}$内存中的缓存页
> > >    - 缓存页的数据$\xrightarrow[\text{Hash}]{\text{H1}}$剩下的$\text{B-1}$个$\text{Bucket}$​中
> > >    - 满了的$\text{Bucket}\xrightarrow{读出}$硬盘中**若干**页(由于不够细分一个$\text{Bucket}$​​可能输出多页)
> > >    - 最终硬盘中有$\text{Bucket1→Bucket(B-1)}$共$\text{B-1}$个$\text{Bucket}$，每个$\text{Bucket}$中有若干页
> > >
> > > 2. 第二轮：试图用有限内存充分分类
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/13807891517.png" alt="13807891517" style="zoom:45%;" />  
> > >
> > >    - 硬盘$\text{Bucket1}$的每页/$\text{Bucket2}$的每页/..../$\text{Bucket(B-1)}$的每页$\xrightarrow[缓存]{读取}$内存中的缓存页
> > >    - 缓存页的数据$\xrightarrow[\text{Hash}]{\text{H2(注意是一个新的Hash函数)}}$新的$\text{B-1}$个$\text{Bucket}$​中
> > >    - 以此类推.............
> > >
> > > 3. 最后一轮：所有的数据得到了充分的细分，以至于最后每个$\text{Bucket}$​中只包含一个数据
> > >
> > > **2️⃣**基于$\text{External Hashing}$的$\text{Projection}$开销
> > >
> > > | 步骤 | 操作                                             | $\textbf{Cost}$值     |
> > > | :--: | ------------------------------------------------ | :-------------------- |
> > > | 读取 | 读取表($\text{Data File}$)中所有要排序的页到内存 | $\text{NPages(R)}$    |
> > > | 投影 | 投影筛掉一些页，将投影后的页写回磁盘             | $\text{NPages(R)×PF}$ |
> > > | 写回 | 将投影后的页，重新读回内存                       | $\text{NPages(R)×PF}$ |
>
> ## $\textbf{2.3. Join Algorithms}$ 
>
> > ### $\textbf{2.3.1. Nested Loops Join}$
> >
> > > **0️⃣**关于$\text{Inner/Outer Table}$​
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240511093730591.png" alt="image-20240511093730591" style="zoom:59%;" />  
> > >
> > > 1. 如果可以选$\text{→}$一般设定$\text{Outer}$为$\text{NPages}$​较小的表
> > > 2. 默认左边是$\text{Outer}$右边是$\text{Inner}$
> > >
> > > **1️⃣**原理
> > >
> > > |    $\textbf{Type}$     | $\textbf{Outer Table}$的每___ | $\xrightarrow{扫描}$ | $\textbf{Inner Table}$的每___ |
> > > | :--------------------: | :---------------------------: | :------------------: | :---------------------------: |
> > > |    $\text{Simple}$     |              行               | $\xrightarrow{扫描}$ |              页               |
> > > | $\text{Page-Oriented}$ |              页               | $\xrightarrow{扫描}$ |              页               |
> > > |     $\text{Block}$     |        块(包含多个页)         | $\xrightarrow{扫描}$ |              页               |
> > >
> > > **2️⃣**示意图与工作流程
> > >
> > > 1. $\text{Simple Nested Loops Join}$​
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240511123035510.png" alt="image-20240511123035510" style="zoom: 26.5%;" />  
> > >
> > >    |      $\textbf{Outer Page}$      | $\textbf{Inner Page}$ |
> > >    | :-----------------------------: | :-------------------: |
> > >    | $\text{Outer Page 1, Tuple 1}$  | $\text{Inner Page 1}$ |
> > >    | $\text{Outer Page 1, Tuple 1}$  | $\text{Inner Page 2}$ |
> > >    | $\text{Outer Page 1, Tuple 1}$  | $\text{Inner Page 3}$ |
> > >    | $\text{Outer Page 1, Tuple 1}$  | $\text{Inner Page 4}$ |
> > >    | $\text{Outer Page 1, Tuple 2}$  | $\text{Inner Page 1}$ |
> > >    |              .....              |         .....         |
> > >    | $\text{Outer Page 10, Tuple N}$ | $\text{Inner Page 4}$ |
> > >
> > > 2. $\text{Page-Oriented Nested Loops Join: }$内存不多不少，就占用三页
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240511101634537.png" alt="image-20240511101634537" style="zoom:50%;" />  
> > >
> > >    | $\textbf{Outer Page}$  | $\textbf{Inner Page}$ |
> > >    | :--------------------: | :-------------------: |
> > >    | $\text{Outer Page 1}$  | $\text{Inner Page 1}$ |
> > >    | $\text{Outer Page 1}$  | $\text{Inner Page 2}$ |
> > >    | $\text{Outer Page 1}$  | $\text{Inner Page 3}$ |
> > >    | $\text{Outer Page 1}$  | $\text{Inner Page 4}$ |
> > >    | $\text{Outer Page 2}$  | $\text{Inner Page 1}$ |
> > >    |         .....          |         .....         |
> > >    | $\text{Outer Page 10}$ | $\text{Inner Page 4}$ |
> > >
> > > 3. $\text{Block Nested Loops Join}$   
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240513080234516.png" alt="image-20240513080234516" style="zoom:33%;" /> 
> > >
> > >    |             $\textbf{Outer Page}$             | $\textbf{Inner Page}$ |
> > >    | :-------------------------------------------: | :-------------------: |
> > >    | $\text{Outer Page 1 + Outer Page 2(Block1)}$  | $\text{Inner Page 1}$ |
> > >    | $\text{Outer Page 1 + Outer Page 2(Block1)}$  | $\text{Inner Page 2}$ |
> > >    | $\text{Outer Page 1 + Outer Page 2(Block1)}$  | $\text{Inner Page 3}$ |
> > >    | $\text{Outer Page 1 + Outer Page 2(Block1)}$  | $\text{Inner Page 4}$ |
> > >    | $\text{Outer Page 3 + Outer Page 4(Block2)}$  | $\text{Inner Page 1}$ |
> > >    |                     .....                     |         .....         |
> > >    | $\text{Outer Page 9 + Outer Page 10(Block5)}$ | $\text{Inner Page 4}$ |
> > >
> > > **3️⃣**开销：外表扫描成本$+$内表扫描成本
> > >
> > > |    $\textbf{Type}$     |      外表扫描成本      |                    内表扫描成本                     |
> > > | :--------------------: | :--------------------: | :-------------------------------------------------: |
> > > |    $\text{Simple}$     | $\text{NPages(Outer)}$ | $\text{NTuples(Outer)}\text{×}\text{NPages(Inner)}$ |
> > > | $\text{Page-Oriented}$ | $\text{NPages(Outer)}$ | $\text{NPagees(Outer)}\text{×}\text{NPages(Inner)}$ |
> > > |     $\text{Block}$     | $\text{NPages(Outer)}$ | $\text{NBlocks(Outer)}\text{×}\text{NPages(Inner)}$ |
> > >
> > > 1. 外表所有页都要被读一次，所以成本为$\text{NPages(Outer)}$ 
> > > 2. $\text{NBlocks(Outer)=NPages(Outer)/(Memory-2)}$
> > >    - $\text{Memory-2}$为$\text{RAM}$中$\text{Outer Pages}$的数量，即一次从$\text{Outer Table}$​读入多少页
> > >    - 当$\text{NBlocks(Outer)}$​​​​​不为整数时，要==向上取整== 
> > >    - 分配$\text{RAM(Memory)}$越多，就会$\text{NBlocks(Outer)}$越低，从而开销越小
> > >
> > > **4️⃣**开销的最优解：$\begin{cases}\text{RAM}可把\text{Outer Table}全放进\to{}大小至少为\text{NPages(Outer)+2}\\\\最优解\to{}\text{Cost=NPages(Outer)+NPages(Inner)}\end{cases}$
> > >
> > > 1. 这其实不仅是$\text{NLJ}$的最优解，==也是全局最优解，因为这个解刚刚刚好是把两个表读进来== 
> > >
> > > 2. 在最优解不变的情况下为了节省内存$\to{}$==$\text{Outer}$表要尽量小(小表)== 
> >
> > ### $\textbf{2.3.2. Sort-Merge Join}$ 
> >
> > > **1️⃣**原理：以`A INNER JOIN B ON A.age = B.number`为例
> > >
> > > 1. 第一步：按照$\text{Join Column}$(此处分别为`age`和`number`)排序
> > >    - $\text{A}$表按照`age`排序，$\text{B}$​​表按照`numver`排序
> > >    - 目的在于：==让相同/相关的值物理上靠近，可以顺序访问$\text{→}$​加快合并==
> > > 2. 第二步：$\text{AB}$两表再进行$\text{Join}$​操作
> > > 3. $\text{Output}$: 一定是按照$\text{Join Column}$排好序的
> > >
> > > **2️⃣**排序的成本为$\text{0}$的情况：==$\text{Clustered + }$$\text{B}^{+}\text{Tree + }$$\text{Join Column}$是索引依据的$\text{Prefix}$== ​
> > >
> > > ```sql
> > > A INNER JOIN B ON A.age = B.number
> > > ```
> > >
> > > | 索引根据($\textbf{Composite Search Key}$) |          索引类型          | 表$\textbf{A}$无需排序 |
> > > | ----------------------------------------- | :------------------------: | :--------------------: |
> > > | `<A.age>`                                 | $\text{Clustered B}^{+}$树 |           ✔️            |
> > > | `<A.name>`                                | $\text{Clustered B}^{+}$树 |           ❌            |
> > > | `<A.age, A.name>`                         | $\text{Clustered B}^{+}$树 |           ✔️            |
> > > | `<A.name, A.age>`                         | $\text{Clustered B}^{+}$树 |           ❌            |
> > >
> > > **3️⃣**$\text{Cost = Sort(Outer)+ Sort(Inner)+ NPages(Outer)+ NPages(Inner)}$ 
> > >
> > > |    $\textbf{Cost}$     |              成因              |
> > > | :--------------------: | :----------------------------: |
> > > |  $\text{Sort(Outer)}$  |       将外表所有元素排序       |
> > > |  $\text{Sort(Inner)}$  |       将内表所有元素排序       |
> > > | $\text{NPages(Outer)}$ | 遍历外表的所有页以执行合并操作 |
> > > | $\text{NPages(Inner)}$ | 遍历内表的所有页以执行合并操作 |
> > >
> > > - $\text{Sort(X)=}\begin{cases} \text{2×NumPasses×NPages(X)}\\\\0\text{ (Clustered B}^{+}\text{ Index on Join Column Prefix)}\end{cases}$ 
> >
> > ### $\textbf{2.3.3. Hash Join}$(一般情况开销最小)
> >
> > > **1️⃣**原理：以按照`A.id = B.id`$\text{Join}$为例，其中`id`为连接键
> > >
> > > 1. $\text{Build Phase}$: `A.id`$\xrightarrow[\text{Hash}]{\text{H1哈希函数}}$​`H1(A.id)`构建$\text{Hash}$表$\text{A}$，==通常是选小表($\text{Inner}$)来构建$\text{Hash}$表==
> > > 2. $\text{Probe Phase}$(探测阶段):  
> > >    - `B.id`$\xrightarrow[\text{Hash}]{\text{H1哈希函数}}$`H1(B.id)`得到$\text{Hash}$值$\text{B(n)}$ 
> > >    - 在$\text{Hash}$表$\text{A}$中检索$\text{Hash}$​值$\text{B(n)}$则匹配，那么匹配的行进行$\text{Join}$
> > >
> > > **2️⃣**$\text{Cost=3×NPages(Outer)+3×NPages(Inner)}$​​​ ​
> >
> > ### $\textbf{2.3.4. Join Pipeline}$：减少$\textbf{Cost}$的一种方式
> >
> > > #### $\textbf{2.3.4.1. }$基本概念
> > >
> > > > **1️⃣**$\text{Left-Deep Join Tree}$​：
> > > >
> > > > 0. 多重$\text{Join: }$考虑$\text{Join}$的顺序和类型
> > > >
> > > > 1. $\text{Left-Deep Join Tree: }$是最优$\text{Join}$顺序(快速增长率)，方便在$\text{RAM}$中$\text{Pipeline}$并行处理
> > > >
> > > > 2. 示意图：默认左边的为$\text{Outer Table}$
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240512191103986.png" alt="image-20240512191103986" style="zoom: 43%;" />  
> > > >
> > > > **2️⃣**$\text{Pipeline}$
> > > >
> > > > 1. 概念：
> > > >
> > > >    - $\text{Direct “streaming” in memory}$
> > > >    - $\text{Of the output of one operation as the input of another operation}$
> > > >    - $\text{Without writing output to disk}$
> > > >
> > > > 2. 基于$\text{Left-Deep Join Tree}$的$\text{Pipeline}$​​示例
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240513002106358.png" alt="image-20240513002106358" style="zoom: 67%;" /> 
> > > >
> > > >    | $\textbf{Stage}$ |            $\textbf{Outer Page}$             | $\textbf{Inner Page}$ | $\textbf{Output Page}$                                       |
> > > >    | :--------------: | :------------------------------------------: | :-------------------: | :----------------------------------------------------------- |
> > > >    |    $\text{1}$    |                  $\text{A}$                  |      $\text{B}$       | $\text{A}\bowtie{}\text{B}\xrightarrow{\text{Move to}}\text{Outer Page}$ |
> > > >    |    $\text{2}$    |         $\text{A}\bowtie{}\text{B}$          |      $\text{C}$       | $\text{A}\bowtie{}\text{B}\bowtie{}\text{C}\xrightarrow{\text{Move to}}\text{Outer Page}$ |
> > > >    |    $\text{3}$    | $\text{A}\bowtie{}\text{B}\bowtie{}\text{C}$ |      $\text{D}$       | $\text{A}\bowtie{}\text{B}\bowtie{}\text{C}\bowtie{}\text{D}\xrightarrow{\text{Finally}}\text{Output}$ |
> > >
> > > #### $\textbf{2.3.4.2. Pipeline}$简化计算 
> > >
> > > > **1️⃣**简化计算$\text{1}$：$\text{Heap Scan}$不算$\text{Cost + }$上层$\text{Join}$也不减其$\text{Pipelining}$
> > > >
> > > > 1. 原因：$\text{Heap Scan}$扫描的成本，和其对应减去的$\text{Pipelining}$，都等于对应表大小，互相抵消
> > > >
> > > > 2. 示例$\text{1: Join}$(顶层)开销$\text{=NLJ}$开销
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/49521839130.png" alt="49521839130" style="zoom:30%;" /> 
> > > >
> > > >    - 原本开销：$\text{NLJ+}$两个$\text{Heap Scan}$​ 
> > > >    - $\text{Pipeline: }$减去两个$\text{Heap Scan}$ 
> > > >
> > > > 3. 示例$\text{2: Join}$(顶层)开销$\text{=SMJ}$开销$-\text{RSA(Result Size A)}$，==注意$\text{RSA}$是以$\text{Pages}$为单位==
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/77537735808.png" alt="77537735808" style="zoom:30%;" />  
> > > >
> > > >    - 原本开销：$\text{SMJ+}\text{Heap Scan}$ 
> > > >    - $\text{Pipeline: }$减去$\text{Heap Scan}$，减去$\text{RSA}$ 
> > > >
> > > > **2️⃣**简化计算$\text{2: Heap Scan}$自动忽略所有$\text{Index}$​，来看一个不忽略$\text{Index}$的示例
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240617140212192.png" alt=" " style="zoom: 25%;" /> 
> > > >
> > > > 1. 原本开销：$\text{HJ}$开销$\text{+Index Scan(Test)}$开销 (具体怎么算要看采用哪种$\text{Index}$ )
> > > >
> > > > 2. $\text{Pipeline: }$减去$\text{NPages(Test)}$，减去$\text{RSA}$ 

# $\textbf{3. Query Optimization}$

> ## $\textbf{3.1. Relational Algebra Equivalences}$
>
> > ### $\textbf{3.1.1. Selection/Projection Equivalences}$
> >
> > > **1️⃣**概览
> > >
> > > |               定律                |                             公式                             |          含义           |
> > > | :-------------------------------: | :----------------------------------------------------------: | :---------------------: |
> > > | $\small\text{Selection Cascade}$  | $\sigma_{\text{c}_1 \wedge \cdots \wedge \text{c}_\text{n}}(\text{R})\equiv \sigma_{\text{c}_1}\left(\ldots\left(\sigma_{\text{c}_\text{n}}(\text{R})\right)\right)$ | 多条件筛行$=$每个都筛下 |
> > > | $\small\text{Selection Commute}$  | $\sigma_{\text{c}_\text{1}}\left(\sigma_{\text{c}_2}(\text{R})\right)\equiv \sigma_{\text{c}_2}\left(\sigma_{\text{c}_\text{1}}(\text{R})\right)\equiv{}\sigma_{\text{c}_\text{1} \wedge \text{c}_\text{2}}(\text{R})$ | 先用哪个条件筛选无所谓  |
> > > | $\small\text{Projection Cascade}$ | $\pi_{\text{a}_\text{1}}(R) \equiv \pi_{\text{a}_\text{1}}\left(\ldots\left(\pi_{\text{a}_n}(R)\right)\right)$ | 随便投，最后一下说了算  |
> > >
> > > ⚠️注意事项：$\text{Projection Cascade}$中，假设$\text{A}$是$\text{Attributes}$的集合$\left(\text{A=}\{\text{a}_\text{1},\text{a}_2,...,\text{a}_\text{n}\}\right)$
> > >
> > > 1. 在$\pi{_{\text{A}_\text{1}}}(\ldots(\pi{_{\text{A}}}_\text{n}(\text{R})))$中，必须满足$\text{A}_{\text{n}}\subseteq{}\text{A}_{\text{m}}(\text{n<m})$
> > >
> > > 2. 以$\pi{_{\text{A}_\text{1}}}(\pi{_{\text{A}}}_\text{2}(\text{R}))$为例
> > >
> > >    |     ${\textbf{A}_\textbf{1}}$      |                  ${\textbf{A}_\textbf{2}}$                   |            是否适用$\textbf{Projection Cascade}$             |
> > >    | :--------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> > >    | $\{\text{a}_\text{1},\text{a}_2\}$ |              $\{\text{a}_\text{1},\text{a}_2\}$              | $\text{A}_{\text{1}}\subseteq{}\text{A}_{\text{2}}\to{}\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\text{R}))=\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\text{R})$ |
> > >    | $\{\text{a}_\text{1},\text{a}_2\}$ | $\{\text{a}_\text{1},\text{a}_2,\text{a}_\text{3},\text{a}_4\}$ | $\text{A}_{\text{1}}\subseteq{}\text{A}_{\text{2}}\to{}\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\pi{_{\text{a}_\text{1},\text{a}_\text{2},\text{a}_\text{3},\text{a}_\text{4}}}(\text{R}))=\pi{_{\text{a}_\text{1},\text{a}_\text{2}}}(\text{R})$ |
> > >    | $\{\text{a}_\text{1},\text{a}_4\}$ |     $\{\text{a}_\text{1},\text{a}_2,\text{a}_\text{3}\}$     | $\text{A}_{\text{1}} \not\subseteq{}\text{A}_{\text{2}}$不适用 |
> > >
> > > **2️⃣**示例：关于第$\text{3}$个，注意要让==外部操作($\pi{}\text{/}\sigma$)的$\text{Column}\subseteq$ 里面操作($\pi$)的$\text{Column}$==  
> > >
> > > 1. $\large{}\sigma_{\text{age<18 }\wedge \text{ rating}>5}\text{(Sailors)}\Leftrightarrow\begin{cases} \sigma_{\text{age}<18}\left(\sigma_{\text{rating}>5}\text{(Sailors)}\right)\\\\ \left.\sigma_{\text{rating}>5}\left(\sigma_{\text{age}<18}\text{(Sailors}\right)\right)\end{cases}$ 
> > >
> > > 
> > >
> > > 2. $\large\pi_{\text{age,rating}}(\text{Sailors})\Leftrightarrow \pi_{\text{age,rating}}\left(\pi_{\text{age,rating,sid}}\text{(Sailors)}\right)$ ​
> > >
> > > 
> > >
> > > 3. $\large\begin{cases}\begin{flalign*}& \pi_{\text{age,sid}}( \sigma_{\text{age<18 }\wedge \text{ rating}>5}\text{(Sailors))} &\\& \Updownarrow &\\& \begin{cases}\text{错误的: }\sigma_{\text{age<18 } \wedge \text{ rating}>5}\left(\pi_{\text{age, sid}}(\text{Sailors})\right)\\\\\text{正确的: }\sigma_{\text{age<18 } \wedge \text{ rating}>5}\left(\pi_{\text{age, sid, rating}}(\text{Sailors})\right)\end{cases}&\\\end{flalign*}\end{cases}$ ​
> >
> > ### $\textbf{3.1.2. Join Equivalences}$
> >
> > > |           定律            |                             公式                             |               含义                |
> > > | :-----------------------: | :----------------------------------------------------------: | :-------------------------------: |
> > > | $\text{Join Associative}$ | $\text{R}\bowtie(\text{S} \bowtie \text{T})\equiv(\text{R}\bowtie \text{S})\bowtie \text{T} \quad$ | $\text{Join}$顺序不影响结果(三个) |
> > > | $\text{Join Commutative}$ | $(\text{R}\bowtie \text{S})\equiv(\text{S}\bowtie \text{R})\quad$ | $\text{Join}$顺序不影响结果(两个) |
>
> ## $\text{3.2. }$$\textbf{Query Optimization}$实例
>
> > **1️⃣**$\text{Cross Product}$优化：转化为有条件的$\text{Join}$
>
> > $\large{}\begin{flalign*}& \sigma_{\text{Sailors.sid=Reserves.sid}}(\text{Sailors} \text{×}\text{Reserves}) &\\& \Updownarrow &\\& \text{Sailors} \bowtie_{\text{Sailors.sid=Reserves.sid}} \text{Reserves} &\\& \Updownarrow &\\& \text{Sailors} \bowtie \text{Reserves }\end{flalign*}$ 
>
> > **2️⃣**$\text{Predicate Pushdown: }$先给表格$\sigma{}$筛选$\to{}$降低数据量/减少计算
> >
> > $\large{}\begin{flalign*}
> > & \sigma_{\text{Sailors.age<18}}(\text{Sailors} \bowtie_{\text{Sailors.sid=Reserves.sid}} \text{Reserves}) &\\
> > & \Bigg\Updownarrow {\small{想办法把\text{Join}左边的\text{Sailors}表格变小}} &\\
> > &(\sigma_{\text{Sailors.age<18}}(\text{Sailors})) \bowtie_{\text{Sailors.sid=Reserves.sid}} \text{Reserves} &
> > \end{flalign*}$ 
> >
> > **3️⃣**$\text{Projection Pushdown: }$先给表格$\pi{}$筛选$\to{}$降低数据量/减少计算
> >
> > $\large{}\begin{flalign*}
> > & \pi_{\text{Sailors.sname}}(\text{Sailors} \bowtie_{\text{Sailors.sid=Reserves.sid}} 
> > \text{Reserves})&\\
> > & \Bigg\Updownarrow {\small{想办法把\text{Join}左右的\text{Sailors/Reserves}表格变小}\to{}\text{把两张表中用得到的Column都Project出来}} &\\
> > &\pi_{\text{Sailors.sname}}(\pi_{\text{sname, sid}}
> > (\text{Sailors}) \bowtie_{\text{Sailors.sid=Reserves.sid}} \pi_{\text{sid}}(\text{Reserves})) &
> > \end{flalign*}$​ 

# $\textbf{4. Query Cost}$计算题

> ## $\textbf{4.1. Of One Table}$
>
> > **1️⃣**原理：考虑各种可能的$\text{Query}$途径($\text{Scan/Index}$)$\to{}$选择开销最小的一个
> >
> > 1. 注意永远别忘了算一下$\text{Heap Scan}$，有时候算来算去反倒$\text{Heap Scan}$​​开销最小
> > 2. 除去$\text{Heap Scan}$其它所有类型的开销，都需要先估计$\text{RF }\downarrow{}$​
> >
> > **2️⃣**$\text{RF}$估算汇总
> >
> > |         条件         |                       $\text{RF}$等于                        |               补充说明               |
> > | :------------------: | :----------------------------------------------------------: | :----------------------------------: |
> > | ${}\text{Col=Value}$ |           $\cfrac{\text{Num}}{\text{NKeys(Col)}}$            |           ==处理离散变量==           |
> > |  $\text{Col>Value}$  | $\cfrac{\text{High(Col)}-\text{Value}}{\text{High(Col)}-\text{Low(Col)}}$ |           ==变量必须连续==           |
> > |  $\text{Col<Value}$  | $\cfrac{\text{Value}-\text{Low(Col)}}{\text{High(Col)}-\text{Low(Col)}}$ |           ==变量必须连续==           |
> > |  $\text{Join}$操作   |    $\cfrac{1}{\text{Max[NKeys(Col\_A), NKeys(Col\_B)]}}$     | 主键所在列$\text{JoinCol}$唯一值更多 |
> > |    无任何已知条件    |                  $\text{RF=}\cfrac{1}{10}$                   |                 默认                 |
> >
> > **3️⃣**基于`WHERE + Condition`的$\text{RF}$​​​选取
> >
> > ```sql
> > WHERE day<8/9/94 AND bid=5 AND sid=3
> > ```
> >
> > |      $\textbf{Type}$      | $\textbf{Index}$ | $匹配的\textbf{Prefix}$ |      是否适用于示例的查询       |      $\textbf{RF}$       |
> > | :-----------------------: | :--------------: | :---------------------: | :-----------------------------: | :----------------------: |
> > | $\text{B}^{+}\text{Tree}$ |  `<rname,day>`   |      $\text{N/A}$       | $\text{N}(无匹配\text{Prefix})$ |        $\text{1}$        |
> > | $\text{B}^{+}\text{Tree}$ |  `<day,rname>`   |          `day`          |           $\text{Y}$            |     $\text{RF(day)}$     |
> > | $\text{B}^{+}\text{Tree}$ |   `<day,sid>`    |        `day,sid`        |           $\text{Y}$            | $\text{RF(day)*RF(sid)}$ |
> > |       $\text{Hash}$       |  `<day,rname>`   |          `day`          |  $\text{N(Hash不能范围搜索)}$   |        $\text{1}$        |
> >
> > 1. 索引匹配的谓词：`WHERE + Condition`==必须要==包含$\text{Composite Search Key}$的$\text{Prefix}$
> > 2. $\text{Hash}$不能作$\text{Range Search}$
> >
> > **4️⃣**基于$\text{RF}$的$\text{Scan Cost Formula}$汇总
> >
> > | $\textbf{Structure}$ |     $\textbf{Index}$实现      | $\textbf{Index}$存储/角色 |                             开销                             |
> > | :------------------: | :---------------------------: | :-----------------------: | :----------------------------------------------------------: |
> > |  $\text{Heap File}$  |         $\text{N/A}$          |       $\text{N/A}$        |                      $\text{NPages(R)}$                      |
> > | $\text{Sorted File}$ |         $\text{N/A}$          |       $\text{N/A}$        |       $\log_{2}\text{[NPages(R)]+RF×}\text{NPages(R)}$       |
> > | $\text{index File}$  |   $\text{B}^{+}\text{Tree}$   |     $\text{Primary}$      |                 $\text{树高Height(Index)+1}$                 |
> > | $\text{index File}$  |         $\text{Hash}$         |     $\text{Primary}$      |     $\text{ProbeCost(Index)+1}\xrightarrow{默认为}1.2+1$     |
> > | $\text{index File}$  |   $\text{B}^{+}\text{Tree}$   | ==$\text{Unclustered}$==  | $\text{[NPages(I)+NTuples(R)]×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}$ |
> > | $\text{index File}$  | ==$\text{B}^{+}\text{Tree}$== |  ==$\text{Clustered}$==   | $\text{[NPages(I)+NPages(R)]×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}$ |
> > | $\text{index File}$  |         $\text{Hash}$         | ==$\text{Unclustered}$==  | $\text{NTuples(R)×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}\times{}2.2$ |
> > | $\text{index File}$  |         $\text{Hash}$         |  ==$\text{Clustered}$==   | $\text{NPages(R)×}\prod_\limits{i=1\ldots\text{n}}\text{RF}_{\text{i}}\times{}2.2$ |
>
> ## $\textbf{4.2. Of Multiple Tables}$ 
>
> > **1️⃣**需要考虑的问题
> >
> > |            事项             | 注释                                                         |
> > | :-------------------------: | ------------------------------------------------------------ |
> > | $\text{Join}$所有可能的顺序 | 这不会影响$\text{Join}$结果但会影响开销，一般只考虑$\text{Left-Deep Join Tree}$ |
> > | $\text{Join}$所有可能的算法 | 但是排除最蠢的$\text{Cross Product}$                         |
> >
> > **2️⃣**对$\text{Pipeline}$​的处理
> >
> > 1. $\text{Heap Scan}$不算$\text{Cost + }$上层$\text{Join}$也不减其$\text{Pipelining}$​
> > 2. $\text{Heap Scan}$自动忽略所有$\text{Index}$
> >
> > **3️⃣**$\text{Join Cost}$汇总：注意小表为$\text{Outer}$
> >
> > |       $\textbf{Type}$       | 扫描成本                                                     |
> > | :-------------------------: | :----------------------------------------------------------- |
> > |     $\text{Simple NLJ}$     | $\text{NPages(Outer)+}\text{NTuples(Outer)}\text{×}\text{NPages(Inner)}$ |
> > | $\text{Page-Oriented  NLJ}$ | $\text{NPages(Outer)+}\text{NPagees(Outer)}\text{×}\text{NPages(Inner)}$ |
> > |     $\text{Block  NLJ}$     | $\text{NPages(Outer)+}\text{NPages(Outer)/(Memory-2)}\text{×}\text{NPages(Inner)}$ |
> > |   $\text{Hash Join(HJ)}$    | $\text{[NPages(Outer)+NPages(Inner)]×3}$                     |
> > |        $\text{SMJ}$         | $\text{[NPages(Outer)+NPages(Inner)]×(2×NumPasses+1)}$       |
> >
> > 1.  $\text{NPages(Outer)/(Memory-2)}$要==向上取整==
> > 2.  最优解：$\begin{cases}\text{RAM大小: }\text{NPages(Outer)+2}\\\\\text{开销: Cost=NPages(Outer)+NPages(Inner)}\end{cases}$​​ 
> > 3.  注意$\text{SMJ}$中可能出现$\text{Outer/Inner}$的$\text{NumPass}$​不一样的情况，此时就要分开讨论
>
> ## $\textbf{4.3. Pipeline}$​例题
>
> > ### $\textbf{4.3.0. }$前提条件
> >
> > > :one:$\text{SQL}$代码
> > >
> > > 1. 关系结构
> > >
> > >    ```sql
> > >    Movie(MovieID, name, genre, releasedate, duration, budget)
> > >    Show(ShowID, dateofShow, MovieID(FK), TheatreID(FK), attend, revenue)
> > >    Theatre(TheatreID, name, city, capacity)
> > >    ```
> > >
> > > 2. 查询
> > >
> > >    ```sql
> > >    SELECT *
> > >    FROM Movie AS M, Show AS S, Theatre AS T
> > >    WHERE M.MovieID = S.MovieID
> > >      AND S.TheatreID = T.TheatreID
> > >      AND S.revenue < 60000
> > >      AND M.genre = 'Comedy';
> > >    ```
> > >
> > > :two:参数
> > >
> > > 1. $\text{Data}$​参数
> > >
> > >    |          $\textbf{\\}$          | $\small\textbf{Genre}$ | $\small\textbf{Revenue}$ | $\small\textbf{Movie}$ | $\small\textbf{Show}$ | $\small\textbf{Theatres}$ |
> > >    | :-----------------------------: | :--------------------: | :----------------------: | :--------------------: | :-------------------: | :-----------------------: |
> > >    |    $\small\text{Num/Tuples}$    |      $\text{10}$       |      $\textbf{\\}$       |     $\text{5000}$      |   $\text{600,000}$    |       $\text{100}$        |
> > >    |      $\small\text{Range}$       |     $\textbf{\\}$      |  $\text{[0, 100,000]}$   |     $\textbf{\\}$      |     $\textbf{\\}$     |       $\textbf{\\}$       |
> > >    |   $\small\text{Tuples/Page}$    |     $\textbf{\\}$      |      $\textbf{\\}$       |      $\text{100}$      |      $\text{10}$      |        $\text{10}$        |
> > >    | $\small\Rightarrow\text{Pages}$ |     $\textbf{\\}$      |      $\textbf{\\}$       |      $\text{50}$       |    $\text{60,000}$    |        $\text{10}$        |
> > >
> > > 2. $\text{Index}$​​​参数
> > >
> > >    |    $\textbf{\\}$    |    $\small\textbf{Show.Revenue}$    | $\small\textbf{Movie.MovieID}$ |
> > >    | :-----------------: | :---------------------------------: | :----------------------------: |
> > >    | $\small\text{Type}$ | $\text{Clustered B}^{+}\text{Tree}$ |    $\text{Clustered Hash}$     |
> > >    | $\small\text{Size}$ |          $\text{10Pages}$           |        $\text{10Pages}$        |
> > >
> > > 3. $\text{Join}$​参数
> > >
> > >    | $\textbf{Movie}\bowtie{}\textbf{Show}$ | $\textbf{Theater}\bowtie{}\textbf{Show}$ |
> > >    | :------------------------------------: | :--------------------------------------: |
> > >    |        $\text{100Tuples/Page}$         |         $\text{100Tuples/Page}$          |
> > >
> > > 4. $\text{Sort}$参数：所有关系的排序，$\text{NumPass=2}$ 
> > >
> > > :three:其它：$\text{NLJ}$是$\text{Page-Oriented}$​的
> >
> > ### $\textbf{4.3.1. }$​前提条件
> >
> > > | $\textbf{SQL}$              |   $\textbf{RF}$   | 备注                                                       |
> > > | :-------------------------- | :---------------: | :--------------------------------------------------------- |
> > > | `M.MovieID = S.MovieID`     | $\cfrac{1}{5000}$ | `MovieID`是$\text{Movie(5000}$个$\text{)}$的$\text{PK}$    |
> > > | `S.TheatreID = T.TheatreID` | $\cfrac{1}{100}$  | `TheatreID`是$\text{Theatre(100}$个$\text{)}$的$\text{PK}$ |
> > > | `S.revenue < 60000`         |  $\cfrac{6}{10}$  | 范围$\text{[0, 100,000]}$                                  |
> > > | `M.genre = 'Comedy'`        |  $\cfrac{1}{10}$  | 共十种                                                     |
> >
> > ### $\textbf{4.3.2. Plan A}$​ 
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240617124259352.png" alt="image-20240617124259352" style="zoom: 46%;" /> 
> > >
> > > :one:$\text{RSA}$计算
> > >
> > > 1. $\text{NTuples(M)×NTuples(S)×RF(M}\bowtie\text{S)}=5000×600000×\cfrac{1}{5000}$​  
> > > 2. 结果为$600000\text{Tuples}$，记得转化为$\text{6000Pages (100Tuples/Page)}$​
> > >
> > > :two:$\text{B}$处$\text{NLJ(Page-Oriented)}$计算，默认左边为$\text{Outer}$ 
> > >
> > > 1. $\text{NPages(M)+}\text{NPagees(M)}\text{×}\text{NPages(S)}=50+50×60000$
> > >
> > > 2. 结果为$\text{3000050 I/O}$​  
> > >
> > > :three:$\text{C}$处$\text{SMJ}$计算
> > >
> > > 1. $\text{[RSA+NPages(T)]×(2×NumPasses+1)-RSA=(6000+10)×5-6000}$ 
> > > 2. 结果为$\text{24050 I/O}$​ 
> >
> > ### $\textbf{4.3.2. Plan B}$ 
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240617131414662.png" alt="image-20240617131414662" style="zoom:65%;" />  
> > >
> > > :one:$\text{RSA}$计算
> > >
> > > 1. $\text{NTuples(S)×RF(Revenue)=600000×}\cfrac{6}{10}$ 
> > >
> > > 2. 结果为$\text{360000Tuples}$，即$\text{36000Pages}$ 
> > >
> > > :two:$\text{RSB}$计算
> > >
> > > 1. $\text{NTuples(RSA)×NTuples(T)×RF(S}\bowtie\text{T)}=360000×100×\cfrac{1}{100}$  
> > > 2. 结果为$\text{360000Tuples}$，也就是$\text{3600Pages}$​ 
> > >
> > > :three:$\text{C}$处$\text{Index Scan}$开销，注意是$\text{Clustered B}^{+}\text{Tree}$ 
> > >
> > > 1. $\text{[NPages(Index)+NPages(S)]×RF(Revenue)=(10+60000)×}\cfrac{6}{10}$
> > > 2. 结果为$\text{36006 I/O}$ 
> > >
> > > :four:$\text{D}$处$\text{SMJ}$开销
> > >
> > > 1. $\text{[RSA+NPages(Inner)]×(2×NumPasses+1)-RSA}=(36000+10)×5-36000$
> > > 2. 开销为$\text{144050 I/O}$ 
> > >
> > > :five:$\text{E}$处开销$\text{ = HJ}$开销$\text{ + Index Scan}$开销
> > >
> > > 1. $\text{HJ=[RSB+NPages(M)]×3-RSB-NPages(M)=(3600+50)×2}$
> > > 2. $\text{Index Scan(M)=NPages(M)×RF×2.2}=50×2.2$
> > >    - 注意此处是$\text{Clustered Hash}$，并且$\text{RF=1}$ 
> > >
> > > 3. 结果为$\text{7300+110=7410 I/O}$ 

# $\textbf{Normalization \& Transaction}$ 

# $\textbf{1. Normalization}$

> ## $\textbf{1.1. Normalization}$​定义
>
> > **1️⃣**定义
> >
> > |                          |                  操作                  |                       目的                        |
> > | :----------------------: | :------------------------------------: | :-----------------------------------------------: |
> > |  $\text{Normalization}$  | 一大表格$\xrightarrow{拆分}$若干小表格 | 去除$\text{Redundancies}$从而避免$\text{Anomoly}$ |
> > | $\text{Denormalization}$ | 一大表格$\xleftarrow{拼接}$若干小表格  |              避免频繁的$\text{Join}$              |
> >
> > ⚠️$\text{Fully Normalized = Eliminate All Anomalies}$，一般到$\text{4NF}$才算完全归一化
> >
> > **2️⃣**示例
> >
> > 1. 标准化前
> >
> >    | $\textbf{StuID}$ | $\textbf{SName}$ | $\textbf{CID}$ | $\textbf{CName}$ |
> >    | :--------------: | :--------------: | :------------: | :--------------: |
> >    |    $\text{1}$    |  $\text{John}$   |  $\text{101}$  |  $\text{Math}$   |
> >    |    $\text{2}$    |  $\text{Mary}$   |  $\text{102}$  | $\text{English}$ |
> >    |    $\text{1}$    |  $\text{John}$   |  $\text{103}$  | $\text{Physics}$ |
> >    |    $\text{3}$    |  $\text{Peter}$  |  $\text{101}$  |  $\text{Math}$   |
> >    |    $\text{2}$    |  $\text{Mary}$   |  $\text{103}$  | $\text{Physics}$ |
> >
> > 2. 标准化后
> >
> >    | $\small\textbf{学生表}$ | $\small\textbf{StuID}$ | $\small\textbf{SName}$ | $\small\textbf{课程表}$ | $\small\textbf{CID}$ | $\small\textbf{CName}$ | $\small\textbf{学生-课程表}$ | $\small\textbf{StuID}$ | $\small\textbf{CID}$ |
> >    | :---------------------: | :--------------------: | :--------------------: | :---------------------: | :------------------: | :--------------------: | :--------------------------: | :--------------------: | :------------------: |
> >    |       $\text{\\}$       |       $\text{1}$       |  $\small\text{John}$   |       $\text{\\}$       |     $\text{101}$     |  $\small\text{Math}$   |         $\text{\\}$          |       $\text{1}$       |     $\text{101}$     |
> >    |       $\text{\\}$       |       $\text{2}$       |  $\small\text{Mary}$   |       $\text{\\}$       |     $\text{102}$     | $\small\text{English}$ |         $\text{\\}$          |       $\text{2}$       |     $\text{102}$     |
> >    |       $\text{\\}$       |       $\text{1}$       |  $\small\text{John}$   |       $\text{\\}$       |     $\text{103}$     | $\small\text{Physics}$ |         $\text{\\}$          |       $\text{1}$       |     $\text{103}$     |
> >    |       $\text{\\}$       |       $\text{3}$       |  $\small\text{Peter}$  |       $\text{\\}$       |     $\text{101}$     |  $\small\text{Math}$   |         $\text{\\}$          |       $\text{3}$       |     $\text{101}$     |
> >    |       $\text{\\}$       |       $\text{2}$       |  $\small\text{Mary}$   |       $\text{\\}$       |     $\text{103}$     | $\small\text{Physics}$ |         $\text{\\}$          |       $\text{2}$       |     $\text{103}$     |
> >
> > **3️⃣**$\text{Normalization/Denormalization}$对比
> >
> > |      操作      | $\textbf{Normalization}$，比如$\textbf{A, B}$ | $\textbf{Denormalization}$，比如$\textbf{A}\bowtie{}\textbf{B}$ |
> > | :------------: | :-------------------------------------------: | :----------------------------------------------------------: |
> > |   查询一个表   |                      快                       |                              慢                              |
> > |   查询两个表   |                      慢                       |                              快                              |
> > | 插入/修改/删除 |                     容易                      |                             困难                             |
>
> ## $\textbf{1.2. Database Anomalies}$​异常
>
> > **1️⃣**概述：期末会给你表格，让你用文字描述举例三种$\text{Anomaly}$​ 
> >
> > 1. 示例表格
> >
> >    | $\textbf{Order(PFK)}$ | $\textbf{Item(PFK)}$ | $\textbf{Desc}$ | $\textbf{Qty}$ |
> >    | :-------------------: | :------------------: | :-------------: | :------------: |
> >    |      $\text{27}$      |     $\text{873}$     |  $\text{nut}$   |   $\text{2}$   |
> >    |      $\text{28}$      |     $\text{873}$     |  $\text{nut}$   |  $\text{10}$   |
> >    |      $\text{30}$      |     $\text{495}$     | $\text{washer}$ |  $\text{50}$   |
> >
> > 2. 基本概念
> >
> >    | $\textbf{Anomaly}$ |              含义              | 示例(下表)                                                   |
> >    | :----------------: | :----------------------------: | :----------------------------------------------------------- |
> >    | $\text{Insertion}$ | 插入数据$\text{→}$插入其他数据 | 插入$\text{Item/Desc}\xrightarrow{还需}$插入$\text{Order/Qty}$ |
> >    | $\text{Deletion}$  | 删除数据$\text{→}$删除其他数据 | 删除$\text{Order30}\xrightarrow{引起}$整行删除               |
> >    |  $\text{Update}$   | 更新数据$\text{→}$更新其他数据 | 更新$\text{Item873}$的$\text{Desc}\xrightarrow[有两处\text{Item873}]{引起}$两处$\text{Desc}$更新 |
> >
> > **2️⃣**用$\text{NULL}$来解决$\text{Anomaly:}$ 不能根本解决
> >
> > 1. $\text{Insertion Anomaly}$可能可以，原因在于$\text{PK}$是不能$\text{NULL}$的
> >    - 可以的示例：插入$\text{Order/Item/Desc}\to{}\text{Qty}$为$\text{NULL}$ 
> >    - 不可以的示例：插入$\text{Item/Desc}\to{}\text{Qty}$为$\text{NULL/}\text{Order}$不能为$\text{NULL}$​ 
> > 2. $\text{Deletion Anomaly:}$  同理可能可以，当删除的数据不是$\text{PK}$时，可考虑设为$\text{NULL}$ 
> > 3. $\text{Update Anomaly:}$ 绝对没戏，不可能更新成$\text{NULL}$ 
>
> ## $\textbf{1.3. Functional Dependencies}$​ 
>
> > **1️⃣**概述
> >
> > 1. 定义：$\text{A set of attributes X determines another set of attributes Y uniquely}$ 
> > 2. 符号：$\text{X}\to{}\text{Y}$表示如果知道$\text{X}$就知道$\text{Y}$，比如$\text{Stu-Name}\to{}\text{Stu-FirstName}$​  
> > 3. 性质：
> >    - 依赖恒等式：$\text{X}\to{}\text{X}$ ，$\text{PK}\to{}\text{All Column}$​ 
> >    - 拆分原则$\text{: AB}\to{}\text{CD}\begin{cases}可以拆分为\text{: AB}\to{}\text{C / }\text{AB}\to{}\text{D}\\\\不可拆分为\text{: A}\to{}\text{CD / }\text{B}\to{}\text{CD}\end{cases}\to{}只有右侧可拆分$​ 
> >
> > **2️⃣**有关概念：以$\text{A}(\underline{\text{X}}, \underline{\text{Y}}, \text{Z}, \text{D})$为例
> >
> > 1. $\text{Determinants:}$ 
> >
> >    - 箭头左侧的属性，比如$\underline{\text{X}} ,\underline{\text{Y}}\to{}\text{Z}$中的$\text{XY}$
> >    - 至于这其中$\text{Z}$叫什么就无具体说法
> >
> > 2. $\text{Key/Non-Key}$属性：包含/不包含$\text{PK}$的属性，比如
> >
> >    |       属性类型       |                        含义                        |                     示例                     |
> >    | :------------------: | :------------------------------------------------: | :------------------------------------------: |
> >    |   $\text{Key}$属性   | 包含$\text{PK}$的属性，或者说是$\text{PK}$的一部分 | $\underline{\text{X}} ,\underline{\text{Y}}$ |
> >    | $\text{Non-Key}$属性 |                      其余属性                      |             $\text{Z} ,\text{D}$             |
> >
> > 3. 两种$\text{Dependency}$​​  
> >
> >    |                依赖类型                |                             含义                             |                 示例                 |
> >    | :------------------------------------: | :----------------------------------------------------------: | :----------------------------------: |
> >    | $\text{Partial Functional Dependency}$ | $\text{Key}$属性($\text{PK}$的一部分)$\xrightarrow{决定}\text{Non-Key}$属性 | $\underline{\text{Y}} \to{}\text{Z}$ |
> >    | $\text{Transitive Dependency}$(传递性) |  $\text{Non-Key}$属性$\xrightarrow{决定}\text{Non-Key}$属性  |       $\text{Z} \to{}\text{D}$       |
> >
> > **3️⃣**$\text{Armstrong’s Axioms}$(公理)
> >
> > |      $\textbf{Axioms}$      |                             条件                             | $\Rightarrow$ |               结果                |                 备注                  |
> > | :-------------------------: | :----------------------------------------------------------: | :-----------: | :-------------------------------: | :-----------------------------------: |
> > |    $\text{Reflexivity}$     |                 $\text{B}\subseteq\text{A}$                  | $\Rightarrow$ |  $\text{A} \rightarrow \text{B}$  | 或者说$\text{A}\text{B}\to{}\text{A}$ |
> > | $\text{Augmentation}$(扩展) |                $\text{A}\rightarrow\text{B}$                 | $\Rightarrow$ | $\text{AC} \rightarrow \text{BC}$ |             $\text{N/A}$              |
> > |     $\text{Transitive}$     | $\text{A} \rightarrow \text{B }\land{}\text{ B}\rightarrow \text{C}$ | $\Rightarrow$ |  $\text{A} \rightarrow \text{C}$  |             $\text{N/A}$              |
>
> ## $\textbf{1.4. Normal Form}$​ 
>
> > **0️⃣**$\text{Overview}$ 
> >
> > | $\textbf{Normal Form}$ | $\textbf{Description}$                                       |
> > | :--------------------: | ------------------------------------------------------------ |
> > |      $\text{0NF}$      | 混沌之物$\text{ (Non-Relational)}$                           |
> > |      $\text{1NF}$      | 无$\text{Repeating Groups}$                                  |
> > |      $\text{2NF}$      | 无$\text{Repeating Groups+}\text{Partial Dependency}$        |
> > |      $\text{3NF}$      | 无$\text{Repeating Groups+}\text{Partial Dependency+}\text{Transitive Dependency}$ |
> >
> > **1️⃣**$\text{1NF}$​ 
> >
> > 1. $\text{1NF}$ 的基本特征，==$\text{(}$不满足以下特征的就是$\text{Non-Relational Model)}$== 
> >
> >    - 不能有重复的列
> >
> >    - 不能有$\text{Repeating Groups}$，即表中一个单元($\text{Fill}$)只能有一个数据
> >
> >      (不同单元的数据用逗号隔开，但注意有些数据单元内本就有逗号如$\text{Address}$)
> >
> > 2. $\text{Non-Relational Model→1NF:}$
> >
> >    - 将$\text{Repeating Groups}$从原表中拆分成新表
> >    - 将原表的$\text{PK}\begin{cases}一份保留在原关系\to{}作\text{PK}\\\\一份复制到新关系\to{}作\text{PFK}\end{cases}$ 
> >
> > 3. 示例：注意区分$\underline{\text{PK}}$，$\overline{{\text{FK}}}$，$\overline{\underline{\text{PFK}}}$的表示方法
> >
> >    $\text{Order-Item(}\underline{\color{red}{\text{Order}}}\text{, Cust, (}\underline{\color{green}{\text{Item}}}\text{, Desc, Qty))}\text{→}\begin{cases}
> >    \text{Order(}{\underline{\color{red}{\text{Order}}}}\text{, Cust)} \\\\
> >    \text{Order-Item(}\overline{\underline{\color{red}{\text{Order}}}}\text{, }\underline{\color{green}{\text{Item}}}\text{, Desc, Qty)}
> >    \end{cases}$ 
> >
> > **2️⃣**$\text{2NF}$ 
> >
> > 1. $\text{2NF}$基本特征：$\text{Part of Composite Key}\xrightarrow[❌]{\text{Identify}}\text{Non-key Attribut (NO Partial 依赖)}$  
> > 2. $\text{1NF→2NF:}$ 移除$\text{Partial Dependencies}$​​ 
> >
> >    - 把$\text{Partial Dependencies}$从原关系中剥离出来
> >    - $\text{Partial Dependencies}$的$\text{Determinant}\begin{cases}一份保留在原关系\to{}作\text{PFK}\\\\一份剥离到新关系\to{}作\text{PK}\end{cases}$ 
> > 3. 示例：注意区分$\underline{\text{PK}}$，$\overline{{\text{FK}}}$，$\overline{\underline{\text{PFK}}}$的表示方法
> >
> >    - $假设\text{Order-Item(}\overline{\underline{\text{Order}}}\text{, }\underline{\text{Item}}\text{, Desc, Qty))存在}\begin{cases}\overline{\underline{\text{Order}}},\underline{\text{Item}}\to{}\text{Qty}\\\\\underline{\text{Item}}\to{}\text{Desc (Partial Dependency)}\end{cases}$ 
> >    - $\text{Order-Item}\text{→}
> >      \begin{cases}
> >          \text{Order(}\underline{\color{red}{\text{Order}}}\text{, Cust)} \\\\
> >          \text{Order-Item(}\overline{\underline{\color{red}{\text{Order}}}}\text{, }\underline{\color{green}{\text{Item}}}\text{, Desc, Qty))→}
> >          \begin{cases}
> >              \text{Item(}\underline{\color{green}{\text{Item}}}\text{, Desc)} \\\\
> >              \text{Order-Item(}\overline{\underline{\color{red}{\text{Order}}}}\text{, }\overline{\underline{\color{green}{\text{Item}}}}\text{, Qty)}
> >          \end{cases}
> >      \end{cases}$    
> >
> > **3️⃣**$\text{3NF}$​​ 
> >
> > 1. $\text{3NF}$基本特征：$\text{Non-key Attribut}\xrightarrow[❌]{\text{Identify}}\text{Non-key Attribut (NO Transitive 依赖)}$   
> > 2. $\text{2NF→3NF:}$ 移除$\text{Transitive Dependencies}$​​ 
> >    - 把$\text{Transitive Dependency}$从原关系剥离出来
> >    - $\text{Transitive Dependency}$的$\text{Determinant}\begin{cases}一份保留在原关系\to{}作\text{FK}\\\\一份剥离到新关系\to{}作\text{PK}\end{cases}$ 
> > 3. 示例：注意区分$\underline{\text{PK}}$，$\overline{{\text{FK}}}$，$\overline{\underline{\text{PFK}}}$的表示方法
> >    - 假设$\begin{cases}\underline{\text{Empt}}\to{}\text{Ename, Dept}\\\\{\text{Dept}}\to{}\text{Dname (Transitive Dependency)}\end{cases}$
> >    - $\text{Emp(}\underline{\color{red}{\text{Emp}}}\text{, Ename, Dept, Dname)}\to{}
> >      \begin{cases}
> >          \text{Emp(}\underline{\color{red}{\text{Emp}}}\text{, Ename, }\overline{\color{green}{\text{Dept}})} \\\\
> >          \text{Dept(}\underline{\color{green}{\text{Dept}}}\text{, Dname)}
> >      \end{cases}$   
> >
> > **4️⃣**其他级别的$\text{NF}$==(课外，可不看)== 
> >
> > 1. $\text{BCNF:}$ $\text{Non-key Attribut}\xrightarrow[❌]{\text{Identify}}\text{Part of Composite Key}$​  
> >
> > 2. $\text{4NF:}$解决$\text{Multivalue Dependency}$
> >
> >    - 多值依赖：比如若下列$\begin{cases}\text{M}\xrightarrow{✔️}\text{S}\\\text{M}\xrightarrow{✔️}\text{C}\\\text{C}\xleftrightarrow{❌}\text{S}\end{cases}\to$则存在多值依赖，且记为$\begin{cases}\text{M→→S}\\\\\text{M→→C}\end{cases}$ 
> >
> >      | $\textbf{M}$ | $\textbf{S}$ | $\textbf{C}$ |
> >      | :----------: | :----------: | :----------: |
> >      | $\text{M1}$  | $\text{S1}$  | $\text{C1}$  |
> >      | $\text{M1}$  | $\text{S1}$  | $\text{C2}$  |
> >      | $\text{M1}$  | $\text{S2}$  | $\text{C1}$  |
> >
> >    - 当关系达到$\text{4NF}$时就认为完成$\text{Normalization}$了，已经没有$\text{Duplicates}$​​了
> >
> > 3. $\text{5NF:}$解决$\text{Loss Dependency}$
> >
> >    - 若表格拆开又拼回去不改变原表格($\text{Lossless-Join}$分解)，则表格就有$\text{Loss Dependency}$
> >    - 但实际上不会如此吹毛求疵了

# $\textbf{2. Transaction}$​(事务)

> ## $\textbf{2.1. }$概念与概述
>
> > **1️⃣**$\text{Tansaction}$定义：
> >
> > 1. 定义：数据库操作序列($\text{A logical unit of work}$​)
> >
> > 2. 根本特性：要么一次性执行完$\text{Entirely Completed}$要么$\text{Aborted}$​​​，是不可分割的工作单位 
> >
> >    |        状态        | 操作                                                   |
> >    | :----------------: | :----------------------------------------------------- |
> >    |  $\text{COMMIT}$   | 事务正常结束，完成所有操作(读取数据，更新写回硬盘)     |
> >    | $\text{ROLL BACK}$ | 事务异常结束，中途不再继续运行，已完成的操作也全部撤回 |
> >
> > **2️⃣**$\text{Tansaction}$引入的目的
> >
> > 1. 定义$\text{Unit of Work}$，适用于一个/多个用户
> > 2. $\text{Concurrent Access}$，允许多个$\text{Command}$交织执行，适用于多个用户
> >
> > **3️⃣**$\text{Tansaction}$种类
> >
> > 1. $\text{Implicit Transaction:}$ 单独一句$\text{DML/DDL}$就是$\text{Transaction}$​ 
> >
> >    ```sql
> >    SELECT / INSERT / DELETE / CREATE / ALTER / DROP -- 比如一个SELECT就是一个事务
> >    ```
> >
> > 2. $\text{User-Defined Transaction:}$ 需要关键字`BEGIN/COMMIMT/RILLBACK` 
> >
> >    ```sql
> >     -- 从SATRT到COMMIT不论中间多少语句，都只算一个Transaction
> >    START TRANSACTION; -- 开始事务,也可以用BEGIN TRANSACTION
> >     -- SQL 语句1
> >     -- SQL 语句2
> >    COMMIT; -- 提交事务
> >    ROLLBACK; -- 或者如果发生错误，回滚事务
> >    ```
> >
> > **4️⃣**$\text{Transaction}$性质$\text{: ACID}$​ 
> >
> > |         性质         | 描述                                                         |
> > | :------------------: | :----------------------------------------------------------- |
> > |  $\text{Atomicity}$  | $\text{Transaction}$是不可分割的逻辑工作单位(执行完$\text{Or}$回退) |
> > | $\text{Consistancy}$ | $\text{Transaction}$执行前后数据库都是一致状态$\text{+}$多用户读取数据时应看到相同值 |
> > |  $\text{Isolation}$  | 运行结束前一个$\text{Transaction}$的改变对其他$\text{Transaction}$不可见 |
> > | $\text{Durability}$  | 一旦$\text{Transaction}$执行完其对数据的改变永久有效(即使系统崩溃) |
>
> ## $\textbf{2.2. Serializability}$ 
>
> > **1️⃣**$\text{Transaction}$的交叉执行($\text{Interleaved}$)：注意$\text{Transaction}\xrightarrow{缩写}\text{TXN}$
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240526204243601.png" alt="image-20240526204243601" style="zoom:56%;" /> 
> >
> > |    $\textbf{Execution}$种类     |             含义             |           备注           |
> > | :-----------------------------: | :--------------------------: | :----------------------: |
> > | $\text{Concurrent/Interleaved}$ | 不同$\text{TXN}$交叉并行执行 | 实际$\text{TXN}$执行方式 |
> > |    $\text{Serial Execution}$    |  不同$\text{TXN}$一个个执行  | 最安全但最低效的执行方式 |
> >
> > **2️⃣**示例
> >
> > 1. $\text{Serial Execution}$​的读写操作
> >
> >    | $\textbf{TXN}$ | $\textbf{Stage1}$ | $\textbf{Stage2}$ | $\textbf{Stage3}$ | $\textbf{Stage4}$ |
> >    | :------------: | :---------------: | :---------------: | :---------------: | :---------------: |
> >    | $\text{TXN1}$  |   $\text{R(A)}$   |   $\text{W(A)}$   |    $\text{\\}$    |    $\text{\\}$    |
> >    | $\text{TXN2}$  |    $\text{\\}$    |    $\text{\\}$    |   $\text{R(B)}$   |   $\text{W(B)}$   |
> >
> > 2. $\text{Concurrent Execution}$的读写操作：==黄标==为$\text{Concurrent Execution}$部分
> >
> >    | $\textbf{TXN}$ | $\textbf{Stage1}$ | ==$\textbf{Stage2}$== | $\textbf{Stage3}$ | ==$\textbf{Stage4}$== |
> >    | :------------: | :---------------: | :-------------------: | :---------------: | :-------------------: |
> >    | $\text{TXN1}$  |   $\text{R(A)}$   |     $\text{R(A)}$     |   $\text{W(A)}$   |     $\text{W(A)}$     |
> >    | $\text{TXN2}$  |    $\text{\\}$    |     $\text{R(B)}$     |    $\text{\\}$    |     $\text{W(B)}$     |
> >
> >
> > :three:$\text{Serializable}$ 
> >
> > 1. 含义：多个$\text{TXN}$是$\text{Serializable}\xLeftrightarrow{\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }}$(多个$\text{TXN}$并行执行效果 $ \equiv\text{Serial Execution}$执行效果)
> >
> > 2. 上例中：若$\text{AB}$的读写互不干扰，则两表最终结果一样，则$\text{TXN1/2}$是$\text{Serializable}$ 
>
> ## $\textbf{2.3. Concurrent Execution}$的问题与解决
>
> > ### $\textbf{2.3.1. Concurrent Access Conflict}$ 
> >
> > > 🤔出现问题的根本原因：多$\text{TXN}$操作同一$\text{Object}$，并且其中至少一个操作是$\text{Write}$ 
> > >
> > > **1️⃣**$\text{Loss Update Problem:}$ 多次针对一个$\text{Object}$写，$\text{Object}$为最后一次写的内容
> > >
> > > | $\textbf{TXN}$ | $\textbf{Stage1}$ | $\textbf{Stage2}$ | $\textbf{Stage3}$ | $\textbf{Stage4}$ | $\textbf{Stage5}$ |
> > > | :------------: | :---------------: | :---------------: | :---------------: | :---------------: | :---------------: |
> > > |  $\text{Bob}$  |   $\text{R(A)}$   |    $\text{\\}$    |   $\text{W(A)}$   |    $\text{\\}$    |  $\text{COMMIT}$  |
> > > | $\text{Alice}$ |    $\text{\\}$    |   $\text{R(A)}$   |    $\text{\\}$    |   $\text{W(A)}$   |  $\text{COMMIT}$  |
> > >
> > > - 最后结果是$\text{Alice}$​写入内容
> > >
> > > **2️⃣**$\text{Uncommitted Data/Dirty Read Problem:}$ 某$\text{TXN}$回退导致未交付数据被后面$\text{TXN}$使用
> > >
> > > | $\textbf{TXN}$ | $\textbf{Stage1}$ | $\textbf{Stage2}$ | $\textbf{Stage3}$ | $\textbf{Stage4}$ | $\textbf{Stage5}$  |
> > > | :------------: | :---------------: | :---------------: | :---------------: | :---------------: | :----------------: |
> > > |  $\text{Bob}$  |   $\text{R(A)}$   |   $\text{W(A)}$   |    $\text{\\}$    |    $\text{\\}$    | $\text{ROLL BACK}$ |
> > > | $\text{Alice}$ |    $\text{\\}$    |    $\text{\\}$    |   $\text{R(A)}$   |   $\text{W(A)}$   |  $\text{COMMIT}$   |
> > >
> > > - $\text{W(A)}$数据并未$\text{COMMIT}$但却被$\text{Alice}$​使用
> > >
> > > **3️⃣**$\text{Inconsistent Retrieval Problem:}$ 一个$\text{TXN}$在聚合函数操作$\text{+}$另一个$\text{TXN}$在$\text{Update}$​数据
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240526220018050.png" alt="image-20240526220018050" style="zoom: 50%;" />  
> > >
> > > - 理论上，可以合理安排$\text{Interleaved}$​来避免冲突
> >
> > ### $\textbf{2.3.2. Concurrency Control Method:}$ 解决冲突
> >
> > > #### $\textbf{2.3.2.0. }$概述
> > >
> > > > **1️⃣**总体思路：合理安排读写操作的顺序
> > > >
> > > > **2️⃣**基本思路
> > > >
> > > > |      基本思路       | 操作                                    |       备注        |
> > > > | :-----------------: | :-------------------------------------- | :---------------: |
> > > > | $\text{Pesimistic}$ | 先检查有无问题，以选择不执行/更正后执行 | 比如$\text{Lock}$ |
> > > > | $\text{Optimistic}$ | 先一股脑执行，执行完后有问题再回来更正  |   此课程不涉及    |
> > > >
> > > > - $\text{Optimistic}$方法：$\text{Timestamping}$和$\text{Optimistic Concurrency Control}$ 
> > >
> > > #### $\textbf{2.3.2.1.  Lock Method}$ 
> > >
> > > > **1️⃣**总体思路：
> > > >
> > > > 1. 逻辑上：通过让$\text{TXN}$持有$\text{Lock}$，让当前$\text{TXN}$霸占某个数据项($\text{Exclusive Use of Data}$) 
> > > > 2. 物理上：在$\text{RAM}$上设置$\text{Lock Manager}$来管理$\text{Lock}$的数据
> > > >
> > > > **2️⃣**$\text{Level/Gradularity}$(精细度)$\text{of Lock}$ 
> > > >
> > > > |                   $\textbf{Gradularity}$                    |             含义             |                          使用频率                          |
> > > > | :---------------------------------------------------------: | :--------------------------: | :--------------------------------------------------------: |
> > > > | <span style="color:#99FF00;">$\text{Database-Level}$</span> |        锁住整个数据库        | <span style="color:#99FF00;">$\text{Slightly Rare}$</span> |
> > > > |  <span style="color:#FF9900;">$\text{Table-Level}$</span>   |         锁住一张表格         |  <span style="color:#FF9900;">$\text{Very Common}$</span>  |
> > > > |   <span style="color:#FFCC00;">$\text{Page-Level}$</span>   | 锁住一页(一张表存储在多页中) |    <span style="color:#FFCC00;">$\text{Common}$</span>     |
> > > > |   <span style="color:#FF3300;">$\text{Row-Level}$</span>    |        锁住表中的一行        |  <span style="color:#FF3300;">$\text{Most Common}$</span>  |
> > > > |  <span style="color:#00FF00;">$\text{Field-Level}$</span>   |       锁住表中的某个值       |     <span style="color:#00FF00;">$\text{Rare}$</span>      |
> > > >
> > > > 1. 理想情况$\text{Field-Level}$最好，但其$\text{Lock}$​过于复杂($\text{High Overhead}$)，反倒最不常用
> > > > 2. 在$\text{MySQL}$中，如果多层级$\text{Lock}$被应用，则需要$\text{Intention Lock}$​​来辅助
> > > >
> > > > **3️⃣**$\text{Types of Lock}$​​ 
> > > >
> > > > 1. $\text{Binary Lock:}$ 仅$\text{Lock/Unlock}$两种状态，只要用到数据(不论读写)都是$\text{Lock}$ 
> > > >
> > > > 2. $\text{Shared and Exclusive Locks(Read and Write Locks)}$
> > > >
> > > >    - 描述
> > > >
> > > >      |        $\textbf{Type}$        |                适用情况                 |         要求          |
> > > >      | :---------------------------: | :-------------------------------------: | :-------------------: |
> > > >      |   $\text{Share/Read Lock}$    |        $\text{Read Table Only}$         | 无$\text{Write Lock}$ |
> > > >      | $\text{Exclusive/Write Lock}$ | $\text{Update(Write) Records in Table}$ |  无其他$\text{Lock}$  |
> > > >
> > > >    - 要求表，==这张表很重要== 
> > > >
> > > >      |          操作           | 已有$\textbf{S-Lock}$ | 已有$\textbf{X-Lock}$ |
> > > >      | :---------------------: | :-------------------: | :-------------------: |
> > > >      | 申请新的$\text{S-Lock}$ |           ✔️           |           ❌           |
> > > >      | 申请新的$\text{X-Lock}$ |           ❌           |           ❌           |
> > > >
> > > > **4️⃣**上锁与解锁$\text{Two Phase Policy}$ 
> > > >
> > > > 1. $\text{Two Phase Policy:}$​​ 
> > > >
> > > >    |   $\textbf{Phase}$    | 描述                                                    |
> > > >    | :-------------------: | ------------------------------------------------------- |
> > > >    |  $\text{Grow Phase}$  | 给$\text{Object}$一个个上锁                             |
> > > >    | $\text{Shrink Phase}$ | 给$\text{Object}$一个个解锁，当解锁开始时就不能再上锁了 |
> > > >
> > > > 2. $\text{Strict Two Phase Policy:}$​ 相比于非$\text{Strict}$有如下改变
> > > >
> > > >    - 只有在$\text{Transaction COMMIT}$后才能解锁
> > > >    - 解锁不是一个个解锁，而是一次性全部解锁
> > >
> > > #### $\textbf{2.3.2.2. Unresolvable Problem For Lock: Deadlock}$​ 
> > >
> > > > **1️⃣**基本思路
> > > >
> > > > |      基本思路       | 操作                                              |     备注     |
> > > > | :-----------------: | ------------------------------------------------- | :----------: |
> > > > | $\text{Pesimistic}$ | 执行前先检查是否死锁，如果死锁就不执行/更正后执行 | $\text{N/A}$ |
> > > > | $\text{Optimistic}$ | 先一股脑执行，每隔一段时间检测是否锁死并加以解决  |  此处不涉及  |
> > > >
> > > > **2️⃣**死锁$\text{Detection}$的方法：$\text{Wait-For Graph}$ 
> > > >
> > > > 1. 用圈代表$\text{TXN}$，用箭头表示等待($\text{A}\to{}\text{B}$表示$\text{A}$在等待$\text{B}$释放某个$\text{Lock}$)
> > > >
> > > > 2. 当$\text{Graph}$构成闭环$\to{}$​死锁，但注意成环不代表闭环，闭环是要形成环路(下图示例)
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240527033215115.png" alt="image-20240527033215115" style="zoom: 33%;" /> 
> > > >
> > > > **3️⃣**死锁检测例题$\text{1:}$ 序列$\text{1}$如下，$\text{C=COMMIT}$，其次不必在意一个$\text{Object}$可以不读就写
> > > >
> > > > | 序列: $\textbf{TXN}$ |    $\textbf{1}$     |    $\textbf{2}$     |    $\textbf{3}$     |    $\textbf{4}$     |    $\textbf{5}$     |   $\textbf{6}$   |   $\textbf{7}$   |   $\textbf{8}$   | $\textbf{9}$ |
> > > > | :------------------: | :-----------------: | :-----------------: | :-----------------: | :-----------------: | :-----------------: | :--------------: | :--------------: | :--------------: | :----------: |
> > > > |  序列$\text{1: T1}$  | $\small\text{R(Z)}$ |     $\text{\\}$     |     $\text{\\}$     |     $\text{\\}$     | $\small\text{W(Y)}$ | $\small\text{C}$ |   $\text{\\}$    |   $\text{\\}$    | $\text{\\}$  |
> > > > |  序列$\text{1: T2}$  |     $\text{\\}$     | $\small\text{W(X)}$ | $\small\text{W(Y)}$ |     $\text{\\}$     |     $\text{\\}$     |   $\text{\\}$    | $\small\text{C}$ |   $\text{\\}$    | $\text{\\}$  |
> > > > |  序列$\text{1: T3}$  |     $\text{\\}$     |     $\text{\\}$     |     $\text{\\}$     | $\small\text{W(Y)}$ |     $\text{\\}$     |   $\text{\\}$    |   $\text{\\}$    | $\small\text{C}$ | $\text{\\}$  |
> > > >
> > > > 1. $\text{Lock}$请求时序：$\text{T}_{1,2,3}$对$\text{X-Lock(Y)}$的请求构成等待 
> > > >
> > > >    |                        $\textbf{T1}$                         |                    $\textbf{T2}$                    |                        $\textbf{T3}$                         |
> > > >    | :----------------------------------------------------------: | :-------------------------------------------------: | :----------------------------------------------------------: |
> > > >    |       $\text{R(Z)}\xrightarrow{获得}\text{S-Lock(Z)}$        |                     $\text{\\}$                     |                         $\text{\\}$                          |
> > > >    |                         $\text{\\}$                          |   $\text{W(X)}\xrightarrow{获得}\text{X-Lock(X)}$   |                         $\text{\\}$                          |
> > > >    |                         $\text{\\}$                          | ==$\text{W(Y)}\xrightarrow{获得}\text{X-Lock(Y)}$== |                         $\text{\\}$                          |
> > > >    |                         $\text{\\}$                          |                     $\text{\\}$                     | ==$\text{W(Y)}\xrightarrow[\text{T}_{2}释放]{等待}\text{X-Lock(Y)}$== |
> > > >    | ==$\text{W(Y)}\xrightarrow[\text{T}_{2,3}释放]{等待}\text{X-Lock(Y)}$== |                     $\text{\\}$                     |                         $\text{\\}$                          |
> > > >
> > > > 2. 对于$\text{T}_{1,2,3}$的$\text{Wait-For Graph}\xrightarrow{不闭环}$​不构成死锁
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240527033243392.png" alt="image-20240527033243392" style="zoom:35%;" />  
> > > >
> > > > 3. $\text{TXN}$顺序：$\text{T2}$完成$\xrightarrow[\text{T3}获得\text{X-Lock(Y)}]{\text{T}_2\text{ COMMIT}释放\text{X-Lock(Y)}}\text{T3}$完成$\xrightarrow[\text{T1}获得\text{X-Lock(Y)}]{\text{T}_3\text{ COMMIT}释放\text{X-Lock(Y)}}\text{T1}$完成
> > > >
> > > > **4️⃣**死锁检测例题$\text{2}$ 
> > > >
> > > >
> > > > | 序列: $\textbf{TXN}$ |    $\textbf{1}$     |    $\textbf{2}$     |    $\textbf{3}$     |    $\textbf{4}$     |    $\textbf{5}$     |    $\textbf{6}$     |   $\textbf{7}$   |   $\textbf{8}$   |   $\textbf{9}$   |
> > > > | :------------------: | :-----------------: | :-----------------: | :-----------------: | :-----------------: | :-----------------: | :-----------------: | :--------------: | :--------------: | :--------------: |
> > > > |  序列$\text{2: T1}$  |     $\text{\\}$     | $\small\text{W(Y)}$ |     $\text{\\}$     |     $\text{\\}$     |     $\text{\\}$     | $\small\text{W(X)}$ | $\small\text{C}$ |   $\text{\\}$    |   $\text{\\}$    |
> > > > |  序列$\text{2: T2}$  | $\small\text{W(X)}$ |     $\text{\\}$     |     $\text{\\}$     |     $\text{\\}$     | $\small\text{W(Y)}$ |     $\text{\\}$     |   $\text{\\}$    | $\small\text{C}$ |   $\text{\\}$    |
> > > > |  序列$\text{2: T3}$  |     $\text{\\}$     |     $\text{\\}$     | $\small\text{R(Z)}$ | $\small\text{W(Z)}$ |     $\text{\\}$     |     $\text{\\}$     |   $\text{\\}$    |   $\text{\\}$    | $\small\text{C}$ |
> > > >
> > > > 1. $\text{Lock}$请求时序：$\text{T}_{1,2,3}$对$\text{X-Lock(Y)}$​的
> > > >
> > > >    |                        $\textbf{T1}$                         |                        $\textbf{T2}$                         |                  $\textbf{T3}$                  |
> > > >    | :----------------------------------------------------------: | :----------------------------------------------------------: | :---------------------------------------------: |
> > > >    |                         $\text{\\}$                          | <span style="color:#FF3300;">$\text{W(X)}\xrightarrow{获得}\text{X-Lock(X)}$</span> |                   $\text{\\}$                   |
> > > >    |     ==$\text{W(Y)}\xrightarrow{获得}\text{X-Lock(Y)}$==      |                         $\text{\\}$                          |                   $\text{\\}$                   |
> > > >    |                         $\text{\\}$                          |                         $\text{\\}$                          | $\text{R(Z)}\xrightarrow{获得}\text{S-Lock(Z)}$ |
> > > >    |                         $\text{\\}$                          |                         $\text{\\}$                          | $\text{W(Z)}\xrightarrow{获得}\text{X-Lock(Z)}$ |
> > > >    |                         $\text{\\}$                          | ==$\text{W(Y)}\xrightarrow[\text{T}_{1}释放]{等待}\text{X-Lock(Y)}$== |                   $\text{\\}$                   |
> > > >    | <span style="color:#FF3300;">$\text{W(X)}\xrightarrow[\text{T}_{2}释放]{等待}\text{X-Lock(X)}$</span> |                         $\text{\\}$                          |                   $\text{\\}$                   |
> > > >
> > > > 2. 对于$\text{T}_{1,2,3}$的$\text{Wait-For Graph}\xrightarrow{闭环}$​构成了死锁
> > > >
> > > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240527035828981.png" alt="image-20240527035828981" style="zoom:35%;" />  
> > > >
> > > > 3. $\text{TXN}$顺序：只有$\text{T}_3$​可以完成
> > > >
> > > > **5️⃣**一些课外补充
> > > >
> > > > 1. 死锁的解决：选择一个死锁的$\text{TXN}$去(部分)回退，至于是哪个可以根据$\text{Age}$/负载等
> > > > 2. 死锁的预防：$\text{Wait-die and Wound-die Policy}$​ 
> > >
> > > #### $\textbf{2.3.2.3. Concurrency Control Method}$ 
> > >
> > > > **1️⃣**$\text{TXN}$序列：是一个$\text{Loss Update Problem}$问题
> > > >
> > > > | $\textbf{Time}$ | $\textbf{t=0}$ | $\textbf{t=1}$ | $\textbf{t=2}$ | $\textbf{t=3}$ | $\textbf{Final}$ |
> > > > | :-------------: | :------------: | :------------: | :------------: | :------------: | :--------------: |
> > > > |   $\text{T1}$   | $\text{R(A)}$  |  $\text{\\}$   |  $\text{\\}$   | $\text{W(A)}$  | $\text{COMMIT}$  |
> > > > |   $\text{T2}$   |  $\text{\\}$   | $\text{R(A)}$  | $\text{W(A)}$  |  $\text{\\}$   | $\text{COMMIT}$  |
> > > >
> > > > **2️⃣**用$\text{Binary Lock}$​​​​​解决
> > > >
> > > > 1. 规则：
> > > >
> > > >    |         操作          | 已占用$\textbf{Lock}$ |
> > > >    | :-------------------: | :-------------------: |
> > > >    | 申请新的$\text{Lock}$ |           ❌           |
> > > >
> > > > 2. 执行
> > > >
> > > >    |                阶段                |                操作                 |
> > > >    | :--------------------------------: | :---------------------------------: |
> > > >    |          $\text{T1-R(A)}$          |     获取$\text{Lock(A)}$并执行      |
> > > >    | $\text{T2-R(A)}$和$\text{T2-W(A)}$ | 等待$\text{T1}$释放$\text{Lock(A)}$ |
> > > >    |          $\text{T1-W(A)}$          |     已有$\text{Lock(A)}$并执行      |
> > > >    |          $\text{COMMIT}$           |      只有$\text{W(A)}$完成执行      |
> > > >
> > > > **3️⃣**$\text{Shared and Exclusive Locks(Read and Write Locks)}$​​解决
> > > >
> > > > 1. 规则
> > > >
> > > >    |          操作           | 已占用$\textbf{S-Lock}$ | 已占用$\textbf{X-Lock}$ |
> > > >    | :---------------------: | :---------------------: | :---------------------: |
> > > >    | 申请新的$\text{S-Lock}$ |            ✔️            |            ❌            |
> > > >    | 申请新的$\text{X-Lock}$ |            ❌            |            ❌            |
> > > >
> > > > 2. 执行
> > > >
> > > >    |       阶段       | 操作                                                         |
> > > >    | :--------------: | :----------------------------------------------------------- |
> > > >    | $\text{T1-R(A)}$ | 获取$\text{S-Lock(A)-1}$                                     |
> > > >    | $\text{T2-R(A)}$ | 获取$\text{S-Lock(A)-2}$ (在已有$\text{S-Lock}$情况下在获取一个$\text{S-Lock}$是$\text{OK}$的) |
> > > >    | $\text{T2-W(A)}$ | 等待$\text{T1}$释放$\text{X-Lock(A)-1}$                      |
> > > >    | $\text{T1-W(A)}$ | 等待$\text{T2}$释放$\text{X-Lock(A)-2}$                      |
> > > >    | $\text{COMMIT}$  | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240527045640074.png" alt="image-20240527045640074" style="zoom: 25%;" />$\implies$死锁，谁都$\text{COMMIT}$不了 |
>
> ## $\textbf{2.4. Transaction Log}$​ 
>
> > **1️⃣**含义：记录数据库事务变化的日志，包括
> >
> > 1. $\text{Transaction}$开始的记录
> > 2. 每个$\text{SQL}$语句的详细信息
> > 3. $\text{Transaction COMMIT}$的记录
> >
> > **2️⃣**作用：将所有更改恢复到最后一次$\text{COMMIT}$的状态

# $\textbf{Rest of DB}$ 

# $\textbf{1. Data Administration}$​ 

> ## $\textbf{1.1. Overview}$ 
>
> >**1️⃣**$\text{Capacity Planning:}$ 预测未来$\text{DB}$的负荷$\text{→}$预测系统会何时饱和$\text{→}$尽可能延长饱和的时间
> >
> >**2️⃣**大小计算
> >
> >|    $\textbf{Size}$     | 描述                                                         |
> >| :--------------------: | :----------------------------------------------------------- |
> >| $\text{Database Size}$ | $\text{Sum of all Table sizes}$                              |
> >|  $\text{Table Size}$   | $\text{Number of rows(Cardinality) * Average row width(Degree)}$ |
> >|   $\text{Row Size}$    | $\text{Sum of sizes of all attributes}$                      |
>
> ## $\textbf{1.2. }$​例题
>
> > **1️⃣**$\text{DB}$更新数据
> >
> > |        表格         |   起始量   | 更新                                                         |
> > | :-----------------: | :--------: | :----------------------------------------------------------- |
> > | $\text{Suppliers}$  | $\text{0}$ | 新增$\text{1000 Suppliers/Year}$                             |
> > | $\text{Puerchases}$ | $\text{0}$ | 新增$\text{10000 Purchases/Year}$，$\text{1-Purchase}\xleftrightarrow{对应}\text{10-PurchaseItem}$ |
> > |   $\text{Items}$    | $\text{0}$ | 新增$\text{2000 Items/Year}$                                 |
> >
> > - $\text{PurchaseItem}$作为联结实体，起始量也一定是$\text{0}$ 
> >
> > **2️⃣**$\text{Size of Row}$ 
> >
> > |      $\textbf{Table Name}$      | $\textbf{Size of Row(Byte)}$ |
> > | :-----------------------------: | :--------------------------: |
> > |  $\text{Purchase(Normalized)}$  |         $\text{50}$          |
> > | $\text{Purchase(Denormalized)}$ |         $\text{110}$         |
> > |        $\text{Supplier}$        |         $\text{50}$          |
> > |      $\text{PurchaseItem}$      |         $\text{12}$          |
> > |          $\text{Item}$          |         $\text{50}$          |
> >
> > **3️⃣**$\text{Normalized}$模式下：数据库运行两年后，会占用多大存储空间$\text{ ?}$ 
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240527193246239.png" alt="image-20240527193246239" style="zoom: 31%;" />  
> >
> > - $\text{2×1000×50+2×10000×50+2×100000×12+2×2000×50=3700000Bytes=3613.28KB}$ 
> >
> > **4️⃣**$\text{Denoemalized}$模式下：数据库运行两年后，会占用多大存储空间$\text{ ?}$ 
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240527194017901.png" alt="image-20240527194017901" style="zoom: 29%;" /> 
> >
> > - $\text{2×10000×110+2×100000×12+2×2000×50=4800000Bytes=4687.5KB}$  

# $\textbf{2. DB Backup}$​ 

> ## $\textbf{2.1. Overview}$ 
>
> > **1️⃣**可能出现数据丢失的$\text{Fails}$ 
> >
> > |    $\textbf{Failure Type}$    | $\textbf{Description}$                          |
> > | :---------------------------: | ----------------------------------------------- |
> > |  $\text{Statement failure}$   | 语法错误                                        |
> > | $\text{User Process failure}$ | 处理过程中的错误，比如$\text{Power Outage}$断电 |
> > |   $\text{Network failure}$    | 断网                                            |
> > |      $\text{User error}$      | 用户手欠导致的错误，比如误删掉某个表格          |
> > |    $\text{Memory failure}$    | 内存出错                                        |
> > |    $\text{Media Failure}$     | 硬盘出错                                        |
> >
> > **2️⃣**$\text{Backup}$​​的意义就在于，出现上述情况时防止数据丢失
>
> ## $\textbf{2.2. Backup}$种类
>
> > **1️⃣**$\text{Backup}$种类：$\text{Physical \& Logical}$​ 
> >
> > 1. $\text{Physical \& Logical}$性质概述
> >
> >    |    $\textbf{Item}$    | $\textbf{Physical}$                                        | $\textbf{Logical}$     |
> >    | :-------------------: | :--------------------------------------------------------- | :--------------------- |
> >    | $\text{Backup}$的内容 | 实体表格($\text{File+Dictionary}$)                         | $\text{SQL}$代码       |
> >    |      数据库状态       | 希望$\text{Offline(Cold Backup)}$，但也可以$\text{Online}$ | 必须$\text{Online}$    |
> >    |       备份速度        | 快(直接复制文件表格，无需转成$\text{SQL}$)                 | 慢(需转成$\text{SQL}$) |
> >    | $\text{Log}$日志文件  | 包含在备份中                                               | 不包含在备份中         |
> >    |     关于系统配置      | 备份后的文件要在相似的系统配置上才能运行                   | 备份独立于具体的机器   |
> >
> > 2. 如何选择
> >
> >    |                情景                 |       选择        |
> >    | :---------------------------------: | :---------------: |
> >    |   需要$\text{Time-Critical}$要求    | $\text{Pyhsical}$ |
> >    | $\text{DB}$需要在不同硬件配置上运行 | $\text{Logical}$  |
> >
> >    如果是就选择
> >
> > **2️⃣**$\text{Backup Option}$​
> >
> > |  $\textbf{Option}$   | 描述                                   | 适用情景                                     |
> > | :------------------: | -------------------------------------- | -------------------------------------------- |
> > |   $\text{Online}$    | 备份时数据库要在线($\text{Available}$) | 数据库$\text{24h×7day}$不停歇工作，逻辑备份  |
> > |   $\text{Offline}$   | 备份时数据库下线($\text{Shut Down}$)   | 物理备份                                     |
> > |    $\text{Full}$     | 备份起始于$\text{DB}$诞生              | 数据库不常用(周末)                           |
> > | $\text{Incremental}$ | 备份起始于上次备份完                   | 数据库需要频繁使用(工作日)                   |
> > |   $\text{Onsite}$    | 备份在本地==(更快)==                   | $\text{Time-Critical}$，需要快速导入备份数据 |
> > |   $\text{Offsite}$   | 备份在云端                             | 上传云端要有意义                             |
> >
> > 1. $\text{Full \& Incremental}$​​通常会混用
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240527223901294.png" alt="image-20240527223901294" style="zoom:50%;" />  
> >
> > 2. $\text{Offsite}$上传云端有意义的实例：
> >
> >    - 有多个工厂共用一套$\text{DB}$时，可以本地也可以云端
> >    - 只有一个工厂时，则必须上传云端，以防自然灾害数据损失

# $\textbf{3. Data Warehouse}$​ 

> ## $\textbf{3.1. Data Warehouse}$概述
>
> > **1️⃣**两种$\text{DB}$​ 
> >
> > 1. 概述
> >
> >    |   $\textbf{DB Type}$   | 适用情况                                                     |
> >    | :--------------------: | ------------------------------------------------------------ |
> >    | $\text{Transactional}$ | 涉及表格少(不需要太多$\text{Join}$)，比如$\text{Relational DB}$ |
> >    | $\text{Informational}$ | 涉及表格多，解决$\text{Analytical}$问题                      |
> >
> > 2. 二者间的关系：$\text{Trans DB}\xrightarrow{\text{Data Warehouse}}\text{Info DB}$ 
> >
> > 3. $\text{Informantional}$数据库是$\text{Read Only}$​的，如果硬要修改则遵从以下步骤
> >
> >    - 从$\text{Info DB}$回到$\text{Trans DB}$ 
> >
> >    - 修改$\text{Trans DB}$，然后将修改$\text{ETL}$到$\text{Info DB}$​ 
> >
> >      $更改\text{Trans DB}\xrightarrow[\text{ETL/DBA Process}]{\begin{cases}\text{ETL: 即Extract/Transform/Load过程}\\\\\text{DBA: 即DB Administration(人为干预)}\end{cases}}更改\text{Info DB/Data Warehouse}$ 
> >
> > **2️⃣**$\text{Data Warehouse}$特点
> >
> > | 特点                                | 描述                                                    |
> > | :---------------------------------- | ------------------------------------------------------- |
> > | $\text{Subject Oriented}$           | $\text{Data Warehouse}$需要有特定的分析目标             |
> > | $\text{Validated, Integrated Data}$ | 数据转为同一模式(即$\text{Dimensional Model}$)          |
> > | $\text{Time Variant}$               | 存在时间维度，历史数据被用来分析趋势                    |
> > | $\text{Non-Volatile}$(非易失性)     | 用户对$\text{Data Warehouse}$只读，如果要更改则见下补充 |
>
> ## $\textbf{3.2. Dimensional Modelling}$
>
> > **1️⃣**$\text{Fact \& Dimension:}$ 可类比为因变量/自变量
> >
> > |   $\text{Item}$    | 描述                     | 示例                                     |
> > | :----------------: | ------------------------ | ---------------------------------------- |
> > |   $\text{Fact}$    | (因变量)测量与分析的目标 | 产品$\text{G}$过去三月的销量             |
> > | $\text{Dimension}$ | (自变量)衡量目标的维度   | 产品销售地区，产品促销力度，产品投放时间 |
> >
> > **2️⃣**$\text{Star Schema: Fact Table+Dimension Table}$​​​​ 
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528002136546.png" alt="image-20240528002136546" style="zoom:50%;" /> 
> >
> > 1. $\text{Fact Table}$​置于中间
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528011806796.png" alt="image-20240528011806796" style="zoom:33%;" />  
> >
> >    - 存放了所有$\text{Dimension Table}$的$\text{PK}$(其实是$\text{PFK}$​)，这样利于不同表格快速相$\text{Join}$ 
> >    - 还存放了$\text{Fact}$，此处为$\text{PRICE/QUANTITY}$ 
> >
> > 2. $\text{Dimension Table:}$​  
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528012430298.png" alt="image-20240528012430298" style="zoom: 40%;" /> 
> >
> >    - 置于周围，有$\text{N}$个$\text{Dimension Table}$就是$\text{N-Dimension}$​ 
> >    - 处于$\text{Denormalized}$​状态，若存在$\text{Hierarchies}$(比如$\text{Product}$高$\text{Sale}$​一级)则可标准化
> >
> > 3. 当问到一个模型是不是$\text{Star Shceme}$，需要阐述
> >
> >    - 存在(几个)$\text{Dimension}$
> >    - 每个$\text{Dimension}$都是$\text{Denormalized}$的
> >
> > **3️⃣**$\text{Star Schema}\xrightarrow[向外延展(可以延申很多层)]{将\text{Dimension Table}完全规范化}\text{Snowflake Schema}$ 
> >
> >   <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528003747856.png" alt="image-20240528003747856" style="zoom: 33%;" />

# $\textbf{4. Distributed DB}$​ 

> ## $\textbf{4.1. Distributed DB}$概念
>
> > **1️⃣**几种数据库
> >
> > |      $\textbf{Type}$      | 描述                                                         |
> > | :-----------------------: | ------------------------------------------------------------ |
> > |  $\text{Centralized DB}$  | 将一个数据库放到一个$\text{Location}$                        |
> > | $\text{Decentralized DB}$ | 将**一个**数据库分为几块，每块放到不同的$\text{Location}$ ($\text{Aka Node}$) |
> > |  $\text{Distributed DB}$  | 将**一个**数据库分为几块，每块放到不同的$\text{Location}$，并通过网络互联 |
> >
> > **2️⃣**$\text{Distributed DB}$​结构示意图
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528020053662.png" alt="image-20240528020053662" style="zoom: 33%;" /> 
> >
> > 1. $\text{DB}$不同部分由$\text{Communication Network/Link}$互联，任一部分可访问其他所有部分的数据
> > 2. 此处有两个$\text{DB1}$这是允许的，但是要确保连个$\text{DB1}$​的数据尽可能一致
>
> ## $\textbf{4.2. Distributed DB}$的特点
>
> > **1️⃣**$\text{Distributed DB}$的优点
> >
> > 1. 加快访问/处理数据的速度：
> >
> >    - 原理：将数据存储在最长使用它的地区
> >    - 示例：$\text{L1}$处要频繁访问$\text{DB1}$，将$\text{DB1}$放在$\text{L1}$​处就可(相比访问整体)加快访问速度
> >
> > 2. 允许$\text{Modular Growth}$/具有$\text{Horizontal Scalability}$​(横向扩展)
> >
> >    - $\text{Vertical Scaling:}$ 在$\text{Centralized DB}$中增加磁盘空间
> >
> >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528021157893.png" alt="image-20240528021157893" style="zoom: 25%;" /> 
> >
> >    - $\text{Horizontal Scaling:}$ 在$\text{Distributed DB}$中增加节点，并用网络连接；==成本要低得多== 
> >
> >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528021435381.png" alt="image-20240528021435381" style="zoom: 35%;" /> 
> >
> > 3. 稳定性更高：一个节点崩了，其它节点不受牵连，整个系统不至于崩($\text{Partition Tolerance}$)
> >
> > **2️⃣**$\text{Distributed DB}$的缺点
> >
> > 1. $\text{Management and Control}$更复杂，维护更复杂
> > 2. 需要保证数据一致($\text{Integrity}$)：比如有多个$\text{DB1}$节点备份，用户改变一$\text{DB1→}$所有$\text{DB1}$​都变
> > 3. 安全问题更严峻：节点越多越容易被黑
> >
> > :three:$\text{Features}$
> >
> > 1. $\text{Local Transparency: }$​用户不必知道具体某个数据存放在哪里
> > 2. $\text{Local Autonomy: }$如果$\text{Communication}$断掉了，还可以继续使用本地的节点
>
> ## $\textbf{4.3. Distribution Option}$ 
>
> > **1️⃣**$\text{Partitioned/Replicated}$方式：但注意一般实际会采用二者的结合
> >
> > |  $\textbf{Option}$   | 描述：将$\small\text{DB}\_\_$ | 示例                           |    可靠性    | 访问(本地)数据 |     存储     |
> > | :------------------: | :---------------------------: | ------------------------------ | :----------: | :------------: | :----------: |
> > | $\text{Replicated}$  |         完整复制几块          | $\small\text{ABC→3×ABC}$       |      高      |       慢       |      大      |
> > | $\text{Partitioned}$ |         拆为不同几块          | $\small\text{ABC→A/B/C或AB/C}$ |      低      |       快       |      小      |
> > |    $\text{Mixed}$    |          前二者混合           | $\small\text{ABC→AB/BC/C}$     | $\text{N/A}$ |  $\text{N/A}$  | $\text{N/A}$ |
> >
> > 🤔$\text{Replicated}$方式特点
> >
> > 1. 优点：减少了$\text{Network Traffic}$，因为所有数据都在本地，无需频繁联网取数据
> >
> > 2. 缺点：$\text{Update}$操作很费时(难以保持一致性)，比如改动一个$\text{Node}$其余所有点必定都需更新
> >
> > **2️⃣**$\text{Partitioned}$的两种方式： 把数据横着/竖着切开$\text{→Horizontal/Vertical}$​  
> >
> > |        方式         | 描述：分割表的操作                                 | 数据还原                                  |
> > | :-----------------: | -------------------------------------------------- | ----------------------------------------- |
> > | $\text{Horizontal}$ | 把不同的$\text{Row}$放在不同的$\text{Location}$    | 将不同$\text{Location}$数据$\text{UNION}$ |
> > |  $\text{Vertical}$  | 把不同的$\text{Column}$放在不同的$\text{Location}$ | 将不同$\text{Location}$数据$\text{JOIN}$  |
> >
> > - $\text{Vertical}$会改变表格的$\text{Schema}$​​，因此更复杂
>
> ## $\textbf{4.4. CAP}$理论：不可能三角
>
> > **1️⃣**概述
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528025831917.png" alt="image-20240528025831917" style="zoom: 43%;" /> 
> >
> > |             性质             | 描述                           | 对应更新选项                        |
> > | :--------------------------: | :----------------------------- | ----------------------------------- |
> > | $\text{Partition Tolerance}$ | 某节点网络失联后，系统任能运行 | $\text{N/A}$                        |
> > |     $\text{Consistency}$     | 所有用户看到的数据都一致       | 数据立即更新($\text{Synchronous}$)  |
> > |    $\text{Availability}$     | 每个请求都有回应，即使节点故障 | 数据延迟更新($\text{Asynchronous}$) |
> >
> > **2️⃣**$\text{Distributed DB:}$ 由于有多个节点，必须选择$\text{Partition Tolerance}$ 
> >
> > 1. 当节点失联后还==使用==节点$\text{→}$再选择$\text{Availability}$  
> > 2. 当节点失联后就==丢弃==节点$\text{→}$再选择$\text{Consistency}$ ​
> >
> > **3️⃣**$\text{Transactional DB:}$ 只有一个节点(不存在网络问题)$\to$大概率只能选$\text{Availability+Consistency}$ 

# $\textbf{5. NoSQL: }$专门用来存数据 

> ## $\textbf{5.1. NoSQL}$概述
>
> > **1️⃣**$\text{NoSQL}$的引入：要解决$\text{Objected Oriented}$(面向对象)问题，而传统$\text{Relational Model}$办不到 
> >
> > **2️⃣**$\text{NoSQL}$的作用：存储大量数据
> >
> > 1. $\text{Bigdata}$的特点：$\text{3V}$ ($\text{Volume}$/量大，$\text{Variety}$/种类多，$\text{Velocity}$​​/数据生成快)
> >
> >    |       特点        | 示例                                                         |
> >    | :---------------: | :----------------------------------------------------------- |
> >    |  $\text{Volume}$  | $\text{Scalability / Data Lake}$                             |
> >    | $\text{Variety}$  | $\text{\textcolor{red}{\colorbox{yellow}{Bespoke QL}} / Different Data Structure}$ |
> >    | $\text{Velocity}$ | $\text{Streaming Data / \textcolor{red}{\colorbox{yellow}{Eventual Consistency}}}$ |
> >
> > 2. $\text{NoSQL}$存储数据的方式：$\text{Schema On Read}$ 
> >
> >    |           方式           | 描述                                           |      适用      |
> >    | :----------------------: | ---------------------------------------------- | :------------: |
> >    | $\text{Schema On Read}$  | 先快速存储数据，稍后再为数据选择$\text{Model}$ | $\text{NoSQL}$ |
> >    | $\text{Schema On Write}$ | 先决定数据的$\text{Model}$，再存储数据         |   传统数据库   |
> >
> > 3. $\text{Data Lake:}$ 存储数据的大型集成$\text{Repository}$ 
> >
> > **3️⃣**$\text{NoSQL}$更契合$\text{Distributed DB}$​的思想：
> >
> > 1. ==在$\text{CAP}$中选择$\text{Partition Tolerance+Availability}$== 
> > 2. 由于主要用于存数据，所以比起一致性对数据可访问性要求更高
> >
> > :four:优点：$\text{Flexible Model / Scalability / Performance / High Availability}$ 
>
> ## $\textbf{5.2. NoSQL}$种类 
>
> > **1️⃣**$\text{Key-Value}$
> >
> > 1. 结构：类似于**目录结构**，通过$\text{Primary Key}$索引，对应其下的$\text{Value}$可以放任何东西
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528074434447.png" alt="image-20240528074434447" style="zoom:28%;" />  
> >
> > 2. 特点：
> >
> >    - 最灵活，图片/视频/$\text{PDF}$都能放 (杂七杂八格式要放一起时，大概率用$\text{Key-Value}$) 
> >    - 结构化程度最弱($\text{Unstructured}$)
> >
> > **2️⃣**$\text{Document:}$ 
> >
> > 1. 结构：将数据存储在文件中，比如$\text{Json/XML}$​，比较偏门的还有==$\text{MARC}$== 
> > 2. 特点：$\text{Semi-Structured}$或者说$\text{Object-Relational Structured}$ 
> > 3. 示例：$\text{MangoDB}$ 
> >
> > **3️⃣**$\text{Column Family:}$​ 类似于$\text{Vertical Partition}$将每列存储为一个表格
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240528075841058.png" alt="image-20240528075841058" style="zoom: 23%;" /> 
> >
> > **4️⃣**$\text{Graphic-Oriented:}$​ 
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/38311088324.png" alt="38311088324" style="zoom:60%;" />  
> >
> > 1. 图边$\xleftrightarrow{}$关系，图节点$\xleftrightarrow{}$​实体
> > 2. 适合追溯不同实体间的关系 ($\text{Track Relationship}$) 
>
> ## $\textbf{5.3. BASE}$​理论$\textbf{For NoSQL}$ 
>
> > ==对应$\text{Transaction}$的$\text{ACID}$性质== 
> >
> > **1️⃣**$\text{Basically Avaliable:}$ 选择$\text{Partition Tolerance}$基础上，确保$\text{Availbility}$而非$\text{Consistency}$​ 
> >
> > **2️⃣**$\text{Evental Consistency:}$ 系统从停止接收数据开始，终将会(慢慢更新)到达$\text{Evental Consistency}$ 
> >
> > **3️⃣**$\text{Soft State:}$ 在最终一致状态($\text{Evental Consistency}$)前，系统状态会随时改变 