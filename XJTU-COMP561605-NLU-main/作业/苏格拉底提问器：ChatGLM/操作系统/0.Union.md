# <font color='cornflowerblue'>OS概述</font>

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1.%20OS%E6%A6%82%E8%BF%B0.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1.%20OS%E6%A6%82%E8%BF%B0.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1.%20OS%E6%A6%82%E8%BF%B0.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1.%20OS%E6%A6%82%E8%BF%B0.html)==**

# <font color='cornflowerblue'>1. 操作系统概念</font>

> ## <font color='cornflowerblue'>1.1. OS概述：为何物</font>
>
> > **0️⃣**计算机系统部件：硬件(CPU/内存/输入输出设备/系统总线)、操作系统、应用程序以及用户
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231103190244280.png" alt="image-20231103190244280" style="zoom: 50%;" />  
> >
> > **1️⃣**为何需要操作系统：方便用户交互与使用，高效管理硬件
> >
> > **2️⃣**<font color="red">**定义：控制和管理计算机系统资源，方便用户使用的程序和数据结构的集合**</font>
>
> ## <font color='cornflowerblue'>1.2. 操作系统的特点</font>
>
> > ### <font color='cornflowerblue'>1.2.1. 并发</font>
> >
> > > **1️⃣**含义：计算机中同时存在多个运行的程序，进程由此引入
> > >
> > > **2️⃣**实现方式：程序分时交替执行，一段时间内并发执行，一个时刻只有一个程序在执行
> > >
> > > **3️⃣**与并行的辨析：并行是同一时刻(而非同一时间但)执行多个程序
> >
> > ### <font color='cornflowerblue'>1.2.2. 共享</font>
> >
> > > **1️⃣**含义：系统资源可供内存中多个并发执行进程使用
> > >
> > > **2️⃣**共享方式之一：互斥共享方式(如打印机)
> > >
> > > 1. 含义：一段时间内只许一个进程访问该资源，别的进程要访问只能先等
> > > 2. 临界资源：一段时间只允许一个进程访问的资源
> > >
> > > **3️⃣**共享方式之二：同时访问方式(如磁盘)，指宏观上多个进程同时访问一个资源(微观上分时交替)
> >
> > ### <font color='cornflowerblue'>1.2.3. 虚拟</font>
> >
> > > **1️⃣**含义：物理实体映射为若干个对应的逻辑实体(用户能感觉到的)
> > >
> > > **2️⃣**虚拟处理器(时分复用技术)：让多道程序并发执行，分时使用一个处理器，让每个用户觉得自己独享CPU
> > >
> > > **3️⃣**虚拟存储器(空分复用技术)：利用软件技术将辅存扩充为主存
> > >
> > > **3️⃣**虚拟IO设备：将一台I/O虚拟为多台逻辑I/O，允许每个用户占用一台逻辑I/O
> >
> > ### <font color='cornflowerblue'>1.2.4. 异步(不确定性)</font>
> >
> > > 进程的执行顺序/时间，不是一贯到底而是以不可预测的方式走走停停
>
> ## <font color='cornflowerblue'>1.3. 操作系统功能</font>
>
> > > **1️⃣**管理系统资源：CPU(进程)管理+内存管理+文件管理+设备管理
> > >
> > > **2️⃣**作为用户接口，主要分为命令接口(联机+脱机)，程序接口
> > >
> > > 1. 联机命令接口(分时系统)：用户通过控制台/终端输入命令→系统解释/执行命令行→控制权转回终端
> > > 2. 脱机命令接口(批处理系统)：用户不直接干预作业运行，事先用控制命令写成一份作业操作说明，连同作业一起提交给系统
> > >
> > > 3. 程序接口：供用户在程序中使用是的一堆系统调用，通过GUI(图像用户界面)调用程序接口
> > >
> > > **3️⃣**扩充计算机资源：没操作系统的计算机叫裸机，覆盖了软件的机器称为扩充机器/虚拟机

# <font color='cornflowerblue'>2. 操作系统的发展：分时操作系统前</font>

> 无OS(真空管)→批处理OS(晶体管)→多道程序(集成电路)→分时系统(大规模集成电路)
>
> ## <font color='cornflowerblue'>2.1. 无操作系统阶段</font>
>
> > **1️⃣**概述：工作方式(手搓)+编程语言(机器语言)+IO(打纸袋)
> >
> > **2️⃣**缺点：用户独占全机利用率低，CPU等待用户(装卸纸带)
> >
> > **3️⃣**脱机IO：将IO操作放在别的计算机上实现，让磁带作为中介
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231103193551270.png" alt="image-20231103193551270" style="zoom: 67%;" /> 
>
> ## <font color='cornflowerblue'>2.2. 单道批处理系统(操作系统前身)</font>
>
> > **1️⃣**系统工作方式：作业脱机输入磁带，OS配置监督程序，监督程序一个个把磁带中的作业调入内存处理完后调出
> >
> > **2️⃣**特点：自动性(作业自动进入)，顺序性(作业进入内存后顺序执行)，单通道性(内存中只能同时运行一个程序)
> >
> > **3️⃣**一大缺陷：CPU和I/O设备使用忙闲不均
>
> ## <font color='cornflowerblue'>2.3. 多道批处理系统</font>
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20211221095310417.png" alt="image-20211221095310417" style="zoom: 50%;" /> 
> >
> > **1️⃣**工作方式：区别于单道，作业排队(一个/多个一起被操作系统)送入内存，内存中可以有多个独立作业，但同时运行/共享资源(CPU，IO等)
> >
> > **2️⃣**特点：多道性(内存中多道程序)+无序性(作业完成顺序与进入内存顺序无关)+调度性(作业/进程调度)
> >
> > **3️⃣**缺点：无交互能力，用户响应时间长，作业平均周转时间长(有可能第一个进入，最后一个出)

# <font color='cornflowerblue'>3. 正式操作系统类型</font>

> pre.作业的概念：操作系统执行一个工作所作的工作(程序，数据，命令)集合
>
> ## <font color='cornflowerblue'>3.1. 分时OS</font>
>
> > **1️⃣**分时技术：把CPU运行时间分为时间片，按时间片轮流把CPU给各联机作业使用。若某作业在其时间片内不能完成其计算，则下一轮时间片再计算行
> >
> > **2️⃣**实现方法种类：
> >
> > 1. 简单分时操作系统(内存中只有一个作业，但是时间片满后就被踢出)
> >
> > 2. 有先后台的分时操作系统(把作业划分为前后台，前台同于简单分时/后台批处理，前台运行后台才能运行)
> >
> > 3. 多道分时操作系统(引入多道程序技术，内存可同时装入多道作业)
> >
> > **3️⃣**特点：多路性(一设备多终端，每个终端的用户同时使用)，交互性(用户直接控制程序运行)，独占性(用户都以为自己独占计算机)，及时性(计算机快速响应用户需求)
>
> ## <font color='cornflowerblue'>3.2. 实时OS(专用OS)</font>
>
> > 在极短时间内(短于分时系统)对外界信息做出响应，实时性高，专用性强
> >
> > **1️⃣**实时控制系统(硬件)：以计算机为中心的生产过程控制系统(如数控机床)，实时采集/处理数据
> >
> > **2️⃣**实时信息处理系统(软件)：及时接收远程终端的服务请求，并快速响应(如12306系统)
>
> ## <font color='cornflowerblue'>3.3. 其它OS</font>
>
> > **1️⃣**嵌入式OS：在各种设备/装置/系统中(比如电器)，完成特定功能的软硬件系统
> >
> > **2️⃣**并行系统<font color='red'>(紧耦合)</font>：有紧密通信的(不要理解为多通道)、多于一个CPU的多处理器系统
> >
> > **3️⃣**网络操作系统：通过网络将多个计算机系统互连来交换信息/共享资源/协作处理，特点为：
> >
> > 1. 系统中的计算机系统在物理上是分散的，自治的(都有各自系统)
> >
> > 2. 系统互连要通过通信设施(硬/软件)来实现
> >
> > **4️⃣**分布式系统<font color='red'>(松散耦合)</font>：分散处理单元经网络连城统一OS，可将大任务划分并分配
> >
> > 1. 特点：统一(它是个统一OS)+共享性(所有资源共享)+透明性(用户眼里不知道哪个计算机在处理请求)+自治性(多个主机都处于平等地位)
> > 2. 优点：成本低性能高，可靠(一个CPU挂了照样运行)
>
> ## <font color='cornflowerblue'>3.4. 番外：分布式OS vs 网络OS</font>
>
> > **1️⃣**分布式系统是OS同质(OS一样)，网络OS要求协议同质(OS可不一样但是网络协议要一样)
> >
> > **2️⃣**分布式OS可将进程分散在多个主机，网络OS进程则不能迁移
> >
> > **3️⃣**分布式OS中用户不知道哪个主机在处理任务，网络OS则反之
> >
> > **4️⃣**分布式系统容错率更大

# <font color='cornflowerblue'>4. OS运行环境</font>

> ## <font color='cornflowerblue'>4.0. 硬件保护</font>
>
> > **1️⃣**IO保护：I/O都是特权指令(用户不能直接I/O)，必须通过系统调用，需要保护IO必须先保护中断向量(在内存中)，所以必须保护内存
> >
> > **2️⃣**内存保护：确定进程能访问空间，使用基址+界限寄存器(内存开始+长度)，这两个寄存器只能由特权指令在核心态加载
> >
> > **3️⃣**CPU保护：防止用户程序死循环/不调用系统服务/不将控制权返回OS，设置定时器
> >
> > PS: 定时器，一定时间后就会在中断，把控制权返回OS
>
> ## <font color='cornflowerblue'>4.1. CPU运行模式</font>
>
> > ### <font color='cornflowerblue'>4.1.1. 两种模式</font>
> >
> > > **1️⃣**核心态(管态/系统态)：OS管理程序执行时机器处于核心态，特权高，可执行一切指令，可访问所有寄存器/存储区
> > >
> > > **2️⃣**用户态(目态)：用户程序执行时机器处于用户态，特权低，只执行规定命令，只访问特定寄存器/存储区
> > >
> > > PS: **一开机时处于管态，执行用户程序时转为用户态；出现中断/陷阱时，硬件会切换回管态**
> > >
> > > **3️⃣**两种状态的程序被严格分开存储，在CPU中以不同方式执行
> > >
> > > **4️⃣**用户态程序如何调用核心态程序：去执行访问核心态命令→中断→中断系统转入OS内相应程序
> >
> > ### <font color='cornflowerblue'>4.1.2. 有关概念</font>
> >
> > > **1️⃣**特权指令：只给OS内核使用，只有在核心态中才能使用，如IO/中断屏蔽/存储保护/清内存/设置时钟
> > >
> > > **2️⃣**OS内核：硬件强关联模块(时钟管理/中断处理/驱动)+运行频率高的程序(进程/存储/设备管理)
> > >
> > > 1. 时钟管理(最关键)：向用户提供标准系统时间，管理时钟中断来切换进程
> > > 2. 中断机制：小部分由内核负责(保护/恢复中断现场信息，转移控制权到相关程序)
> > > 3. 原语：关闭中断的公用小程序，是最接近硬件的软件，运行时间段调度频繁，一条原语必须一次性执行完
> > > 4. 系统控制的数据结构及处理：登记状态信息的数据块(作业控制块/进程控制块等)+如何操作这些块(进程管理等)
>
> ## <font color='cornflowerblue'>4.2. 中断和异常的处理</font>
>
> > **1️⃣**硬件中断：设备控制器利用中断通知CPU它已经完成了某个操作
> >
> > **2️⃣**软件中断：也称为陷阱，包括异常(Exception)与系统调用(System call)
> >
> > PS：中断会将控制权转移到中断服务程序，通用程序检查是否中断，不同终端有不同代码处理
> >
> > **3️⃣**中断向量表：每一类中断对应一个中断向量，合在一起就是中断向量表
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231104114609681.png" alt="image-20231104114609681" style="zoom:50%;" /> 
> >
> > **4️⃣**IO中断：
> >
> > 1. IO操作：分为同步(OS干等IO结束)+异步(OS在IO时去干别的)
> > 2. IO操作完后就触发一个中断

# <font color='cornflowerblue'>5. OS结构</font>

> ## <font color='cornflowerblue'>5.1. 操作系统服务一览</font>
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231104142255717.png" alt="image-20231104142255717" style="zoom:50%;" /> 
>
> ## <font color='cornflowerblue'>5.2. 系统调用</font>
>
> > 六大类：进程控制/文件管理/设备管理/信息维护/通信/保护 
> >
> > ### <font color='cornflowerblue'>5.2.1. 系统调用概念</font>
> >
> > > **1️⃣**功能：提供在运行程序和操作系统之间的接口，属于软中断(aka陷入/异常指令/访管指令)
> > >
> > > **2️⃣**途径：程序通过API(高级应用程序接口)访问
> > >
> > > **3️⃣**常见API：Win32 API，POSIX API(UNIX/Linux/MacOS)，用于Java虚拟机(JVM)的Java API
> > >
> > > **4️⃣**系统调用处理机构：陷入/异常处理机构(TRAP)
> >
> > ### <font color='cornflowerblue'>5.2.2. 系统调用的过程</font>
> >
> > > **1️⃣**大致流程：系统调用把应用程序请求传给内核→内核调用内核函数完成处理→执行结果返回应用程序
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20231008010245492.png" alt="image-20231008010245492" style="zoom: 50%;" />  
> > >
> > > **2️⃣**实现细节：用户调用→CPU中断/发信给陷入处理机构→陷入处理机构保护现场/通过入口地址表找到系统调用程序→执行完系统程序→CPU恢复现场
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231104145432958.png" alt="image-20231104145432958" style="zoom:50%;" /> 
> >
> > ### <font color='cornflowerblue'>5.2.3. 向OS传参的方式</font>
> >
> > > 用寄存器+用栈(程序压入/OS取出)+通过参数表(下图)
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231104145810320.png" alt="image-20231104145810320" style="zoom: 59%;" /> 
> > >
> > > 参数在表中，表的地址通过寄存器传递
>
> ## <font color='cornflowerblue'>5.3. 操作系统体系结构类型</font>
>
> >### <font color='cornflowerblue'>5.3.1. 模块组合结构(UNIX，MS-DOS)</font>
> >
> >> **1️⃣**含义：操作系统是一个整体模块，由若干模块按照一定结构组成
> >>
> >> **2️⃣**利弊：利在于结构紧凑/接口简单/效率高，弊在于模间调度混乱/接口设计灵活度低/不适用于大型系统
> >
> >### <font color='cornflowerblue'>5.3.2. 层次结构</font>
> >
> >> **1️⃣**含义：将所有模块按功能调用次序排列成若干层，模块间只存在单向调用/依赖
> >>
> >> <font color='red'>**2️⃣**优点：</font>
> >>
> >> 1. <font color='red'>低层和高层可分别实现(可扩充)</font>
> >> 2. <font color='red'>高层错误不会影响到低层，便于调试、利于功能的增删改</font>
> >> 3. <font color='red'>调用关系清晰(高层对低层单向依赖)，避免递归调用，有利于保证设计和实现的正确性</font>
> >>
> >> **3️⃣**缺点：难以解决OS各模块应放哪一层(当下将为进程有关调用模块放在内层)
> >
> >### <font color='cornflowerblue'>5.3.3. 微内核结构：用户程序(客户/服务器进程)+微内核</font>
> >
> >> **1️⃣**含义：OS Kenel中只留基本功能<font color='red'>(任务管理/虚存管理/进程间通信)</font>，其他功能分出去，由服务器进程完成其他功能，形成CS模式
> >>
> >> **2️⃣**工作方式：C进程通过内核请求S进程，然后C进程获得操作系统服务
> >>
> >> **3️⃣**优点：可靠(某个服务器进程崩了不会全崩)，灵活(接口灵活增减)，便于维护(修改服务器代码不会崩)，适用于分布式系统
> >>
> >> **4️⃣**缺点：效率不高，通信频繁
> >
> >### <font color='cornflowerblue'>5.3.4. 模块化内核(可加载内核模块)</font>
> >
> >> **1️⃣**面向对象：每个内核模块都封装抽象，保留功能接口
> >>
> >> **2️⃣**核心组件分离：核心组件(文件系统/网络协议栈/设备驱动)成为独立模块，模块只在需要时加载
> >>
> >> **3️⃣**模块间通信：通过定义接口
> >>
> >> **4️⃣**动态加载：模块不是在内核启动时加载，而是在内核运行时按需加载，比如某个硬件挂在后相应驱动模块才加载
>
> ## <font color='cornflowerblue'>5.4. 虚拟机</font>
>
> > 软件实现，模拟硬件系统的功能，安装并运行操作系统和应用程序

# <font color='cornflowerblue'>进程管理</font>

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/2.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/2.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/2.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/2.%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html)==**

# <font color='cornflowerblue'>1. 进程</font>

> ## <font color='cornflowerblue'>1.1. 顺序与并发</font>
>
> > 进程是OS分配资源，独立运行的基本单位
> >
> > ### <font color='orange'>1.1.1. 前驱图</font>
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20231009202811269.png" alt="image-20231009202811269" style="zoom: 33%;" /> 
> > >
> > > **1️⃣**结点：一个语句/一段程序/一个进程
> > >
> > > **2️⃣**$P_i\to{}P_j$意思是$P_i$必须在$P_j$开始执行前执行完成
> > >
> > > **3️⃣**前驱后继，直接前驱直接后继的概念同离散舒徐。没有前驱的叫初始节点，没有后继的叫终止节点
> >
> > ### <font color='cornflowerblue'>1.1.2. 程序的顺序执行</font>
> >
> > > **1️⃣**含义：一个程序分为若干程序，前一个执行完后一个才能执行
> > >
> > > **2️⃣**特点：顺序性，封闭性(独占资源，结果不受外界影响)，可再现(相同程序执行结果总相同)
> >
> > ### <font color='cornflowerblue'>1.1.3. 程序的并发执行</font>
> >
> > > **1️⃣**含义：无论上个程序是否执行完，下一程序强行执行。导致一定时间内多个程序同时运行且**次序不事先确定**
> > >
> > > **2️⃣**与顺序执行不同的特点：
> > >
> > > 1. 间断性(异步性)：程序走走停停，失去输入时的时序
> > > 2. 失去封闭性：程序得共享资源，运行互相影响，数据可能被乱改
> > > 3. 不可再现性：失去封闭性的结果，例如当两个程序共享一个变量时，运行结果是怎么样不可预测
> >
> > ### <font color='orange'>1.1.4. 程序并发执行的条件</font>
> >
> > > **1️⃣**换而言之：让程序在并发执行时保持封闭/可再现性
> > >
> > > **2️⃣**Bernstein条件(理想化条件)
> > >
> > > 1. 读集$R(p_i)=\lbrace{}a_1,a_2,...,a_m\rbrace{}$/写集$W(p_i)=\lbrace{}b_1,b_2,...,b_m\rbrace{}$是$p_i$执行所**引用/改变**变量集合
> > >
> > > 2. Bernstein条件：对于$p_1,p_2$两个程序，满足以下条件就可再现
> > >
> > >    条件1：两次读操作间存储器不变，$R(p_1)\cap{}W(p_2)=R(p_2)\cap{}W(p_1)=\varnothing$
> > >
> > >    条件2：写操作结果不丢失，$W(p_1)\cap{}W(p_2)=\varnothing$
> >
> > ### <font color='cornflowerblue'>PS：串行与并行</font>
> >
> > > **1️⃣**串行：一个任务执行单元，从物理上就只能执行一个任务，顺序执行在逻辑上也是执行一个任务
> > >
> > > **2️⃣**并行：多个任务执行单元，从物理上多个任务一起执行，并行在逻辑上(一段时间内分时)是多任务但是物理上是单任务(同一时刻不行)
>
> ## <font color='cornflowerblue'>1.2. 进程定义和描述</font>
>
> > ### <font color='cornflowerblue'>1.2.1. 进程定义</font>
> >
> > > **1️⃣**结点定义：是程序在CPU上一次执行过程；是可和别的进程并行执行的计算；程序序在一个数据集合上的运行过程
> > >
> > > **2️⃣**不同OS下的含义：批处理OS中作业=进程(基本认为二者含义相同)。分时OS中进程=用户程序/任务
> >
> > ### <font color='cornflowerblue'>1.2.2. 进程的特性</font>
> >
> > > **1️⃣**动态性：创建后产生，调度而执行，得不到资源会暂停，撤销后消亡
> > >
> > > <font color='red'>**2️⃣**并发性：可以多个进程都在内存，多个内存同时执行(进程就是因为并发执行才提出)</font>
> > >
> > > **3️⃣**独立性：程是一个能独立运行/分配调度资源的单位
> > >
> > > **4️⃣**异步性：进程以各自独立，不可预知的速度推进
> > >
> > > **5️⃣**结构特征：进程控制块(见后)+程序段(进程中能被调度到CPU上执行的程序代码段)+数据段(初始/中间/执行产生的数据)
> >
> > ### <font color='cornflowerblue'>1.2.3. 进程&其它概念的辨析</font>
> >
> > > **1️⃣**进程和程序：进程是程序的执行(动态/静态)，进程是暂时的程序是永久的，一个程序可每次执行出不同进程/一个进程可调用多个程序
> > >
> > > **2️⃣**进程和进程映像：进程映像(实体)是进程某一时刻的静态视图(把进程定住，就是进程映像)，和进程一样都由程序段+数据段+PCB构成
> > >
> > > **3️⃣**进程和作业：
> > >
> > > 1. 作业是用户向计算机提交任务的任务实体，作业的完成过程为提交+收容+执行+完成。
> > > 2. 作业会在外存中排队进入内存，作业进入内存后就是进程(作业是提交后的作业的执行过程)
> > > 3. 一个作业有一个及以上进程，一个进程不能有多个作业
>
> ## <font color='cornflowerblue'>1.3. 进程的状态与转换</font>
>
> > ### <font color='cornflowerblue'>1.3.1. 五状态模型</font>
> >
> > > **1️⃣**就绪：已获得除CPU以外的所有资源，CPU时间片没转到这个进程时
> > >
> > > **2️⃣**执行/运行：获得CPU后在CPU中运行
> > >
> > > **3️⃣**阻塞/等待：正在执行的进程被打断(如IO完成，缺少数据)，**即使CPU给了进程也执行不了**
> > >
> > > **4️⃣**创建：申请空白PCB，填写PCB，系统分配资源，最后转入就绪
> > >
> > > **5️⃣**结束状态：正常执行完/中断退出
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231104164623020.png" alt="image-20231104164623020" style="zoom:58%;" /> 
> > >
> > > **1️⃣**就绪→执行：进程被进程调度程序选中
> > >
> > > **2️⃣**执行→等待(阻塞)：请求，等待某个事件(IO/填补数据)发生完毕
> > >
> > > **3️⃣**执行→就绪：时间片用完or优先级更高的进程插队
> > >
> > > **4️⃣**阻塞→就绪：等待到了某此除CPU以外的资源，被唤醒
> > >
> > > **5️⃣**Tips：进程转化不可都逆(上图)，进程间转化并非都是程序主动的(只有执行→阻塞为主动)
> >
> > ### <font color='cornflowerblue'>1.3.2. 七状态模型：引入了挂起</font>
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231104165308128.png" alt="image-20231104165308128" style="zoom: 60%;" /> 
> > >
> > > **1️⃣**就绪/阻塞挂起：把就绪/阻塞进程从内存丢到外存，保存就绪/阻塞信息，等待重新调入内存
> > >
> > > **2️⃣**引入挂起的意义：优化不活跃的进程，用户可以挂起进程来调查问题，父进程挂起子进程来同步，优化内存等资源利用
>
> ## <font color='cornflowerblue'>1.4. 进程调度</font>
>
> > ### <font color='cornflowerblue'>1.4.1. 调度队列</font>
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231104213934224.png" alt="image-20231104213934224" style="zoom: 67%;" />  
> > >
> > > 作业队列(所有进程集合)+就绪队列(主存中就绪执行的进程)+设备队列(等待某IO设备的进程)
> >
> > ### <font color='cornflowerblue'>1.4.2. 三种调度：详见CPU的三级调度</font>
> >
> > ### <font color='cornflowerblue'>1.4.3. 上下文切换：详见进程切换</font>
>
> ## <font color='cornflowerblue'>1.5. 进程控制数据结构：PCB</font>
>
> > **1️⃣**概述：每个进程都有一个，在进程创建时生成并跟随全程，系统通过PCB识别/感知到/控制/描述进程，常驻内存
> >
> > **2️⃣**PCB(进程控制块)的内容
> >
> > 1. 进程标识符(PID)：每个进程唯一持有，进程创建时创建
> >
> > 2. 进程状态：作为进程调度程序分配CPU的依据
> >
> > 3. 进程队列指针：记录PCB队列(如就绪队列/等待队列)中下一个PCB的地址，PCB队列有就绪队列/拥塞队列等
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/537875d2acaa44ad9a28a6405457e0ff" alt="操作系统基础12-进程调度" style="zoom: 67%;" />   
> >
> > 4. 进程的程序与数据的地址
> >
> > 5. 进程优先级(优先级高的可以先被处理器处理)
> >
> > 6. CPU现场保护区：进程脱离CPU时，CPU现场信息(PC，寄存器)被保留到PCB中
> >
> > 7. 通信信息：与其它进程的通信记录
> >
> > 8. 家族联系：比如记录父进程，本进程，子进程，子子进程的关系树
> >
> > 9. 占有资源清单：进程所需/当前已分配资源
> >
> > **3️⃣**PCB的组织方式：链接(PCB链表)+索引(按索引表找PCB)
>
> ## <font color='cornflowerblue'>1.6. 进程控制基础操作</font>
>
> > 也就是进程管理，由OS内核实现
> >
> > ### <font color='cornflowerblue'>1.6.1. 创建进程：从程序到进程</font>
> >
> > > **1️⃣**进程前驱图(进程家族树)：进程创建n个子进程，子进程又创建m个子子进程......
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20231010105152130.png" alt="image-20231010105152130" style="zoom: 67%;" /> 
> > >
> > > **2️⃣**进程创建的诱因：
> > >
> > > 1. 用户登录(分时OS)：用户在终端输入登录信息，OS为其建立进程然后就绪
> > > 2. 作业调度(批处理OS)：作业调度程序让某个作业装入内存，分配资源，变成就绪进程
> > > 3. 请求服务：一个进程创建一个子进程，以此类推形成进程树
> > >
> > > ➕关于父进程子进程
> > >
> > > 1. 资源共享方式：子进程共享父进程所有/部分/资源+无资源共享
> > > 2. 子进程的执行：父子并发执行，父进程等待子进程终止
> > > 3. 父子进程的地址空间：两者程序/数据相同，子进程另外加载一个程序
> > >
> > > **3️⃣**进程创建过程：原语，过程为
> > >
> > > 向OS申请一个PCB(带有PID)→分配资源→初始化PCB(名称/优先级等)→PCB插入就绪队列
> > >
> > > **4️⃣**UNIX中创建进程的实例
> > >
> > > ```Cpp
> > > int main(int argc, char *argv[]) 
> > > {
> > >     /*pid存储进程ID，调用fork()系统函数创建子进程*/
> > >     int pid;
> > >     pid = fork();
> > > 
> > >     /*发生错误，输出错误信息，异常退出*/
> > >     if (pid < 0) {fprintf(stderr, "Fork Failed\n");exit(-1);}
> > > 
> > >     /*处于新创建的子进程中，子进程的内存空间替换成了"/bin/ls"程序*/
> > >     else if (pid == 0) {execlp("/bin/ls", "ls", NULL);} 
> > > 
> > >     /*处于父进程中，等待父进程的结束，打印子进程结束的信息，正常退出*/
> > >     else {wait(NULL);printf("Child Complete\n");exit(0);}
> > > }
> > > ```
> >
> > ### <font color='cornflowerblue'>1.6.2. 进程撤销</font>
> >
> > > **1️⃣**含义：进程因为完成任务/异常/外界干预，释放各种资源，通过调用exit()返回状态值到OS/父进程
> > >
> > > **2️⃣**撤销原语(OS撤销进程的低级操作)
> > >
> > > 1. 策略：撤销有指定PID的进程，或者顺带其后代进程一起撤销
> > > 2. 过程：撤销PCB→停止执行(设置重新调度标志)→回收进程占用资源(给OS或者父进程)
> > >
> > > **3️⃣**有关概念
> > >
> > > 1. 僵尸进程：执行完成且释放资源但仍占据进程表的进程，源于其父进程还未调用wait()读取子进程退出状态 
> > > 2. 孤儿进程：父进程已经结束(如崩溃)但还在运行(未完成)的子进程，会被init进程，后者定期执行wait()清除这些子进程
> >
> > ### <font color='cornflowerblue'>1.6.3. 进程阻塞与唤醒</font>
> >
> > > **1️⃣**阻塞/唤醒原语：功能分别为使得进程执行→阻塞，阻塞→就绪(不是执行)
> > >
> > > **2️⃣**阻塞/唤醒的原因：
> > >
> > > 1. 阻塞：当一个进程期待的某一事件未出现时，进程主动调用阻塞原语阻塞自己
> > >
> > > 2. 唤醒：当一个进程期待的某一事件出现时，发现者进程主动调用唤醒原语，使得阻塞进程被动唤醒
> > >
> > >    PS：发现者进程和唤醒进程并发
> > >
> > > **3️⃣**阻塞原语的操作流程
> > >
> > > 中断CPU停止进程→保存CPU现场→进程阻塞并加入等待队列→转到进程调度程序去选一个新进程执行
> > >
> > > **4️⃣**唤醒原语的操作流程：将被唤醒进程从等待队列中移出→就绪→插入就绪队列
>
> ## <font color='cornflowerblue'>1.7. 进程控制其他操作</font>
>
> > ### <font color='cornflowerblue'>1.7.1. 进程切换/上下文切换(开销较大)</font>
> >
> > > **1️⃣**含义：处理器从一个进程的运行转到另一个进程的运行
> > >
> > > **2️⃣**进程切换：CPU将旧进程上下文保存在PCB中→加载新进程上下文
> > >
> > > **3️⃣**这一过程中会产生中断，CPU会从用户模式→内核模式→用户模式
> >
> > ### <font color='cornflowerblue'>1.7.2. 协同进程</font>
> >
> > > **1️⃣**独立/协同进程：是(协同)否(独立)需要与其他进程共享信息或在执行上相互作用
> > >
> > > PS: 进程是否可以进行进程通信和他是独立/协同没有必然联系
> > >
> > > **2️⃣**协同进程的好处：信息共享，模块化，加速运算
> >
> > ### <font color='cornflowerblue'>1.7.3. 进程通信:arrow_down:</font>
>
> ## <font color='cornflowerblue'>1.8. 进程通信(IPC)</font>
>
> > ### <font color='orange'>1.8.1. 低级进程通信</font>
> >
> > > 其实就是进程的同步P和互斥V，对应的P/V原语为低级进程通信原语
> >
> > ### <font color='cornflowerblue'>1.8.2. 三种高级进程通信</font>
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231105003408708.png" alt="image-20231105003408708" style="zoom: 67%;" />  
> > >
> > > **1️⃣**共享存储系统
> > >
> > > 1. 含义：主存中的共享区域，多个进程通过对这个区域读写来实现通信
> > > 2. 特点：由通信进程确定交换的数据和位置，**不受OS控制**
> > >
> > > **2️⃣**消息传递系统
> > >
> > > 1. 含义：进程通过建立通信连接(物理的总线/逻辑的程序)，通过send/receive交换信息
> > > 2. 直接通信方式：发送进程发信给接收进程→消息进入接收进程的缓冲队列→接收进程从队列中取得消息
> > > 3. 间接通信方式：创建邮箱→发送进程把消息给信箱(端口Port)→接收进程从邮箱取得消息→销毁邮箱(Optional)，邮箱分为私有(进程创建的)/公有的(OS创建的)
> > >
> > > **3️⃣**管道通信系统
> > >
> > > 1. 管道：连接读写进程，实现二者间通信的共享文件，并不是一个传输通道
> > > 2. 过程：向管道提供写进程，信息以字符流形式送入管道，而接收管道通过读进程输出
> >
> > ### <font color='cornflowerblue'>1.8.3. 消息传递的异步/同步</font>
> >
> > > **1️⃣**零容忍/同步/阻塞：发送者必须等待接收者
> > >
> > > **2️⃣**有限容忍：接收缓冲队列里达到n长后，发送者就必须等了
> > >
> > > **3️⃣**无限容忍/异步/非阻塞：发送者一直发送消息不等待，接收者同样不等待

# <font color='cornflowerblue'>2. 线程</font>

> ## <font color='cornflowerblue'>2.1. 线程的引入</font>
>
> > **1️⃣**早期OS进程的基本属性：拥有资源的独立单位+可调度的基本单位
> >
> > **2️⃣**弊端：进程拥有资源又要频繁调度，开销大，限制了并发
> >
> > **3️⃣**解决方案：让进程成为拥有资源的单位，不频繁切换；让线程成为调度单位，不拥有资源
>
> ## <font color='cornflowerblue'>2.2. 线程的概念</font>
>
> > **2️⃣**线程定义：作为CPU调度单位(进程只作为资源分配单位)，aka轻型进程
> >
> > **3️⃣**线程的资源：只拥有必不可少资源(<font color='red'>线程状态+程序计数器+寄存器上下文+栈</font>)，但是和同属一个进程的线程们共享资源(<font color='red'>代码段+数据段+OS资源</font>)
> >
> > **4️⃣**多线程：一个进程有多个线程并发执行，一线程改了数据其他线程也使用修改数据， 一线程读文件时其他线程也可同时读
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20211101210651656.png" alt="image-20211101210651656" style="zoom: 50%;" /> <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231105133455429.png" style="zoom: 67%;" />  
> >
> > **5️⃣**线程切换：速度极快，只需切换寄存器+栈
>
> ## <font color='cornflowerblue'>2.3. 进程VS线程</font>   
>
> > **1️⃣**调度：耗时
> >
> > 同一进程内切换上下文<进程切换上下文=不同进程的线程切换上下文(需要进程切换)
> >
> > **2️⃣**拥有资源：进程拥有资源，线程只拥有必要资源(<font color='red'>线程状态+程序计数器+寄存器上下文+栈</font>)不拥有系统资源
> >
> > **3️⃣**并发性：引入线程的OS中，进程可并发，同一进程的线程也可并发
> >
> > **4️⃣**系统开销：线程切换是涉及少量寄存器内容，开销很小；进程切换需要分配/回收资源
> >
> > **5️⃣**通信：线程通信不用OS干预，通过读写进程数据段通信
>
> ## <font color='cornflowerblue'>2.4. 线程的优点</font>
>
> > **1️⃣**响应度高：多线程中即使某线程阻塞，其他线程还可以顶上，不用等待
> >
> > **2️⃣**经济性：并发执行的时空开销小(线程建立/终止/切换耗时短)，由于共享进程资源故可以减少通信频率，有助于提高并发度
> >
> > **3️⃣**多线程更利于多处理器(MP)架构
>
> ## <font color='cornflowerblue'>2.5. 内核线程与用户线程</font>
>
> > ### <font color='cornflowerblue'>2.5.1. 核级线程</font>
> >
> > > **1️⃣**含义：由OS内核创建/撤销的线程，存在于在支持内核级线程的OS中，<font color='red'>此时CPU调度的是线程</font>
> > >
> > > **2️⃣**特点：
> > >
> > > 1. 内核维护进程和线程的上下文信息并完成线程切换
> > > 2. 内核级线程IO操作阻塞时，不影响其他线程
> > > 3. <font color='red'>处理器时间片分配对象是线程</font>，多个线程的进程将获得更多处理器时间
> >
> > ### <font color='cornflowerblue'>2.5.2. 用户级线程</font>
> >
> > > **1️⃣**含义：由用户级线程库管理的线程，线程库创建/管理线程(无需内核)，<font color='red'>此时CPU调度的是进程</font>
> > >
> > > **2️⃣**特点：
> > >
> > > 1. 用户级线程切换不需要内核特权
> > > 2. 其调度在应用进程内部进行，可针对应用优化调度，调度过程简单快速(无须用户态/核心态切换)
> > > 3. 缺点在于OS不知道线程的存在，一个线程阻塞时整个进程都等待
> > > 4. 处理器时间片分配给进程，进程多线程时，每个线程执行时间减少
>
> ## <font color='cornflowerblue'>2.6. 多线程模型</font>
>
> > 首先明确一点：用户级/内核级线程通常在同一进程进行映射/管理
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231105135431105.png" alt="image-20231105135431105" style="zoom: 67%;" /> 
> >
> > **1️⃣**多对一(不可并发/开销小)：多用户级线程映射到一内核级线程
> >
> > 1. 优点：线程在用户空间管理，效率高
> > 2. 缺点：OS只能识别那个内核级线程，一个内核线程只能执行其中一个用户进程，一个用户级线程堵住进程就会堵
> >
> > **2️⃣**一对一(可并发/开销大)：一用户级线程映射到一内核级线程
> >
> > 1. 优点：一线程阻塞不影响其他线程，可以多线程并行
> > 2. 缺点：创建用户线程必须创建内核级线程，开销大
> >
> > **3️⃣**多对多(可并发/开销相对小)：多用户级线程映射到多内核级线程(内核级线程数不多于用户级线程数)，多对多模型允许真正并行，打破用户级线程限制，优化阻塞与调度
>
> ## <font color='orange'>2.7. 线程锁</font>
>
> > 锁的功能越强大，性能就越拉跨
> >
> > **1️⃣**互斥锁：信号量，确保同时只有一个线程能够访问特定的资源，一个进程有锁其它的都等待
> >
> > **2️⃣**条件锁：条件变量，允许线程在特定条件(互斥锁大哥同不同意)暂停/继续
> >
> > **3️⃣**自旋锁：与互斥锁类似，区别在于无法获得资源时，互斥锁会让线程滚/自旋锁会让线程等(不断检测锁是否可用)
> >
> > **4️⃣**读写锁：允许多线程同时读共享资源，但只允许一个线程写
>
> ## <font color='cornflowerblue'>2.8. 线程的生命周期(状态转化)</font>
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231105115655562.png" alt="image-20231105115655562" style="zoom: 33%;" /> 
> >
> > **1️⃣**初始：创建线程
> >
> > **2️⃣**就绪：创建后，通过其它运行线程调用start()方法，加入可运行线程池(就绪)
> >
> > **3️⃣**运行：就绪+CPU开始运行，**2️⃣**+**3️⃣**也称可运行状态
> >
> > **4️⃣**阻塞：线程放弃CPU使用权，暂停，可自动唤醒
> >
> > **5️⃣**等待：线程调用wait()方法，进入等待队列释放占用资源，不可自动唤醒(依赖其他线程调用notify()方法)
> >
> > **6️⃣**超时等待：与等待的区别仅在于超时等待是等一段时间，等待是一直等
> >
> > **7️⃣**终止：线程执行完了
>
> ## <font color='cornflowerblue'>PS：概念补充</font>
>
> > ### <font color='cornflowerblue'>PS.1. 线程池</font>
> >
> > > **1️⃣**含义：一组预先初始化的线程
> > >
> > > **2️⃣**工作方式：要执行某任务时免去建立线程的开销，直接调用线程池中的空闲线程去执行，执行完后也不销毁又丢回线程池
> > >
> > > **3️⃣**好处：资源消耗小，响应快
> >
> > ### <font color='cornflowerblue'>PS.2. 线程库</font>
> >
> > > **1️⃣**含义：是程序员创建和管理线程的API
> > >
> > > **2️⃣**分类：用户级线程库(POSIX Pthreads)+内核级(Win32 threads)+其他(Java thread)

# <font color='cornflowerblue'>3. CPU调度</font>

> ## <font color='cornflowerblue'>3.1. CPU的三级调度</font>
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231105151628325.png" alt="image-20231105151628325" style="zoom:50%;" /> 
> >
> > ### <font color='cornflowerblue'>3.1.1. 作业调度/高级调度/宏观调度/长程调度</font>
> >
> > > **1️⃣**内容：选取外存中后备状态的作业→装入内存/IO后建立进程→进程就绪
> > >
> > > **2️⃣**特点：效率低几分钟一次；仅在通用/批处理OS上才有作业调度，决定了有多少程序在多道运行
> > >
> > > **3️⃣**核心问题：多少作业进内存？(由规模速度决定)；哪些作业进内存？(先进外存的先进内存/短作业优先等等)
> >
> > ### <font color='cornflowerblue'>3.1.2. 中级调度/交换调度</font>
> >
> > > **1️⃣**目的：提高内存利用率/系统吞吐
> > >
> > > **2️⃣**内容：把内存中阻塞进程交换到外存对换区(挂起)，必要时再调入内存
> >
> >
> > ### <font color='cornflowerblue'>3.1.3. 低级调度/进程调度/微观调度/短程调度</font>
> >
> > > 从就绪队列→CPU执行，特点是高频
>
> ## <font color='cornflowerblue'>3.2. 调度性能评价指标(调度准则)</font>
>
> > **1️⃣**CPU利用率大：CPU被工作占用时间/总时间
> >
> > **2️⃣**系统吞吐大：单位时间CPU完成作业数(但长作业会降低吞吐)
> >
> > **3️⃣**响应时间短：**用户提交请求到系统首次做出响应的时间**
> >
> > **4️⃣**周转时间：作业从提交到完成耗时
> >
> > 1. 平均周转时间：是指多个作业(如n个作业)周转时间的平均值
> > 2. 带权周转时间：作业周转时间与作业实际运行时间(服务时间)的比
> >
> > **5️⃣**等待时间短：**进程在就绪队列中等待被调度的时间**
>
> ## <font color='cornflowerblue'>3.3. 进程调度概述</font>
>
> > ### <font color='orange'>3.3.1. 进程调度的功能</font>
> >
> > > **1️⃣**记录所有进程的状态，进程管理模块会把每个进程的状态记录在其PCB中，组织PCB队列
> > >
> > > **2️⃣**选取就绪进程获得CPU资源，开始执行(先来先服务，时间片)
> > >
> > > **3️⃣**处理器分配：在将程序从执行转为就绪/阻塞前保护CPU现场，然后从转为执行时恢复CPU现场
> >
> > ### <font color='cornflowerblue'>3.3.2. 进程调度的诱因(时机)</font>
> >
> > > **1️⃣**运行→等待：运行进程因为IO/阻塞原语等阻塞
> > >
> > > **2️⃣**运行→就绪：(抢占调度)有更高优先级程序要用CPU，(分时系统)时间片用完
> > >
> > > **3️⃣**等待→就绪：(抢占调度)执行完系统调用后返回用户进程
> > >
> > > **4️⃣**终止运行：进程运行结束(正常/出错异常)
> >
> > ### <font color='orange'>3.3.3. 不能调度的情况</font>
> >
> > > **1️⃣**在处理中断：逻辑上中断处理属于OS，不属于任一进程，时刻不能被剥夺CPU资源
> > >
> > > **2️⃣**程序进入OS kernel程序临界区：此时程序需要独占共享数据，所以要加锁防止其他程序进入，也不可切换
> > >
> > > **3️⃣**需要完全屏蔽中断的原子操作过程：加锁/解锁/中断现场保护(恢复)
> >
> > ### <font color='red'>3.3.4. 进程调度的方式</font>
> >
> > > 突然某个更紧迫的进程需要处理，CPU应该如何分配
> > >
> > > **1️⃣**非抢占方式/不可剥夺方式：优先级高的进程进入就绪队列，也要排队(等目前进程结束/阻塞后再执行)，实现简单开销小但是实时性差
> > >
> > > **2️⃣**抢占方式/剥夺方式：进程进入就绪队列，可以插队(立即暂现在进程去执行优先级高的进程)
> > >
> > > **3️⃣**抢占原则：什么进程可以插队？
> > >
> > > 1. 时间片原则(分时系统)：用完一个时间片后，停止目前程序运行并重新调度
> > > 2. 优先权原则：优先级高的进入队列，停止目前的进程，去执行优先级更高的进程
> > > 3. 短作业优先：新到达作业比执行作业明显短时，停止目前的进程，去执行优先级更高的进程
> >
> > ### <font color='cornflowerblue'>3.3.5. 分派程序</font>
> >
> > > **1️⃣**定义：OS的一部分，负责按照某种策略(优先级/轮转法)选一个就绪进程给CPU，是就绪到执行的最后一步
> > >
> > > **2️⃣**工作原理：调度器选好进程→分派程序上下文切换(保存前一进程状态/加载下个进程上下文到CPU)
> > >
> > > **3️⃣**分派延迟：分派程序终结上个进程—[分派延迟]—→启动另一个进程
> > >
> > > **4️⃣**如何降低延迟：系统调用可抢占(确保高优先级进程快速响应)+
>
> ## <font color='red'>3.4. 常见调度算法(如何把CPU分配给进程)</font>
>
> > <font color="red">调度算法影响的是等待时间，而不能影响进程真正使用CPU的时间和I/O时间</font>
> >
> > ### <font color='red'>3.4.1. 先来先服务(作业/进程调度)FCFS</font>
> >
> > > **1️⃣**概述：按进程进入就绪队列的先后来分配CPU，非抢占方式(一旦一个进程占据CPU就会一直执行)
> > >
> > > **2️⃣**特点：有利于长作业不利于短作业；有利于CPU繁忙型不利于I/O繁忙型
> > >
> > > **3️⃣**适用范围：结合其它调度策略使用，例如优先级调度策略中，用一优先级的进程就采用FCFS
> >
> > ### <font color='red'>3.4.2. 短作业优先调度算法(作业/进程调度)SJF</font>
> >
> > > **1️⃣**概述：从后备作业/进程队列选估计运行时间最短的几个调入内存，非抢占
> > >
> > > **2️⃣**特点：全部作业同时到达时SJF算法最佳(平均周转时间最短)，对长作业不利(长作业容易等到饿死)，同时也难以实现
> > >
> > > **3️⃣**最短剩余时间优先调度：SJF的抢占调度版本。当某一进程到达，其时间片比当前执行进程剩余时间片更少时，抢占调度版会强行执行新进程/非抢占调度版本会保持原有进程执行
> >
> > ### <font color='red'>3.4.3. 优先级调度算法(作业/进程调度)</font>
> >
> > > 用整数小/大区分优先级高/低，优先级高的优先分配CPU，所以优先级如何确定？
> > >
> > > #### <font color='red'>3.4.3.1. 静态优先级：进程创建时确定后不变</font>
> > >
> > > > **1️⃣**按进程类型：系统进程>用户进程，前台作业>后台作业，I/O繁忙的进程>CPU繁忙进程
> > > >
> > > > **2️⃣**按作业需要的资源：进程占据资源(CPU时间/内存大小/IO类型)越多优先级越低
> > > >
> > > > **3️⃣**按用户类型和要求：用户收费越高优先级越高(如服务器租用)
> > >
> > > #### <font color='red'>3.4.3.2. 动态优先级：优先级随进程推进而改变</font>
> > >
> > > > **1️⃣**进程使用CPU情况：使用时间越长优先级越低
> > > >
> > > > **2️⃣**进程就绪等待情况：等的越久优先级越高
> > > >
> > > > **3️⃣**进程占用资源情况：占用资源越多优先级高还是低不好说
> > >
> > > #### <font color='cornflowerblue'>PS: 一些概念</font>
> > >
> > > > **1️⃣**优先级倒置：低优先级进程占据内核数据，高优先级进程必须等
> > > >
> > > > **2️⃣**优先级继承：低优先进程用高优先资源时提升其优先级，但资源回收后其优先级又会回归原样
> >
> > ### <font color='red'>3.4.4. 时间片轮转调度(进程调度)RR</font>
> >
> > > **1️⃣**概述：进程调度程序选择就绪队列中的一个进程，执行一个时间片后将其送入队尾，去执行下一个时间片，以此类推
> > >
> > > **2️⃣**时间片多长(核心问题)：太长(所有进程一个时间片内完成)则算法就退化为FCFS，如果时间片太短则切换频繁CPU利用率不高，通常为10-100ms
> > >
> > > **3️⃣**时间片大小确定因素
> > >
> > > 1. 系统响应时间T=N×q=就绪队列中进程数×时间片大小，分时系统对时间片有要求
> > > 2. 就绪队列进程数
> > > 3. 系统处理能力：计算机速度越快，单位时间处理命令就越多，时间片越小
> > >
> > > **4️⃣**特点：
> > >
> > > 1. 平均周转时长长于SJF，但是当大多进程在一个时间片内完成，周转时间就会减少
> > > 2. 响应时间短于SJF
> >
> > ### <font color='red'>3.4.5. 高响应比(作业调度)</font>
> >
> > > FCFS+短作业优先
> > >
> > > **0️⃣**$响应比=\cfrac{响应时间}{预估运行时间}=\cfrac{作业等待时间+作业运行时间}{预估运行时间}\approx{}\cfrac{作业等待时间}{作业运行时间}+1$
> > >
> > > **1️⃣**概述：每次调度时先计算就绪队列中每个作业响应比，响应比高的优先级高
> > >
> > > **2️⃣**特点：对短作业有利(预估运行时间短)+兼顾长作业(等足够长就优先级高了)，但计算响应比增加了开销
> > >
> > > **3️⃣**与其他调度类型相比
> > >
> > > 1. 若等待时间相同，则作业越短，运行时间越短，响应比越大，优先级越高，等于SJF
> > > 2. 若运行时间相同，则先来的进程等的时间长，优先级高，等于FCFS
> >
> > ### <font color='red'>3.4.6. 多级队列(进程调度)</font>
> >
> > > **1️⃣**含义：将进程按照类型/优先级/占用资源分类，每类进程弄一个就绪队列(每个进程固定属于一个)，每个队列调度算法不一样
> > >
> > > **2️⃣**实例：就绪队列分为，前台/交互式/时间片调度，后台/批处理/FCFS
> > >
> > > **3️⃣**队列层级的调度
> > >
> > > 1. 队列优先级：比如，前台运行完后再运行后台
> > > 2. 给队列时间片：给每个队列一个时间片，80%时间执行前台，20%时间执行后台
> >
> > ### <font color='red'>3.4.7. 多级反馈队列(进程调度)</font>
> >
> > > 时间片轮转调度+优先级调度
> > >
> > > <img src="https://s2.loli.net/2023/11/05/XF3VuxfyYziS5hr.png" alt="image-20231105221135362" style="zoom:50%;" /> 
> > >
> > > **1️⃣**概述：有多个就绪队列，每个队列有优先级，各自按时间片轮转，调度允许进程跨队列移动
> > >
> > > **2️⃣**关于时间片的长度：**优先级越高的队列时间片越小**，通常第i+1队列的时间片是第i队列时间片的两倍
> > >
> > > **3️⃣**一个进程要放在什么优先级的队列中？(优先级从上到下减小)
> > >
> > > 1. 新进程先进入第一队列末尾(FCFS调度)，随之被执行一个时间片，若执行完就退出
> > >
> > > 2. 若一时间内未执行完，就把他丢到第二个队列尾(FCFS调度)，以此类推
> > > 3. 若进程到了优先级最低队列都没执行完，就只有重新塞回本队列尾了
> > >
> > > PS: 阻塞进程的优先级低于以上一切队列
> > >
> > > **4️⃣**按什么顺序执行优先级不同的队列？
> > >
> > > 1. 优先执行优先级高的队列：只当第一队列空才执行第二队列进程
> > >
> > > 2. 抢占：执行第二队列进程时，有一进程插入第一队列，则转而执行插入进程(第二队列原来的进程丢到队尾)
>
> ## <font color='cornflowerblue'>3.5. 多处理器调度</font>
>
> > **1️⃣**对称多CPU(SMP)：每个CPU都有自己调度方案，他们互斥访问<font color='red'>公共就绪队列</font>，领取进程执行
> >
> > **2️⃣**非对称多CPU(AMP)：只有一个CPU能管理OS资源，其余执行用户级任务，数据共享更容易
> >
> > PS：进程从一个CPU到另一个CPU需要更新Cache所以开销大，SMP不允许进程迁移到另一个CPU
>
> ## <font color='cornflowerblue'>3.6. 实时调度：基于优先级+抢占</font>
>
> > **1️⃣**目的：完成实时任务()而分配CPU的调度方法
> >
> > **2️⃣**实时任务：硬实时(规定时间内必须执行完)+软实时(允许偶尔的延迟)
> >
> > **3️⃣**实现：基于优先级调度，任何时候实时进程优先级最高，调度延时小

# 4. 同步与互斥

> ## <font color='cornflowerblue'>4.1. 进程同步的基本概念</font>
>
> > **1️⃣**背景：多个进程对数据并发访问会导致数据不一致(如共享变量修改)，所以要保证并发进程按顺序执行
> >
> > **2️⃣**进程类型：协作进程、独立进程
> >
> > **3️⃣**进程间的制约关系
> >
> > 1. 间接互相制约关系(互斥)：进程-资源-进程。同种进程互斥共享某种系统资源，如打印机
> >
> > 2. 直接互相制约关系(同步)：进程-进程。一进程收到另一进程的必要信息，才能继续运行
> >
> > PS: 一般同类进程互斥，不同进程同步
> >
> > **4️⃣**进程间的交互关系
> >
> > 1. 互斥：多个进程不能同时使用同一个资源
> > 2. 同步：异步执行过程中，相合作的进程在关键点互相等待/交换信息
> > 3. 死锁：多个进程互不相让，都得不到足够的资源
> > 4. 饥饿：资源被其他进程轮奸，该进程一直得不到它
>
> ## <font color='red'>4.2. 临界资源与临界区</font>
>
> > **1️⃣**临界资源：只能同时给一个进程使用的资源，比如打印机
> >
> > **2️⃣**临界区：<font color='red'>进程中访问**临界资源**的一段代码</font>，每进程都有一段临界区代码(可不同)，在该区中进程可修改共享变量等，一个进程在其临界区时，同类进程都不可以进入临界区
> >
> > **3️⃣**访问临界资源的过程：
> >
> > 1. 进入区：检查**可否进入**临界区的一段代码，若可以则设置相应“正在访问临界区”标志
> > 2. 临界区：
> > 3. 退出区：属于临界区，清除“正在访问临界区”标志
> > 4. 剩余区：代码其余部分
> >
> > **4️⃣**进程对临界区互斥访问的实现
> >
> > 1. 空闲则入：临界区无进程时，进程请求加入临界区就进吧
> > 2. 忙则等待：临界区有进程了，禁止其他请求进入临界区的请求
> > 3. 有限等待：进程请求访问临界资源后，就应该在有限时间内加入临界区，不死等
> > 4. 让权等待：一个进程不能进入自己的临界区时，释放处理器阻塞自己
>
> ## <font color='cornflowerblue'>4.3. 互斥的实现方式</font>
>
> > ### <font color='cornflowerblue'>4.3.1. 软件方法(困难复杂)</font>
> >
> > > **1️⃣**算法1：两个进程P0，P1使用公共变量turn来实现交替进入临界区
> > >
> > > ```Cpp
> > > int turn = 0;   
> > > void processP0()       //进程P0
> > > {
> > >  while(true)           //无限循环，表示进程的持续执行
> > >  { 
> > >      while(turn != 0); //不为0就卡在这，直到turn为0，P0进入临界区
> > >      /*进程P0的代码区*/
> > >      turn = 1;         //退出区
> > >      /*进程P0其它代码*/
> > >  }
> > > }
> > > void processP1()          //进程P1
> > > {
> > >  while(true)           //无限循环，表示进程的持续执行
> > >  { 
> > >      while(turn != 1); //不为1就卡在这，直到turn为1，P1进入临界区
> > >      /*进程P1的代码区*/
> > >      turn = 0;         //退出区
> > >      /*进程P0其它代码*/
> > >  }
> > > }
> > > ```
> > >
> > > 1. 强制轮流进入临界区，没有考虑进程的实际需要
> > >
> > > 2. 不保证空闲则入：一个进程处于非临界区(即便临界区空闲)，另一个进程也进不去临界区
> > >
> > >    例如：P0执行完后，置turn=1他自己就进不去了，而P1此时也没请求进入，临界区就空了
> > >
> > > **2️⃣**算法2：设置标志数组flag[]表示进程是否在临界区中执行
> > >
> > > ```Cpp
> > > /*每个进程访问临界资源前，检查另一个进程是否在临界区中
> > > *若不在，则修改本进程的临界区标志为真并进入临界区
> > > *退出时，在退出区修改本进程临界区标志为假*/
> > > bool flag[2] = {0,0};     //初始均为假
> > > void processP0()          //进程P0
> > > {
> > >     while(true)           //无限循环，表示进程的持续执行
> > >     { 
> > >         while(flag[1]);   //不为0就卡这，直到falg[1]=0(P1退出临界区了)，P0进入临界区
> > >         flag[0] = 1;      //声明我P0进程在临界区
> > >         /*进程P0的代码区*/
> > >         flag[0] = 0;      //退出区
> > >         /*进程P0其它代码*/
> > >     }
> > > }
> > > void processP0()          //进程P1
> > > {
> > >     while(true)           //无限循环，表示进程的持续执行
> > >     { 
> > >         while(flag[0]);   //不为0就卡这，直到falg[0]=0(临界区没东西了)，P1进入临界区
> > >         flag[1] = 1;
> > >         /*进程P1的代码区*/
> > >         flag[1] = 0;      //退出区
> > >         /*进程P1其它代码*/
> > >     }
> > > }
> > > ```
> > >
> > > 1. 此算法保证空闲让进，不保证忙则等待
> > > 2. 会出现死锁：想象如下场景
> > >
> > > P0置flag[0]=0退出→P0执行剩余代码(此时: P1进入临界区→快速执行完后置flag[1]=0)→此时flag数组中两项都为0→两个进程都要进入临界区→都进不了，死锁
> > >
> > > **3️⃣**算法3：设标志组flag(进程是否希望进入临界区)
> > >
> > > ```Cpp
> > > bool flag[2] = {0, 0};       // 初始化为假，表示两个进程初始时都不希望进入临界区
> > > void processP0()             // 进程P0
> > > {
> > >     while(true)              // 无限循环，表示进程的持续执行
> > >     {
> > >         flag[0] = 1;         // 声明进程P0希望进入临界区
> > >         while(flag[1]);      // 如果进程P1也希望进入，则等待      
> > >         /* 进程P0的代码区*/
> > >         flag[0] = 0;         // 进程P0不再希望进入临界区
> > >         /* 进程P0其它代码*/
> > >     }
> > > }
> > > void processP1()             // 进程P1
> > > {
> > >     while(true)              // 无限循环，表示进程的持续执行
> > >     {
> > >         flag[1] = 1;         // 声明进程P1希望进入临界区
> > >         while(flag[0]);      // 如果进程P0也希望进入，则等待
> > >         /* 进程P1的代码区*/
> > >         flag[1] = 0;         // 进程P1不再希望进入临界区
> > >         /* 进程P1其它代码*/
> > >     }
> > > }
> > > 
> > > ```
> > >
> > > 1. 不满足有限等待：一个进程一直执行，另一个就一直无法进入
> > > 2. 防止了两进程同时进入临界区，但可能两个进程都进不了临界区(都表示不希望进入)
> > >
> > > **4️⃣**在算法**3️⃣**基础上加上一个turn变量，turn=0/1表示允许P0/P1进程访问临界区
> > >
> > > ```Cpp
> > > bool flag[2] = {0, 0};               // 初始化为假，表示两个进程初始时都不希望进入临界区
> > > int turn = 0;                        // 初始时，让进程P0先进入
> > > void processP0()                     // 进程P0
> > > {
> > >     while(true)                      // 无限循环，表示进程的持续执行
> > >     {
> > >         flag[0] = 1;                 // 声明进程P0希望进入临界区
> > >         turn = 1;                    // 此时P0还没进去，让进程P1还有机会进入
> > >         while(flag[1] && turn == 1); // 如果进程P1也希望进入且turn为P1，则等待    
> > >         /* 进程P0的代码区 */
> > >         flag[0] = 0;                 // 进程P0退出临界区
> > >         /* 进程P0其它代码 */
> > >     }
> > > }
> > > 
> > > void processP1()                     // 进程P1
> > > {
> > >     while(true)                      // 无限循环，表示进程的持续执行
> > >     {
> > >         flag[1] = 1;                 // 声明进程P1希望进入临界区
> > >         turn = 0;                    // 此时P1还没进去，让进程P0还有机会进入
> > >         while(flag[0] && turn == 0); // 如果进程P0也希望进入且turn为P0，则等待
> > >         /* 进程P1的代码区 */
> > >         flag[1] = 0;                 // 进程P1不再希望进入临界区
> > >         /* 进程P1其它代码 */
> > >     }
> > > }
> > > ```
> >
> > ### <font color='cornflowerblue'>4.3.2. 硬件方法(当前主流)</font>
> >
> > > **1️⃣**主要思想：通过硬件指令/中断屏蔽，确保关键代码段在不被打断的情况下连续执行，从而保障进程间的互斥访问
> > >
> > > **2️⃣**优势：适用广(进程数随意/处理器数随意)，简单(容易验证正确性)，支持多临界区
> > >
> > > **3️⃣**缺点：不能让权等待(只能忙等耗费CPU时间)，看你饥饿(有的进程可能一直选不上到临界区)
> > >
> > > <font color='red'>PS—让全等待：进程抛弃CPU资源等待，区别于不放弃CPU的忙则等待</font>
>
> ## <font color='red'>4.4. 信号量semaphore(Dijkstra提出的同步机构)</font>
>
> > 之前的互斥算法都是平等进程间的协商，信号量使得有一个更高地位的进程管理者来分配资源
> >
> > ### <font color='red'>4.4.1. 信号量及同步原语</font>
> >
> > > **1️⃣**信号量是一个二元组 [s,q] ——且初值非负，q为初始为空的队列
> > >
> > > 1. s是信号量的值：初值非负表示可用资源数，其值只能被P(wait)操作/V(signal)操作改变
> > > 2. q是初始为空的队列：就是该信号量的进程**等待队列**
> > >
> > > **2️⃣**P/V操作：申请/释放资源，二者成对出现，被视为不可分割原子操作
> > >
> > > 1. 原始版本：会忙则等待，s>0表示可用资源数，s不可为负数
> > >
> > >    ```Cpp
> > >    P(S);
> > >    {
> > >        if(S<=0);    //不做仍和操作
> > >        if(S>0) S--; //一个资源被申请走了，所以信号量的值减少
> > >    }
> > >    V(S){S++;}       //一个资源被释放了，信号量增加
> > >    ```
> > >
> > > 2. 改进版：不会忙则等待，s>0表示可用资源数，s<0表示请求该资源而阻塞的进程数(绝对值)
> > >
> > >    ```Cpp
> > >    /*详见记录型信号量*/
> > >    ```
> >
> > ### <font color='red'>4.4.2. 信号量的分类</font>
> >
> > > **1️⃣**整型信号量：就是上面所提到的(int)s，只有初始化/p/v操作可以改变s。存在忙等，因为P操作后若无资源进程会持续测试s直到其有资源了
> > >
> > > **2️⃣**记录型信号量：int s + 链表q(链接了等待该资源的进程)。P操作后无资源则进程自我阻塞放弃CPU，插入等待链表(让权等待)，V操作时唤醒链表中第一个程序
> > >
> > > ```Cpp
> > > typedef struct
> > > {
> > >  int value;
> > >  struct process *L;
> > > }semaphore;
> > > 
> > > semaphore s;
> > > 
> > > P(s)
> > > {
> > >  s.value--;     //可用资源数-1，或者等待资源进程数+1
> > >  if(s.value<0)  //如果已经没有可用资源了
> > >  {/*将该进程加入到s.L中去，然后阻塞*/}
> > > }
> > > V(s)
> > > {
> > >  s.value++;     //可用资源数+1，或者等待资源进程数-1
> > >  if(s.value<=0) //如果此刻正在有进程等待这个资源
> > >  {/*将该进程从s.L中移除，然后唤醒*/}
> > > }
> > > ```
> >
> > ### <font color='red'>4.4.3. 信号量的应用</font>
> >
> > > <font color='red'>PV操作成对出现，同步时PV不在一个进程，互斥时PV在同一进程</font>
> > >
> > > **1️⃣**同步进程：P1(含S1),P2(含S2)两进程并发，S1要在S2之前执行
> > >
> > > ```Cpp
> > > int N=0;               //信号量，初值为0
> > > P1(){...;S1;V(N);...}  //执行S1，后通过V操作增加信号量N的值，这表示S1已执行完毕
> > > P2(){...;P(N);S2;...}  //P操作试图减少信号量N的值但被阻塞，S1执行完N增加后才执行S2
> > > ```
> > >
> > > 举例：S1生成S2/S3，S2继续生成S4/S5，最后S3/S4/S5一起生成S6。如下总结就是入为P出为V<img src="https://s2.loli.net/2023/11/06/JUOtPLrDd6jAa5X.png" alt="image-20231106152151664" style="zoom:59%;" /> 
> > >
> > > **2️⃣**进程互斥：P1,P2只有一个进程可以进入自己的临界区
> > >
> > > ```Cpp
> > > int N=1; //互斥信号量，初值为1，只有一个进程可以获得资源
> > > P1(){...;P(N);P1的临界区代码;V(N);...} //临界区代码置于P/V原语之间
> > > P2(){...;P(N);P2的临界区代码;V(N);...} 
> > > ```
> > >
> > > 反过来想，如果P12同时进入临界区N就会变成负数，不可能的，所以只能进入一个
> > >
> > > :waning_crescent_moon:相连两个P操作，同步P应该在互斥P之前(先检查是否满足同步再进入临界区)，但是二者的V操作顺序无关紧要
> >
> > ### <font color='cornflowerblue'>4.4.4. 信号量集：多个信号量的集合</font>
> >
> > > **1️⃣**概述：用于处理复杂进程同步/互斥，允许进程在执行操作前同时检查多个信号量
> > >
> > > **2️⃣**AND信号量集：
> > >
> > > 1. 功能：保证代码执行前获得多有临界资源(避免锁死)
> > > 2. 原子操作Swait：要么一次分配所有资源，要么一个都不分配，防止中间态而死锁
> > > 3. 操作Ssignal：释放所有资源，检查等待队列中是否有其他简称能因此获得全部资源
> > >
> > > **3️⃣**一般信号量集：AND信号量集的扩展
> > >
> > > 1. 允许进程请求/释放不同数目的多种资源
> > > 2. `Swait(S1, t1, d1; ...; Sn, tn, dn)`：对每个信号量Si，都设置测试值ti+占用值di
> > >
> > > ```txt
> > > Swait(S,m,n);               //S每次申请m个资源，不够则阻塞，够则S减n
> > > Swait(S1,m1,n1; S2,m2,n2)   //S1,S2每次申请m1,m2个资源，不够则阻塞，够则分别减n1,n2
> > > Swait(S,1,1)                //表示互斥信号量；
> > > Swait(S,1,0)                //作为一个可控开关
> > > ```
> > >
> > > 3. `Ssignal(S1, d1; ...; Sn, dn)`：对每个信号量，只设置占用值di
> > >
> > > ```txt
> > > Ssignal(S,n)                //释放n个资源S=S+n
> > > Ssignal(S1,n1; S2,n2)       //S1=S1+n1，S2=S2+n2
> > > ```
>
> ## <font color='cornflowerblue'>4.5. 经典同步问题</font>
>
> > ### <font color='cornflowerblue'>4.5.1. 生产者-消费者问题</font>
> >
> > > **1️⃣**问题描述：进程通过共享缓冲区交换数据，生产者写入/消费者读出，共享缓冲区共N个但一个时刻只有一个进程可操作缓冲区
> > >
> > > <img src="https://s2.loli.net/2023/11/06/Klj1LXDouQRzM7I.png" alt="image-20231106173803349" style="zoom: 50%;" /> 
> > >
> > > **2️⃣**三种信号量激起初值
> > >
> > > ```Cpp
> > > Semaphore full=0;           //表示当前已满的缓冲区数量
> > > Semaphore empty=n;          //表示当前空的缓冲区数量
> > > Semaphore mutex=1;          //互斥信号量，用于确保同一时刻只有一个进程对缓冲区进行操作
> > > ```
> > >
> > > **4️⃣**P/V操作
> > >
> > > ```Cpp
> > > P(empty) //检查是否有空余位来填充，若没有则阻塞直到有空位
> > > V(empty) //填充完了一个空闲区
> > > P(full)  //检查缓冲区是否有数据可以来取，若没有就阻塞直到有数据可读
> > > V(full)  //
> > > P(mutex) //取得互斥锁，告诉其他进程临界区我占了你们都别来
> > > V(mutex) //释放互斥锁，高速
> > > ```
> > >
> > > **4️⃣**实现：P操作顺序不可倒<font color='red'>(先检查资源数目，再检查是否互斥)</font>否则可能死锁
> > >
> > > 死锁情况：生产者先执行P(mutex)进入缓冲区→缓冲区满但执行P(empty)→没有空位然后阻塞
> > >
> > > <img src="https://s2.loli.net/2023/11/06/6JHK2DLbpVmBvNY.png" alt="image-20211019172156100" style="zoom: 50%;" /> 
> >
> > ### <font color='cornflowerblue'>4.5.2. 读者-写者问题</font>
> >
> > > 多进程共享数据区，进程分为读者写者(读者只能读/写者只能写)，<font color='red'>同一时刻可多读但最多一写</font>
> > >
> > > #### <font color='cornflowerblue'>4.5.2.1. 读者优先：写者排队，读者插队，多读一写</font>
> > >
> > > > **1️⃣**示例：(最左边表示最新到达的进程)
> > > >
> > > > ```txt
> > > > [W][W][W][W][W]-[数据区:R]--读者优先+R读完后-->[ ][W][W][W][W]-[数据区:W]
> > > > [R][W][R][R][W]-[数据区:W]--读者优先+W写完后-->[ ][ ][ ][W][W]-[数据区:RRR]
> > > > [R][W][R][R][W]-[数据区:R]--不可能出现这种情况
> > > > [R][W][W][W][W]-[数据区:R]--读者优先+R没读完-->[ ][W][W][W][W]-[数据区:RR]
> > > > ```
> > > >
> > > > **2️⃣**信号量
> > > >
> > > > ```Cpp
> > > > readcount=0//记录读者的数量
> > > > rmute=1    //保证读者进程对readcount的互斥访问(只有当前的唯一读者可修改readcount)
> > > > mutex=1    //标识允许写
> > > > ```
> > > >
> > > > **3️⃣**实现
> > > >
> > > > ```Cpp
> > > > reader()
> > > > {
> > > >  while(1)
> > > >  {
> > > >      P(remutex);               //申请readcount的使用权
> > > >      if(readcount==0);P(mutex);//第一个读者，阻止写入
> > > >      readcount++;              //读者数量+1
> > > >      V(rmutex);                //释放readcount的使用权，允许其他读者读
> > > >      /*读操作，完成读操作后：*/
> > > >      P(remutex);               //申请readcount的使用权
> > > >      readcount--;              //读者数量-1
> > > >      if(readcount==0);V(mutex);//读者全部读完了，就允许写入
> > > >      V(rmutex);                //释放readcount的使用权，允许其他读者读  
> > > >  }
> > > > }
> > > > write()
> > > > {
> > > >  while(ture)
> > > >  {
> > > >      P(mutex);                  //允许写
> > > >      /*写操作，完成写操作后：*/
> > > >      V(mutex);                  //释放写的许可
> > > >  }
> > > > }
> > > > ```
> > >
> > > #### <font color='cornflowerblue'>4.5.2.2. 平等策略：读者写者都要排队，不可插队，仍然多读一写</font>
> > >
> > > > **1️⃣**示例：(最左边表示最新到达的进程)
> > > >
> > > > ```txt
> > > > [W][W][R][R][R]-[数据区:W]--平等策略+W写完后-->[ ][ ][ ][W][W]-[数据区:RRR]
> > > > [W][W][R][R][R]-[数据区:R]--这种情况不可能出现
> > > > [R][W][R][W][W]-[数据区:R]--平等策略+R读完后-->[ ][R][W][R][W]-[数据区:W]
> > > > ```
> > > >
> > > > **2️⃣**信号量
> > > >
> > > > ```Cpp
> > > > readcount=0//记录读者的数量
> > > > rmute=1    //保证读者进程对readcount的互斥访问(只有当前的唯一读者可修改readcount)
> > > > mutex=1    //标识允许写
> > > > wmutex=1： //是否存有在写/等着写的写者，存在的话就禁止新读者进入
> > > > ```
> > > >
> > > > **3️⃣**实现
> > > >
> > > > ```Cpp
> > > > reader()
> > > > {
> > > >  while(1)
> > > >  {
> > > >      P(wmutex);                //是否有写者存在(多读一写→不可能全是读者等)，无则进
> > > >      P(remutex);               //申请readcount的使用权
> > > >      if(readcount==0);P(mutex);//如果这是第一个读者，那么占据数据区阻止其他写着进入
> > > >      readcount++;              //读者数量+1
> > > >      V(rmutex);                //释放readcount的使用权，允许其他读者用
> > > >      V(wmutex);                //恢复wmutex
> > > >      /*读操作，完成读操作后：*/
> > > >      P(remutex);               //申请readcount的使用权
> > > >      readcount--;              //读者数量-1
> > > >      if(readcount==0);V(mutex);//如果读者都没有了，就允许写者进入
> > > >      V(rmutex);                //释放readcount的使用权，允许其他读者使用    
> > > > }
> > > > }
> > > > write()
> > > > {
> > > >  while(ture)
> > > >  {
> > > >      P(wmutex);                //检测是否有其他写者存在，无写者时进入
> > > >      P(mutex);                 //申请对数据区进行访问
> > > >      /*写操作，完成写操作后：*/
> > > >      V(mutex);                 //释放数据区，允许其他进程读写
> > > >      V(wmutex);                //恢复wmutex
> > > >  }
> > > > }
> > > > ```
> > >
> > > #### <font color='cornflowerblue'>4.5.2.3. 写者优先：读者排队，写者插队，多读一写</font>
> > >
> > > > **1️⃣**示例：(最左边表示最新到达的进程)
> > > >
> > > > ```txt
> > > > [W][W][R][R][R]-[数据区:W]--写者优先+W写完后-->[ ][W][R][R][R]-[数据区:W]
> > > > [ ][W][R][R][R]-[数据区:W]--写者优先+W写完后-->[ ][ ][R][R][R]-[数据区:W]
> > > > [ ][ ][R][R][R]-[数据区:W]--写者优先+W写完后-->[ ][ ][ ][ ][ ]-[数据区:RRR]
> > > > ```
> > > >
> > > > 队列中有读者写者时，先按顺序执行完所有写者，然后才开始执行读者
> > > >
> > > > **2️⃣**信号量
> > > >
> > > > ```Cpp
> > > > readcount=0 //记录读者的数量
> > > > writecount=0//记录写者的数量
> > > > rmutex=1    //保证读者进程对readcount的互斥访问(只有当前的唯一读者可修改readcount)
> > > > wmutex=1    //保证写者进程对writecount的互斥访问
> > > > mutex=1     //互斥访问数据区
> > > > readable=1  //表示当前是否有写者
> > > > ```
> > > >
> > > > **3️⃣**实现
> > > >
> > > > ```Cpp
> > > > reader()
> > > > {
> > > >  while(1)
> > > >  {
> > > >      P(readable)               //检查是否存在写者，若没有则占用
> > > >          P(remutex);               //申请readcount的使用权
> > > >      if(readcount==0);P(mutex);//如果这是第一个读者，那么占据数据区阻止其他写着进入
> > > >      readcount++;              //读者数量+1
> > > >      V(rmutex);                //释放readcount的使用权，允许其他读者使用
> > > >      V(readable);              //释放readable,允许其他读者或写者占用
> > > >      /*读操作，完成读操作后：*/
> > > >      P(remutex);               //申请readcount的使用权
> > > >      readcount--;              //读者数量-1
> > > >      if(readcount==0);V(mutex);//如果读者都没有了，就允许写者进入
> > > >      V(rmutex);                //释放readcount的使用权，允许其他读者使用    
> > > >  }
> > > > }
> > > > write()
> > > > {
> > > >  while(ture)
> > > >  {
> > > >      P(wmutex);                //检测是否有其他写者存在，无写者时进入
> > > >      if(writecount==0)
> > > >          P(readable);              //若为第一个写者，则阻止后续读者进入
> > > >      writecount++;             //写者数量加1
> > > >      V(wmutex);                //释放wmutex,允许其他写者修改writecount
> > > >      P(mutex);                 //等当前正在操作的读者或写者完成后，占用数据区
> > > >      /*写操作，完成写操作后：*/
> > > >      V(mutex);                 //写完，释放数据区，允许其他进程读写
> > > >      P(wmutex);                //占用wmutex,准备修改writecount
> > > >      writecount--;             //写者数量减1
> > > >      if(writecount==0)
> > > >          V(readable);              //若为最后一个写者，则允许读者进入
> > > >      V(wmutex);                //释放wmutex,允许其他写者修改writecount
> > > >  }
> > > > }
> > > > ```
> >
> > ### <font color='cornflowerblue'>4.5.3. 哲学家进餐问题</font>
> >
> > > **1️⃣**问题描述：5人围桌而坐，两人间各一根筷子(临界资源)，每人有两个动作，进餐(先左后右拿起筷子)和思考(先左后右放回筷子)
> > >
> > > **2️⃣**死锁：所有人都同时拿起左筷子，同时等待右筷子(但等不到)
> > >
> > > **3️⃣**避免死锁：赶走一个人/同时拿起左右筷子/给人编号然后奇数先拿左边偶数先拿右边再奇偶交替
> >
> > ### <font color='orange'>4.5.4. 理发师问题</font>
> >
> > > **1️⃣**描述：理发师+理发椅+等待椅，无顾客时理发师就会在理发椅上睡觉，顾客到达会唤醒理发师，理发时新顾客会在等待椅空闲/满时选择等待/离开
> > >
> > > **2️⃣**问题核心：保证顾客对于理发师的互斥访问，确保等待队列满后顾客会走，服务完一个顾客后会服务下一个顾客
> > >
> > > **3️⃣**解决方案：使用信号量来控制对临界资源的访问
> > >
> > > 1. 5个信号量：记录等待顾客数，代表理发椅，代表等待凳子，两个记录理发师和顾客的同步
> > > 2. 临界资源：凳子和理发椅
>
> ## <font color='cornflowerblue'>4.6. 管程：优于信号量的进程同步机构(了解即可)</font>
>
> > <img src="https://s2.loli.net/2023/11/06/IXcmYpQklBH2CLg.png" alt="image-20231106214404038" style="zoom: 67%;" /> 
> >
> > **1️⃣**定义：关于共享资源的数据结构及一组针对该资源的操作过程所构成的软件模块
> >
> > **2️⃣**基本思想：把信号量+操作原语(共享变量+对共享变量的操作)封装在一个对象内部
> >
> > **3️⃣**功能：集中管理进程中互斥访问的临界区，保证进程对于共享资源的互斥访问
> >
> > **4️⃣**特点：局部于管程的数据只能被管程内部访问，进程只有通过调用进入管程才能访问共享数据，每次只允许一个进程调用管程
> >
> > **5️⃣**管程的同步设施
> >
> > 1. 条件变量：仅能从管程内进行访问，用于表示进程不同的等待原因
> > 2. wait和signal函数：进程调用wait后会被阻塞然后释放管程，调用signal唤醒在该条件变量上阻塞的进程

# <font color='cornflowerblue'>5. 死锁</font>

> ## <font color='cornflowerblue'>5.1. 死锁概念于特征</font>
>
> > **1️⃣**概念：两个及以上进程互相等待对方资源，无外力作用就无法推进执行
> >
> > **2️⃣**实例：进程P1占用打印机且申请IO设备，进程2占用IO但是申请打印机
> >
> > **3️⃣**死锁的特点：
> >
> > 1. 互斥：对于资源，一次性只能有一个进程访问
> > 2. 占有并等待：进程至少占有一个进程，等待另一个被其他进程占有的资源
> > 3. 不可抢占：进程要在执行完后才释放资源，不会中途被抢走
> > 4. 循环等待：等待资源的进程间存在环
> >
> > 总结：至少两个占有资源但又等待资源的进程才会产生死锁
>
> ## <font color='cornflowerblue'>5.2. 死锁的必要条件</font>
>
> > ### <font color='cornflowerblue'>5.2.1. OS的资源分类</font>
> >
> > > **1️⃣**根据资源性质(事实上进程可抢占与否完全取决于资源类型)
> > >
> > > 1. 可剥夺/抢占资源：别的进程可以从本进程处把这个资源抢走(打印机)
> > > 2. 不可剥夺/抢占资源：除非本进程释放，别的进程根本抢不走(主存/CPU)
> > >
> > > **2️⃣**根据使用方式：共享/独占资源
> > >
> > > PS—共享资源的获取与释放：请求然后得到资源(不被立即允许时一直等待)→使用→释放
> > >
> > > **3️⃣**根据使用期限：永久资源(无法被消耗，如打印机)+临时资源(可以被消耗殆尽，如内存)
> >
> > ### <font color='cornflowerblue'>5.2.2. 死锁产生的原因</font>
> >
> > > 并发执行的资源竞争+系统资源不足(根本原因)+进程推进顺序不当(直接原因)
> > >
> > > 如下图只有4(落入虚线方框内)会锁死
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231021124027431.png" alt="image-20231021124027431" style="zoom:50%;" />  
> >
> > ### <font color='orange'>5.2.3. 进程锁死的必要条件</font>
> >
> > > **1️⃣**互斥条件：一段时间内某种资源仅为一个进程占有
> > >
> > > **2️⃣**不剥离条件：资源在未使用完之前，不能被其他进程夺走
> > >
> > > **3️⃣**请求与保持条件：进程申请新资源的同时，继续占有以获得的资源 
> > >
> > > **4️⃣**环路等待条件：如下
> > >
> > > 1. 进程P1已经拥有资源A，但它还需要资源B来继续运行
> > > 2. 进程P2已经拥有资源B，但它还需要资源C来继续运行
> > > 3. 进程P3已经拥有资源C，但它还需要资源A来继续运行
>
> ## <font color='cornflowerblue'>5.3. 死锁的处理</font>
>
> > **1️⃣** 鸵鸟算法：不对死锁进行任何处理，如UNIX，降低了系统复杂性/但死锁时会导致资源浪费和响应延长
> >
> > **2️⃣** 死锁预防：设置严格限制来破坏死锁的必要条件，如可剥夺式的进程调度(优先级)，系统是永远不会死锁了/但会对影响并发性的性能
> >
> > **3️⃣** 死锁避免：分配资源时OS会预测接下来会不会死锁(再决定要不要这么分配资源)，如银行家算法，比死锁预防更有利于并发执/但预测操作会增加计算成本
> >
> > **4️⃣** 死锁检测及解除：(被动策略)OS定期检索是否死锁然后在死锁后采取措施，如剥终止or剥夺某进程资源来打破死锁，OS可以在大多数时间内高效地运行，但死锁后代价大
>
> ## <font color='cornflowerblue'>5.4. 死锁的预防：四个必要条件各个击破</font>
>
> > **1️⃣**互斥条件：资源只能给一个进程→能给多个进程，但是这会打破进程固有属性(两个进程公用打印机？)所以不实际
> >
> > **2️⃣**不剥夺(非抢占)条件：进程持有资源后就霸占→若该进程新的资源请求不被满足就放弃之前已经有的资源，但是这太复杂还可能造成以前工作作废(打印到一半丢掉)
> >
> > **3️⃣**请求与保持条件：进程持有资源后请求其他资源→强制进程一次性申请得到所有资源后再运行，但是这样资源利用率低且进程容易饥饿
> >
> > **4️⃣**环路等待条件：将所有的资源类型放入资源列表中，并且要求进程按照资源表申请资源；编号递增申请，但限制了新设备的增加(重写编号)，吞吐量低
>
> ## <font color='cornflowerblue'>5.5. 死锁的避免：相比死锁的预防限制更弱</font>
>
> > ### <font color='cornflowerblue'>5.5.1. 安全/不安全状态</font>
> >
> > > **1️⃣**基本概念
> > >
> > > 1. 安全状态：系统按某顺序(安全序列，不唯一)为每进程分配其所需资源，保证每个进程都可顺利完成
> > > 2. 不安全状态：不存在上述的安全顺序，但是不一定所有不安全状态都有死锁，只是可能(有些资源执行到一半就放弃了)
> > >
> > > **2️⃣**安全状态实例：P1-3共享一个资源，资源总数为10
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231021145042920.png" alt="image-20231021145042920" style="zoom: 67%;" /> 
> > >
> > > 可用资源按照P2→P1→P3顺序配是安全的(安全序列)，如果可用资源先分给P1就会直接锁死
> > >
> > > **3️⃣**死锁避免的核心：使OS一直处于安全状态之一的状态
> > >
> > > 分配资源前先计算分配的安全性→确认能安全分配再分配
> >
> > ### <font color='cornflowerblue'>5.5.2. 资源分配图算法：每种资源只有一个实例</font>
> >
> > > **1️⃣**请求边与需求边
> > >
> > > 1. 请求边：实线$<P_i,r_i>$表示$P_i$请求一个$r_i$资源且尚未分配
> > > 2. 需求边：虚线$<P_i,r_i>$表示$P_i$可能会请求一个$r_i$资源
> > > 3. 转化：申请资源后虚线转实线，释放资源后实现转虚线
> > >
> > > **2️⃣**死锁预防
> > >
> > > 把申请边实线$<P_i,r_i>$转化为分配边$<r_i,P_i>$，如果出现环路则不安全，如果不出现环路那么安全可分配
> >
> > ### <font color='red'>5.5.3. 银行家算法：每种资源可有多个实例</font>
> >
> > > #### <font color='red'>5.5.3.1. 算法中用到的数据结构</font>
> > >
> > > > 假设有进程$(P_1,P_2\dots{}P_n)$and资源$(R_1,R_2\dots{}R_m)$，则用到的数据结构
> > > >
> > > > ```Cpp
> > > > Available[i]     //可用资源向量,表示第Ri类资源的现有空闲数量
> > > > Request[i][j]    //请求矩阵，表示进程Pi请求的Rj类资源的数量
> > > > max[i][j]        //最大需求矩阵，表示进程Pi对Rj类资源最大需求数
> > > > Allocation[i][j] //分配矩阵，进程Pi对Rj类资源的持有数
> > > > Need[i][j]       //需求矩阵，进程Pi对Rj类资源仍然需要的数目
> > > > Need[i]          //Pi的资源需求向量，即所需全部资源类型及数目
> > > > ```
> > > >
> > > > ```Cpp
> > > > Need[i] [j] = Max[i] [j] - Allocation[i] [j]
> > > > ```
> > >
> > > #### <font color='red'>5.5.3.2. 银行家算法的描述</font>
> > >
> > > > **1️⃣**银行家算法
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231021162811157.png" alt="image-20231021162811157" style="zoom: 67%;" /> 
> > > >
> > > > **2️⃣**安全性检测算法：
> > > >
> > > > 1. 先要建立两个向量Work(可用资源)和Finish(进程结束)
> > > >
> > > >    ```Cpp
> > > >    Work=Available;
> > > >    Finish[i]=false; //表示Pi进程还未执行完
> > > >    ```
> > > >
> > > > 2. 找到符合条件的进程：未结束+所需资源小于系统可用
> > > >
> > > >    2.1. 如果有这样的进程则执行完进程后释放其所有资源Allocation
> > > >
> > > >    2.2. 找不到这样的进程的话有两种可能，那就是全部执行完了(安全)，否则不安全
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231021163115979.png" alt="image-20231021163115979" style="zoom: 50%;" />  
> > >
> > > #### <font color='red'>5.5.3.3. 银行家算法实例</font>
> > >
> > > > **1️⃣**题目
> > > >
> > > > <img src="https://s2.loli.net/2023/11/07/bkZsDq4A3aYgoXW.jpg" alt="563daa44d9b206705f945f93d137834" style="zoom: 40%;" />  
> > > >
> > > > **2️⃣**解答
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/FTIMdLoWaHBiRem.png" alt="FTIMdLoWaHBiRem" style="zoom: 67%;" /> 
>
> ## <font color='cornflowerblue'>5.6. 死锁的检测</font>
>
> > ### <font color='cornflowerblue'>5.6.1. 资源分配图：SRAG=(V,E)的有向图</font>
> >
> > > **1️⃣**点集：分为两类，每个进程$P_i$一个点(圆圈)，一类资源$r_i$一个点(方框)，而一类资源中还可能有多个资源则用方框中的点来表示(每个资源表示一个<font color='red'>实例</font>)
> > >
> > > **2️⃣**有向边集：$<P_i,r_i>$表示$P_i$请求一个$r_i$资源且尚未分配(申请边)，$<r_i,P_i>$表示$r_i$资源中一个资源已经分配给了$P_i$(分配边)
> > >
> > > **3️⃣**图例：
> > >
> > > <img src="https://s2.loli.net/2023/11/06/8WECli1AufIBgdM.png" alt="image-20211026164306727" style="zoom:60%;" /> 
> >
> > ### <font color='orange'>5.6.2. 死锁定理：用SRAG检验系统是否死锁</font>
> >
> > > **1️⃣**图中的非阻塞进程：首先要有边与进程结点连接(允许仍未结束)，其次该节点申请的资源数要小于等于该类资源的空弦数。如下图的P1就是非阻塞的
> > >
> > > <img src="https://s2.loli.net/2023/11/06/diEFcyjTfuCM8ah.png" alt="image-20231106235833390" style="zoom:40%;" /> 
> > >
> > > **1️⃣**可完全简化
> > >
> > > 1. 找到非阻塞结点，该节点会执行到底然后释放资源，然后孤立。如下图
> > >
> > > <img src="https://s2.loli.net/2023/11/07/icPYACVh3xgFHj4.png" alt="image-20231107000030116" style="zoom: 35%;" /> 
> > >
> > > 2. 其他进程因为得到了被释放的资源，也开始执行。在本例中是P2
> > >
> > > 3. 按照这个规则周而复始，如果最后图中无边则图是可完全简化的，否则得到<font color='red'>唯一的</font>不可简化图
> > >
> > > <img src="https://s2.loli.net/2023/11/07/gDXL7ox4uhzeVvM.png" alt="image-20231107000244774" style="zoom:50%;" /> 
> > >
> > > **2️⃣**死锁定理：状态S是死锁$\iff$S状态的资源分配图不可完全简化
> >
> > ### <font color='cornflowerblue'>5.6.3. 死锁检测方法</font>
> >
> > > **1️⃣**死锁的必要性检测：
> > >
> > > 1. 如果SRAG无环，那么比不可能死锁
> > > 2. 如果SEGA有环，每类资源都只有一个实例，则一定死锁。否则见下：
> > >
> > > **2️⃣**死锁的检测<font color='red'>(他妈就是死锁定理吧！)</font>：确定是否存在一种方式使所有进程都可以获得所需资源并运行完
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231021224059862.png" alt="image-20231021224059862" style="zoom:67%;" /> 
> > >
> > > 1. Work表示当前可用的资源，如果Allocation不为零(分配有资源)则Finish为假(进程不该结束)，反之
> > >
> > > 2. 然后寻找这样的进程：进程仍未结束，请求的资源小于可用资源
> > >
> > >    2.1. 如果有这样的进程就让他执行完然后释放所占资源
> > >
> > >    2.2. 没有的话，要么所有进程都执行完了，要么就死锁了
>
> ## <font color='cornflowerblue'>5.7. 死锁的解除</font>
>
> > **1️⃣**剥夺资源：从其他进程处抢来足够资源解除死锁
> >
> > **2️⃣**撤销进程：灭掉一些进程为其他进程提供更多资源
> >
> > **3️⃣**进程回退：根据记录信息，进程回到死锁前(自愿放弃资源)
>
> ## <font color='orange'>PS. 活锁/饥饿/饿死</font>
>
> > **1️⃣**饥饿：进程长时间等待
> >
> > **2️⃣**饿死：进程等待时间过长，即使得到资源执行了也无意义了
> >
> > **3️⃣**活锁：特殊的一种饥饿，进程在执行但是无法被调度前进，像被死锁了一样

# <font color='cornflowerblue'>内存管理</font>

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/3.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/3.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/3.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/3.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html)==**

# <font color='cornflowerblue'>1. 内存管理基础</font>

> ## <font color='cornflowerblue'>1.1. 概述</font>
>
> > ### <font color='orange'>1.1.1. 内存管理的功能</font>
> >
> > > **1️⃣**分配回收内存：记住内存使用情况，内存分配，回收用户释放的内存
> > >
> > > **2️⃣**地址变换：程序的逻辑地址$\iff$内存的物理地址
> > >
> > > **3️⃣**扩充内容：基于逻辑层面的虚存技术
> > >
> > > **4️⃣**存储保护：使各道作业在内存中独立运行，且不破坏系统程序
> >
> > ### <font color='cornflowerblue'>1.1.2. 其他背景知识</font>
> >
> > > **1️⃣**程序执行的必要条件：输入内存，放入一个进程
> > >
> > > **2️⃣**输入队列：磁盘上等待进入内存并执行的进程集合
> > >
> > > **3️⃣**程序的加载：将程序代码/数据从磁盘读入内存，并准备开始执行
> > >
> > > **4️⃣**动态加载：一个程序只有在调用时才会加载
>
> ## <font color='cornflowerblue'>1.2. 程序的加载</font>
>
> > ### <font color='cornflowerblue'>1.2.1. 概览：编译-链接-装入</font>
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231022010612046.png" alt="image-20231022010612046" style="zoom: 67%;" /> 
> >
> > ### <font color='cornflowerblue'>1.2.2. 地址变换</font>
> >
> > > <img src="https://s2.loli.net/2023/11/07/dO96ozvpSmjTatx.png" alt="image-20211028143020575" style="zoom: 33%;" /> 
> > >
> > > **1️⃣**符号地址(对源程序而言)：编程中用变量/数据名指定的位置
> > >
> > > **2️⃣**相对/虚拟/逻辑地址(对目标程序而言)：源程序编译后CPU生成的目标代码地址，从0开始
> > >
> > > **3️⃣**物理/绝对地址(对可执行程序而言)：程序加载后在内存的实际地址
> > >
> > > PS—逻辑地址对用户可见，物理地址对用户透明
> >
> > ### <font color='cornflowerblue'>1.2.3. 重定位：虚拟地址→物理地址</font>
> >
> > > **1️⃣**静态重定位：在装入时，逻辑地址全部转为绝对的地址，执行过程中不变
> > >
> > > <img src="https://s2.loli.net/2023/11/07/ZEYFNXwDRUb1PxB.png" alt="image-20231107151641464" style="zoom: 67%;" /> 
> > >
> > > **2️⃣**动态重定位：起始地址放入重定位寄存器，执行过程中，在CPU访问内存前，把要访问的数据/程序地址转化为内存地址(硬件实现：重定位寄存器+逻辑地址->物理地址)
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231022120923715.png" alt="image-20231022120923715" style="zoom:67%;" /> 
> >
> > ### <font color='cornflowerblue'>1.2.3. 三种链接</font>
> >
> > > **1️⃣**静态链接：全部链接完再运行
> > >
> > > **2️⃣**装入时动态链接：边装入边链接
> > >
> > > **3️⃣**动态链接：一部分先运行，等需要某些块了再链接+装入，节省了内存(不需要的块就不装入了)
> >
> > ### <font color='cornflowerblue'>1.2.4. 三种装入：对应编译/装入/执行时绑定到内存地址</font>
> >
> > > **1️⃣**绝对装入：编译时生成绝对代码(含物理地址)，决定了要装内存哪
> > >
> > > **2️⃣**可重定位装入：装入时完成地址变换(物理地址=基地址+逻辑地址)，实现容易但程序地址要连续
> > >
> > > **3️⃣**动态运行装入：程序运行时在内存中位移，程序运行某指令/访问某数据后才装入，地址可不连续
>
> ## <font color='orange'>1.3. 内存保护：防止一个作业破坏另一个</font>
>
> > **1️⃣**界限寄存器法
> >
> > 1. 上下界寄存器法：让上/下界寄存器分别存储作业的开始/结束地址，如果作业运行时访问的内存超出这个上下界就立马中断
> > 2. <font color='cornflowerblue'>基址+限长寄存器法：分别存放作业的起始地址+作业长度，限长寄存器与相对地址进行比较超出就立马中断</font>
> >
> > **2️⃣**存储保护键方法：若干分区中每个分区有很多存储块，给每个存储块分配一个单独的保护键(锁)。进入系统的作业被赋予一个保护键(钥匙)，然后检查二者保护键是否匹配，不匹配就立即中断
>
> ## <font color='cornflowerblue'>1.4. 覆盖&交换技术</font>
>
> > ### <font color='orange'>1.4.1. 覆盖技术：把大程序分为一系列覆盖</font>
> >
> > > 见于早期小内存OS
> > >
> > > **1️⃣**基本概念
> > >
> > > 1. 覆盖：程序中相对独立的程序单位
> > > 2. 覆盖段：程序执行时不需要同时装入内存的一组覆盖
> > > 3. 覆盖区：与覆盖段一一对应的存储区域，将覆盖段分配到一个覆盖区。覆盖区的大小=覆盖段中最大覆盖的大小
> > >
> > > **2️⃣**覆盖实例：一般都是由程序员提供覆盖结构
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231022150828445.png" alt="image-20231022150828445" style="zoom:67%;" /> 
> >
> > ### <font color='cornflowerblue'>1.4.2. 内存交换(扩展)</font>
> >
> > > **1️⃣**概述：把暂不用的程序/数据从内存移到外存(或移回来)
> > >
> > > **2️⃣**兼容分时系统：内存中只有一完整作业，时间片用完后OS就把他丢到外存，放外存中另一作业来
> > >
> > > **3️⃣**与覆盖技术的比较
> > >
> > > 1. 覆盖要求程序员给出程序段之间的覆盖结构，交换不需要
> > > 2. 交换发生在不同进程/作业之间，覆盖发生于用一进程/作业
> > >
> > > **4️⃣**交换技术的特点
> > >
> > > 1. 从主存交换到什么设备：快速+空间够+直接访问，比如SSD
> > > 2. 从主存交换到哪里：<font color='red'>交换空间</font>(aka<font color='red'>备份区</font>，大小固定，独立于文件系统，可直接存取)
> > > 3. 什么进程被交换：优先级低的被交换出去(进程要空闲即休眠/不占CPU)，高的被交换进来
> > > 4. 转移时间：交换耗时，应该远低于进程执行时长
> > > 5. 合适交换：内存爆满
> > >
> > > **5️⃣**挂起与交换：挂起进程会被丢到外存
>
> ## <font color='cornflowerblue'>1.5. 连续分配: 程序装入连续内存</font>
>
> > ### <font color='cornflowerblue'>1.5.0. 内部/外部碎片</font>
> >
> > > **1️⃣**内部碎片：已分给作业但不能被利用的内存(某个作业占用内存中没填满的部分)
> > >
> > > **2️⃣**外部碎片：由于太小而无法分配给作业的内存碎片(不同作业之间剩余的内存)
> >
> > ### <font color='cornflowerblue'>1.5.1. 单一连续分配：单任务OS</font>
> >
> > >  **1️⃣**内存结构：低地址给OS，高地址给用户，再其余的浪费掉
> > >
> > >  <img src="https://s2.loli.net/2023/11/08/7SbU9tqZREAkG8I.png" alt="image-20211222144348943" style="zoom:50%;" /> 
> > >
> > >  **2️⃣**缺点：会产生内部碎片
> >
> > ### <font color='cornflowerblue'>1.5.2. 多分区分配：固定/静态分区(早期)</font>
> >
> > > **1️⃣**概述：OS分区+多个用户分区，用户分区大小在装入前预先确定，每个分区装一个程序
> > >
> > > PS1：分区大小可以相等也可以不等
> > >
> > > PS2：会产生内部碎片且分区有限，但是易于实现开销小
> > >
> > > **2️⃣**分区说明表：记录可分配的区号(及其大小/起止)，程序装入内存时检索一次分区表找出满足要求的空闲分区
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231022160820398.png" alt="image-20231022160820398" style="zoom:67%;" /> 
> >
> > ### <font color='cornflowerblue'>1.5.3. 多分区分配：动态分区</font>
> >
> > > #### <font color='cornflowerblue'>1.5.3.1. 概述</font>
> > >
> > > > **1️⃣**含义：作业进入主存时，再建立分区
> > > >
> > > > **2️⃣**分区大小=作业大小：
> > > >
> > > > 1. 作业进入主存时查找大于等于作业大小的空闲分区
> > > > 2. 等于的话直接分配
> > > > 3. 大于的话分成两半——和作业一样大的(占用)+剩余部分(空闲)
> > > >
> > > > **3️⃣**存在外碎片
> > >
> > > #### <font color='orange'>1.5.3.2. 分区分配中的数据结构</font>
> > >
> > > > **1️⃣**空闲分区表：登记空闲的分区，一个分区对应一项，一项中有分区号/大小/起始/状态
> > > >
> > > > PS：内存从低到高——分区号从小到大
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231022162617309.png" alt="image-20231022162617309" style="zoom: 60%;" /> 
> > > >
> > > > **2️⃣**空闲分区链：用指针链接所有空闲分区
> > > >
> > > > PS：每空闲分区起始位，存放空闲分区大小+指向下一空闲分区指针
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231022163249910.png" alt="image-20231022163249910" style="zoom: 67%;" /> 
> > >
> > > #### <font color='cornflowerblue'>1.5.3.3. 分区分配算法：怎样把空闲区分给作业</font>
> > >
> > > > **1️⃣**首次适应算法：
> > > >
> > > > 1. 含义：在空闲分区链中从头按顺序找，选找到的第一个大小合适的空闲区
> > > > 2. 优点：分配/释放速度快
> > > >
> > > > 3. 缺点是：低地址空闲块会越分越小，导致之后的查找成本大
> > > >
> > > > **2️⃣**<font color='orange'>下次适应算法</font>：
> > > >
> > > > 1. 基于首次适应的改进：空闲分区链改为循环链表，每次从上次停留地方开始找，
> > > >
> > > > 2. 缺点：全局都难有大的空闲区
> > > >
> > > > **3️⃣**最佳适应算法：
> > > >
> > > > 1. 含义：空闲区从小到大排列，每次从小到大一个个试，试到差不多大小的块便分给进程
> > > >
> > > > 2. 缺点：会产生很多难以利用的碎片，除非用碎片拼接(aka紧凑)
> > > >
> > > > **4️⃣**<font color='orange'>最差适应算法</font>：
> > > >
> > > > 1. 含义：空闲分区按照容量大到小排列，最大空闲分区优先分配
> > > >
> > > > 2. 缺点：大作业来到时，大空闲区已经被优先分配掉了
> > >
> > > #### <font color='cornflowerblue'>1.5.3.4. 分区回收</font>
> > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231022200615706.png" alt="image-20231022200615706" style="zoom:50%;" /> 
> > > >
> > > > **1️⃣**回收区上/下邻接空闲区：合为一空闲区，首地址为顶上那个
> > > >
> > > > **2️⃣**回收区上下邻接空闲区：合为一大空闲区，从链表中删除下面的分区
> > > >
> > > > **3️⃣**回收区上下无空闲区：独立为空闲区，加入空闲分区链表Z
> > >
> > > #### <font color='cornflowerblue'>1.5.3.4. 如何处理碎片？</font>
> > >
> > > > **1️⃣**核心问题：作业装入的内存要连续，但内存碎片总和总是大于作业大小
> > > >
> > > > **2️⃣**拼接技术(紧缩)：
> > > >
> > > > 1. 含义：向一个方向移动已分配的作业，碎片就此紧缩在另一端
> > > > 2. 何时紧缩？：某个分区回收时(频率高)，找不到足够空间时(频率低但是实现复杂)
> > > >
> > > > **3️⃣**动态分区分配+拼接→动态重定位分区分配：空闲区不够，但碎片总和够大时实行分区
>
> ## <font color='orange'>1.6. 非连续分配概述：程序装入非连续内存</font>
>
> > **1️⃣**核心：把程序打散存在主存里，然后用索引将其联系起来
> >
> > **2️⃣**分类
> >
> > ```txt
> > ├── 分区大小不定：分段存储管理
> > ├── 分区大小固定：分页存储管理
> >                ├── 运行时把作业所有页装入内存：基本分页存储管理
> >                ├── 运行时把作业部分页装入内存：请求分页存储管理(见后虚拟存储)
> > ```
>
> ## <font color='cornflowerblue'>1.7. 基本分页存储管理</font>
>
> > ### <font color='cornflowerblue'>1.7.1. 分页以&页表&地址变换</font>
> >
> > > #### <font color='cornflowerblue'>1.7.1.1. 简单分页/纯分页原理</font>
> > >
> > > > **1️⃣**页&块
> > > >
> > > > 1. 页：作业中等大的逻辑内存空间
> > > > 2. 块/帧：主存中，大小固定的物理内存空间，大小上块和页相等的
> > > > 3. 页框：主存中大小与页一样大的块
> > > >
> > > > **2️⃣**作业调度：以块为单位，将作业任一页丢到主存任一块，所有页要一次调入(块不够就等待)
> > > >
> > > > **3️⃣**页/块大小的决定：
> > > >
> > > > 1. 过大会导致碎片太多，过小会导致页表过长(占用内存)+页面进出主存效率低
> > > > 2. 通常为2幂大小，512B-4KB
> > > >
> > > > **4️⃣**逻辑地址结构：[页号] [页内位移]，如下有$2^{20}=1M$页+每页$2^{12}=4K$大小
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231022213158583.png" alt="image-20231022213158583" style="zoom: 67%;" /> 
> > > >
> > > > 这两个参数都由CPU生成，存在如下关系
> > > >
> > > > ```txt
> > > > (int)[逻辑地址]/[页面大小]=[页号]
> > > > (int)[逻辑地址]%[页面大小]=[页内位移]
> > > > ```
> > >
> > > #### <font color='cornflowerblue'>1.7.1.2. 页表: (用户程序的页)页号$\iff$块号(主存物理块)</font>
> > >
> > > > **1️⃣**概览：页表存在内存中，如图例子。页表项=页号+块号+其他(存在位/修改/访问权限)
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231022214501879.png" alt="image-20231022214501879" style="zoom: 50%;" /> 
> > > >
> > > > **2️⃣**有效-无效位：在页表表项中，有效表示有关页在进程的逻辑地址空间中
> > > >
> > > > <img src="https://s2.loli.net/2023/11/09/HmRaDLfWbthACyn.png" alt="image-20211102165311715" style="zoom: 90%;" /> 
> > >
> > > #### <font color='cornflowerblue'>1.7.1.3. 基本地址变换机构: 基于硬件</font>
> > >
> > > > <img src="https://s2.loli.net/2023/11/09/KWYaUvcstN5ieVz.png" alt="image-20231109211401402" style="zoom: 67%;" /> 
> > > >
> > > > **1️⃣**页表寄存器(PTR)：**页表基址寄存器**(主存中的页表起始地址)+**页表限长寄存器**(页表长度)
> > > >
> > > > **2️⃣**逻辑地址→物理地址
> > > >
> > > > 1. 计算出页号和页内位移
> > > >
> > > > ```txt
> > > > (int)[逻辑地址]/[页面大小]=[页号]
> > > > (int)[逻辑地址]%[页面大小]=[页内位移]
> > > > ```
> > > >
> > > > 2. 若页号>页表长度则越界终中断
> > > > 3. 页表起始地址+偏移量(页号*页表每项长度)→得到地址，从该地址取出物理块号
> > > > 4. 物理块号+页内位移(=块内位移)→物理地址
> > > >
> > > > **3️⃣**弊端：存取数据/变量要访问两次主存(第一次访问页表确定物理地址+第二次用物理地址访问指令or数据)，快表可以解决这一问题
> >
> > ### <font color='cornflowerblue'>1.7.2. 其他类型的页表</font>
> >
> > > #### <font color='cornflowerblue'>1.7.2.1. 具有快表的地址变换机构</font>
> > >
> > > > **1️⃣**快表：储存作业当前/近期访问的页表项，类似于Cache
> > > >
> > > > **2️⃣**联想寄存器TLB：存储块表的寄存器
> > > >
> > > > **2️⃣**改进后逻辑地址→物理地址
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231022224109094.png" alt="image-20231022224109094" style="zoom:67%;" /> 
> > > >
> > > > 1. 求出页号+页内位移
> > > > 2. 先把页号和快表中的对比，对上了就得到对应块号，与页内位移组合成物理地址
> > > > 3. 否则就和原来一样
> > >
> > > #### <font color='cornflowerblue'>1.7.2.2. 两级页表</font>
> > >
> > > > **1️⃣**页表大小计算：页表长度(页表项目数)*页表每项大小(块号位数)
> > > >
> > > > **2️⃣**背景：$页表长=2^{页号位数}$，页表长度爆炸式增长→占空间太大
> > > >
> > > > **3️⃣**两级页表逻辑地址
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231022230019503.png" alt="image-20231022230019503" style="zoom: 67%;" /> 
> > > >
> > > > **4️⃣**地址变换过程：
> > > >
> > > > $外层页号\xrightarrow{在外部页找到}二级页表首地址\xrightarrow[得到]{+外层页内地址}物理块(首)地址\xrightarrow[得到]{+页(块)内地址}物理地址$
> > > >
> > > > ➕多级页表：逻辑和两级页表一样，多见于64位系统，缺点是地址变换耗费资源
> > >
> > > #### <font color='cornflowerblue'>1.7.2.3. HASH页表</font>
> > >
> > > > 通过哈希表来完成逻辑地址到物理地址的映射
> > > >
> > > > <img src="https://s2.loli.net/2023/11/09/wzaPQUy9NEqBjWV.png" alt="image-20211102171917982" style="zoom:67%;" /> 
> > >
> > > #### 1.7.2.4. 反转页表
> > >
> > > > **1️⃣**背景：传统上<font color='red'>每个进程设一张页表</font>，浪费内存
> > > >
> > > > **2️⃣**解决方案：页表按物理内存块组织(而非进程)，反转页表中**包含了内存中所有物理块地址→其逻辑的地址的映射**
> > > >
> > > > **3️⃣**关于表项：
> > > >
> > > > 1. 内存中每一块在表中占一项
> > > > 2. 每项包含：进程逻辑页号(存储在物理内存中)+进程标识
> > > > 3. 使用HASH表来搜索表项
> > > >
> > > > **4️⃣**特点：减少了页表占用空间，但查找时间增加
> >
> > ### <font color='cornflowerblue'>1.7.3. 页的共享与保护</font>
> >
> > > **1️⃣**分页中共享的实现：<font color='red'>共享用户地址空间中的页指向相同的物理块</font>
> > >
> > > **2️⃣**分页中的保护：
> > >
> > > 1. 地址越界保护：比较地址变换机构中的页表长度和逻辑地址中的页号
> > > 2. 访问控制：程序访问一个页面时，OS检查该操作是否有权限(只读/只写/可执行)，无权就中断
> >
> > ### <font color='cornflowerblue'>1.7.4. 基本分页存储管理的利弊</font>
> >
> > > **1️⃣**利：内存利用率高+离散分配+便于存储访问控制+无外部碎片
> > >
> > > **2️⃣**弊：需要硬件支持(如快表)+内存访问效率低+共享困难(对比分段)+有内部碎片
>
> ## <font color='cornflowerblue'>1.8. 基本分段存储管理</font>
>
> > 页是信息的储存单位，段是信息的逻辑单位
> >
> > ### <font color='orange'>1.8.1. 分段存储原理</font>
> >
> > > **1️⃣**作业&内存分段：每个分段都有段名，每段地址从0开始，每段的地址连续(段间可不连续)
> > >
> > > **2️⃣**分段存储的逻辑地址结构：段数=$2^{段号位数}$，段长=$2^{段内位移位数}$
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231023104710698.png" alt="image-20231023104710698" style="zoom: 67%;" /> 
> > >
> > > **3️⃣**分页与分段的区别
> > >
> > > 1. 分段：段号由用户定义，每段大小和含义不同，地址是二维的(用户给出段号+用户给出偏移)
> > > 2. 分页：页号由OS生成，页号无特殊含义，地址是一维的(OS给出页号+用户给出偏移)
> >
> > ### <font color='orange'>1.8.2. 段表: [段号]+[段长]+[段在内存的起始地址]</font>
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231023111114897.png" alt="image-20231023111114897" style="zoom: 67%;" /> 
> >
> > ### <font color='cornflowerblue'>1.8.3. 逻辑地址到物理地址的转换</font>
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231023112052840.png" alt="image-20231023112052840" style="zoom: 67%;" />  
> > >
> > > **1️⃣**先对比段号AND段表长度，若段号超出，则中断
> > >
> > > **2️⃣**算出段表表项位置=段起始地址+段号*段表表项长度
> > >
> > > **3️⃣**读取表项内容，若段长<段内位移，则中断(动态增长段除外)
> > >
> > > **4️⃣**根据表项中的段起始地址+段内位移→物理地址
> >
> > ### <font color='cornflowerblue'>1.8.4. 段的共享与保护</font>
> >
> > > **1️⃣**共享：多个作业段表中相应表项指向被共享物理段的同一物理副本
> > >
> > > **2️⃣**保护的含义：
> > >
> > > 1. 一个作业在共享段读数据时，防止另一个作业修改内容
> > > 2. 不可修改的数据/代码共享，可修改的不共享
> > >
> > > PS1：纯代码/可重入代码：不可修改的代码
> > >
> > > PS2：共享的一个规则：不可修改代码与不可修改数据可共享，但可修改代码与可修改数据不可共享
> > >
> > > PS3：大多系统中，程序都被分为代码区/数据区
> > >
> > > **3️⃣**保护的方式：地址越界保护(段号>段表长就中断，偏移>段长就中断)+访问控制保护(读写权限)
> >
> > ### <font color='cornflowerblue'>1.8.5. 基本分段的特点</font>
> >
> > > **1️⃣**划为多模块：如代码段/数据段/共享段，分别编写/编译/保护，进行共享
> > >
> > > 1. 共享：把需要共享的代码/数据放在一段
> > > 2. 保护：段信息独立，保护段就是保护信息
> > >
> > > **2️⃣**碎片：没内碎片，外碎片可通过内存紧缩消除
> > >
> > > **2️⃣**缺点：需硬件支持，段最大尺寸受主存限制
> >
> > ### <font color='cornflowerblue'>1.8.6. 分页分段对比</font>
> >
> > > |              | 分 页                                        | 分 段                                                    |
> > > | ------------ | :------------------------------------------- | :------------------------------------------------------- |
> > > | 目的         | 提高内存利用率                               | 更好满足用户需要                                         |
> > > | 单位划分     | **页是信息的物理单位，页大小固定(由OS确定)** | 段是**信息的逻辑单位**，其含义完整。段长不固定(用户确定) |
> > > | 作业地址空间 | 一维(页内偏移)                               | 二维(段名+段内偏移)                                      |
> > > | 内存分配     | 以页为单位离散分配，无外碎片                 | 以段为单位离散分配，有外碎片(需要紧缩)                   |
>
> ## <font color='cornflowerblue'>1.9. 基本段页式存储管理方式</font>
>
> > ### <font color='cornflowerblue'>1.9.1. 分段分页&分块</font>
> >
> > > **1️⃣**作业分段分页：先给作业的地址空间逻辑分段(每段有段号)，再给每段内分页
> > >
> > > **2️⃣**主存的分块(和分页管理一样)：分为如讴歌和页大小一样的块
> >
> > ### <font color='cornflowerblue'>1.9.2. 段表与页表</font>
> >
> > > **1️⃣**段表：每进程拥有一张段表，结构为——段号+对应页表始址+页表长
> > >
> > > **2️⃣**页表：每个段表有一张页表，结构为——页号+块号
> >
> > ### <font color='cornflowerblue'>1.9.3. 地址与地址变换</font>
> >
> > > **1️⃣**段页管理的虚拟地址结构
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231023115838241.png" alt="image-20231023115838241" style="zoom:67%;" /> 
> > >
> > > **2️⃣**从虚拟地址到逻辑地址的变换
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231023121807004.png" alt="image-20231023121807004" style="zoom:67%;" /> 
> > >
> > > 1. 先对比段号和段表长度，如果段号大就中断
> > > 2. 段起始地址与段号相加，得到所需段表项(表项：段号+页表长度+页表起始地址)
> > > 3. 如果页号>页表长度就中断
> > > 4. 在通过页表起始地址+页号得到页表项目地址，通过该地址取出块号
> > > 5. 块号+页内位移就是物理地址了，然后访问内存
> >
> > ### <font color='cornflowerblue'>1.9.4. 特点</font>
> >
> > > **1️⃣**内部碎片太多：页式平均一个程序有半页碎片，段页式平均一段就有半页碎片(一个程序很多段)
> > >
> > > **2️⃣**为了获取一条指令或数据，需**三次访问内存** 

# <font color='cornflowerblue'>2. 虚拟内存管理</font>

> ## <font color='cornflowerblue'>2.0. Pre</font>
>
> > ### <font color='cornflowerblue'>2.0.1. 引入虚存的原因</font>
> >
> > > **1️⃣**一次性(全装入后才执行)+驻留性(运行完后作业才脱离内存)，对于大作业难以满足要求
> > >
> > > **2️⃣**程序执行时有些代码用的较少(错误处理部分)，而程序IO又耗费世家
> >
> > ### <font color='cornflowerblue'>2.0.1. 局部性原理</font>
> >
> > > **1️⃣**时间局部性：同一指令/数据短时间内被高频执行/访问**(这可以归因于大量的循环操作)**
> > >
> > > **2️⃣**空间局部性：某条指令被访问后，其附近的指令有极大概率也被访问
>
> ## <font color='cornflowerblue'>2.1. 虚存基本概念</font>
>
> > ### <font color='cornflowerblue'>2.1.1. 虚存的定义</font>
> >
> > > **1️⃣**部分装入：一部分装入内存，一部分放外存
> > >
> > > **2️⃣**请求调入：执行时访问信息不在内存时，再要求OS将其调入内存
> > >
> > > **3️⃣**置换功能：OS将内存中暂时不用的内容置换到外存
> > >
> > > **4️⃣**虚拟内存：逻辑上扩充内存容量的系统
> >
> > ### <font color='cornflowerblue'>2.1.2. 虚存的特征</font>
> >
> > > **1️⃣**离散性(最基本)：程序被打散存储在内存中
> > >
> > > **2️⃣**多次性(最重要)：一个作业被分成多次调入内存
> > >
> > > **3️⃣**交换性：作业在运行时可以不断从内存中换入换出
> > >
> > > **4️⃣**虚拟性：用户使用的内存远大于实际内存
> >
> > ### <font color='cornflowerblue'>2.1.3. 其他有关虚存</font>
> >
> > > <font color='red'>**1️⃣**虚存实现手段：请求分页，请求分段</font>
> > >
> > > **2️⃣**硬件机构：外存外存都要足够大，有中断机构(访问内容不在内存时就中断程序)，地址变换机构，段/页表
> > >
> > > **3️⃣**好处：较小内存执行较大程序，并发性提高，比覆盖技术编成更简单
>
> ## <font color='cornflowerblue'>2.2. 请求分页存储管理方式</font>
>
> > ### <font color='cornflowerblue'>2.2.1. 请求分页原理：局部性原理</font>
> >
> > > **1️⃣**请求分页=基本分页+请求调页功能+页面置换功能
> > >
> > > **2️⃣**页面调入策列
> > >
> > > 1. 预调页策略：进程首次调入时，把预计很快要被访问的页，主动调入内存
> > > 2. 请求调页策略：进程运行时，将需要的页调入内存(通过**页面置换**把暂时不用的页置换出去)
> > >
> > > <font color='red'>PS: 内存中每一页都在外存上保留一份副本</font>
> > >
> > > **3️⃣**从何处调入页面：硬盘分为文件区+对换区，对换区IO快于文件区
> > >
> > > 1. 对换区足够大：全从对换区调入所需页面，运行前就把进程必要块放到对换区
> > >
> > > 2. 对换区不够大：不会被修改的文件都从文件区调入(减少IO)，需要修改的放到调换区
> > >
> > > 3. UNIX方式：未运行的页放在文件区，运行过又被换出的放对换区
> >
> > ### <font color='cornflowerblue'>2.2.2. 页表结构</font>
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231023141323804.png" alt="image-20231023141323804" style="zoom: 80%;" /> 
> > >
> > > **1️⃣**页号与物理块号：与之前相同，虚拟地址页$\xleftrightarrow{映射}$物理地址快
> > >
> > > **2️⃣**状态位(存在位)：判断页是否在主存，不在时触发**缺页中断**
> > >
> > > **3️⃣**访问字段：记录局部性参数——页面一段时间内访问次数/最近多久未被访问
> > >
> > > **4️⃣**修改位：记录页面调入内存后是否被修改
> > >
> > > 1. CPU以写方式访问页时，修改位被设置
> > > 2. 页在内存中没被修改，页换出时就不再写到外存(节省读写次数)
> > >
> > > **5️⃣**外存地址：页面在外存的地址，调入该页时使用
> >
> > ### <font color='cornflowerblue'>2.2.3. 缺页中断与地址变换</font>
> >
> > > **1️⃣**如果访问的页在内存中，地址变换与分页存储管理相同
> > >
> > > **2️⃣**访问页不在内存，进程就请求OS从外存调入所需页
> > >
> > > <img src="https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211104153315925.png" alt="image-20211104153315925" style="zoom:67%;" />  
> > >
> > > ➕ 缺页中断与一般中断的区别
> > >
> > > 1. 缺页/一般中断，发生在指令执行期间/结束后
> > > 2. 一指令可触发多次缺页中断，如指令的两个操作数都在外存
> > > 3. 缺页/一般中断，返回到**本指令开始/下条指令**重新执行
> >
> > ### <font color='cornflowerblue'>2.2.4. 请求分页的性能</font>
> >
> > > **1️⃣**优点：离散存储碎片少，提供虚拟存储主存利用率高
> > >
> > > **2️⃣**缺点：硬件复杂，会抖动，最后一页仍有内部碎片
> > >
> > > **3️⃣**主动动作：处理缺页中断，从磁盘读页(开销最大)，重新开始执行被中断程序
> > >
> > > **4️⃣**缺页率=访问访问失败次数/进程访问内存总次数
>
> ## <font color='cornflowerblue'>2.3. 页面置换(淘汰)算法</font>
>
> > ### <font color='cornflowerblue'>2.3.1. 最佳置换(OPT)</font>
> >
> > > **1️⃣**页面号引用串：进程执行时，按时间顺序引用的页面序列
> > >
> > > **2️⃣**OPT：已知页面号引用串的情况下(其实不可能的)，淘汰以后不再使用/最迟被使用的页
> > >
> > > **3️⃣**特点：缺页率最低，但无法实现(仅作为理论最低缺页率的参考)
> >
> > ### <font color='cornflowerblue'>2.3.2. 先进先出(FIFO): 最简单</font>
> >
> > > **1️⃣**队列结构：指针指向最先进入的页，每次淘汰指针指向的页
> > >
> > > **2️⃣**缺点：会产生Belady异常，源于最早进来(也是最早淘汰)的页使用最频繁
> >
> > ### <font color='cornflowerblue'>2.3.3. 最近最少使用(LRU)</font>
> >
> > > **1️⃣**原理：
> > >
> > > 1. 最近最少使用的页$\xrightarrow[性能接近]{近似的等同于}$往后最迟被使用的页(OPT)
> > > 2. 基于假设：刚访问的页倾向于马上又被访问
> > >
> > > **2️⃣**含义：淘汰最久不被使用的页
> > >
> > > **3️⃣**硬件支持：每个页表项有一个计数器，记录访问情况，作为被淘汰依据
> >
> > ### <font color='cornflowerblue'>2.3.4. 最不常用/最常用置换(LFU/MFU)</font>
> >
> > > **1️⃣**含义：选择当前为止访问最少次/最多次的页面淘汰
> > >
> > > **2️⃣**思想：淘汰最少使用的→访问多的倾向于再被访问；淘汰最多使用的→访问少的页往往最新调入
> > >
> > > **3️⃣**实现方式：设置一个计数器，被访问一次该页的计数器就+1
> >
> > ### <font color='cornflowerblue'>2.3.5. LRU近似算法</font>
> >
> > > #### <font color='cornflowerblue'>2.3.5.1. 时钟置换(CLOCK)/最近未使用(NRU)/二次机会</font>
> > >
> > > > LRU+FIFO的折中
> > > >
> > > > **1️⃣**数据结构：每页设一个访问位(被访问后置1)，内存中所有页构成一个**循环链表**
> > > >
> > > > **2️⃣**访问页在链表中：访问位改为1
> > > >
> > > > **3️⃣**访问页不在链表中：
> > > >
> > > > 1. 指针指向上次被淘汰页的下一页
> > > >
> > > > 2. 指针顺序&循环遍历**循环链表**
> > > >
> > > >    2.1. 指针指向页的访问位=1时，就把该访问位清零，然后继续遍历
> > > >
> > > >    2.2. 指针指向页的访问位=0时，就淘汰该位然后访问位变1
> > > >
> > > > **4️⃣**示例：
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231023211133801.png" alt="image-20231023211133801" style="zoom:90%;" /> 
> > >
> > > #### <font color='cornflowerblue'>2.3.5.2. 改进时钟(CLOCK)/增强的二次访问</font>
> > >
> > > > **1️⃣**改进的核心：增加了修改位(被修改了置1)，访问位同为0时优先淘汰没被修改的位(IO代价更小)
> > > >
> > > > **2️⃣**算法步骤：进程启动将所有(访问位=0, 修改位=0)
> > > >
> > > > 1. 从指针位置开始首次循环遍历
> > > > 2. 先试图找到第一个(**访问位=0**, **修改位=0**)页替换，若没找到:arrow_down:
> > > > 3. 再试图找到第一个(**访问位=0**, **修改位=1**)页替换，所扫描过之处皆置**访问位=0**
> > > > 4. 如还没找到，就重复上述过程(重复下去一定能找到)
> >
> > ### <font color='orange'>2.3.7. 页面缓冲(PBA)</font>
> >
> > > **1️⃣**按照FIFO算法选择被置换页
> > >
> > > **2️⃣**对那些要被换出的页面，为其在内存中建立两个链表(缓冲)
> > >
> > > 1. 对于被换出的未修改的未修改的页，丢到空闲页链表尾
> > > 2. 对于被换出的已修改的未修改的页，丢到已修改页链表尾
> > >
> > > **3️⃣**对于缓冲中的页，在未来一段时间内如果要访问他们，可以快速响应(免去IO)
> > >
> > > **4️⃣**直到修改页链表到达一定规模后，再将他们一同IO到磁盘
>
> ## <font color='cornflowerblue'>2.4. 工作集理论：基于局部性原理</font>
>
> > **1️⃣**目的：解决抖动，提高CPU利用率
> >
> > **2️⃣**原理：预知程序在特定时间内要访问的页面(活跃页面)并提前加载它们
> >
> > **3️⃣**基本概念
> >
> > 1. 工作集：最近n次内存访问的页面集合，或者说落入工作集窗口的页面集合
> >
> > 2. <font color="red">工作集窗口(Δ)</font>：对于给定的访问序列选取定长的区间，其大小选定很重要，Δ过小则不能包含整个局部，Δ过大则可能包含多个局部
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240201120807041.png" alt="image-20240201120807041" style="zoom: 67%;" />  
> >
> > **4️⃣**工作集模型：
> >
> > 1. OS跟踪每个进程的工作集(如何跟踪是难点)，为其分配大于其工作集的物理块数
> >
> > 2. 若还有空闲物理块，启动其他进程
> >
> > 3. 若所有进程的工作集之和>可用物理块总数，OS会暂停&换出一个进程，释放的物理块给其他进程
>
> ## <font color='cornflowerblue'>2.5. 页面分配策略：如何给进程一定空闲页</font>
>
> > ### <font color='cornflowerblue'>2.5.1. 最少页数</font>
> >
> > > **1️⃣**含义：保证进程运行的最小物理块数
> > >
> > > **2️⃣**取值依据：指令格式，功能，寻址方式
> > >
> > > ➕某进程物理块数<最少页数：进程频繁缺页，进而崩溃
> >
> > ### <font color='cornflowerblue'>2.5.2. 分配&替换策略</font>
> >
> > > **1️⃣**分配(固定分配)：平均(每个进程块数一样)+按比例+按优先级
> > >
> > > **2️⃣**替换：全局(进程之间可争躲页，块数会增加)+局部(进程只能从自己那获得页，块数不变)
> > >
> > > ➕全局置换时，无法控制页错误率，系统吞吐率会更高
> >
> > ### <font color='cornflowerblue'>2.5.3. 组合</font>
> >
> > > |                                                          | 固定分配：每个进程分得相同个物理块                           | 可变分配：OS给进程动态分配物理块                             |
> > > | -------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
> > > | 局部置换：进程只在自己内存块中置换页面                   | 各进程物理块数相同，进程间不争夺块，块少进程频繁换页/块多进程浪费内存(核心在于进程块数分配) | 先给每进程一定物理块，进程互相枪内存。增加频繁换页进程块数，减少缺页率过低进程块数 |
> > > | 全局置换：进程需要更多内存时，可以替换掉其他进程的内存页 | 无                                                           | OS维护一空闲物理块队列，进程每次缺页就从队里取一个，取完了就去抢其他进程的块 |
>
> ## <font color='cornflowerblue'>2.7. 抖动与缺页率</font>
>
> > ### <font color='orange'>2.7.1. Belady异常</font>
> >
> > > **1️⃣**含义：FIFO算法中缺页率会随内存中块数增加而增加
> > >
> > > **2️⃣**成因：FIFO算法的策略与内存动态特征违背，总会换掉进程要访问的页
> > >
> > > **3️⃣**PS：LRU算法和最佳置换算法永远不会出现Belady异
> >
> > ### <font color='cornflowerblue'>2.7.2. 抖动/颠簸现象</font>
> >
> > > **1️⃣**含义：某一页面刚被换出又被访问(重新调入)，频繁调入调出，CPU利用率低下
> > >
> > > **2️⃣**成因：进程分到的物理块太少
> > >
> > > **3️⃣**解决方案：
> > >
> > > 1. 全局置换会造成颠簸，局部置换能限制颠簸
> > > 2. 根本上要给进程足够的物理块
> >
> > ### <font color='cornflowerblue'>2.7.3. 缺页率</font>
> >
> > > 作业有n页，系统给作业分了m页
> > >
> > > 如果作业运行时要访问A次页面，当所访问的页不在内存中时，需要将该页调入内存F次
> > >
> > > 则定义
> > >
> > > **1️⃣**缺页率：f=F/A
> > >
> > > **2️⃣**命中率：1-f
> > >
> > > **3️⃣**控制缺页频率：缺页率太低/高，回收/分给一些进程的页框
>
> ## <font color='orange'>2.8. 请求分段存储管理系统</font>
>
> > **1️⃣**将当前需要的若干段装入主存便可运行，访问分段不在主存中时再调入，将不用分段也置换出去
> >
> > **2️⃣**段表表项结构
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231024092120076.png" alt="image-20231024092120076" style="zoom:67%;" /> 

# PS. 总结

> ## PS.1. 三种离散分配方式
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231024093831015.png" alt="image-20231024093831015" style="zoom:67%;" /> 
>
> ## PS.2. 几种内存管理
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231024093940449.png" alt="image-20231024093940449" style="zoom:67%;" /> 

# <font color='cornflowerblue'>文件管理</font>

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/4.%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/4.%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/4.%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/4.%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.html)==**

# <font color='cornflowerblue'>1. 文件系统: 信息的组织/存储/访问</font>

> ## <font color='cornflowerblue'>1.1. 文件</font>
>
> > ### <font color='cornflowerblue'>1.1.1. 文件的概念</font>
> >
> > > **1️⃣**文件的含义：具有一定功能的程序/数据集合，通过文件名(用户访问接口)访问
> > >
> > > **2️⃣**文件逻辑分类
> > >
> > > 1. 流文件：中是指文件内信息不再划分单位，只是一串字符流，如exe文件
> > >
> > > 2. 记录文件：按逻辑把文件独立划分位多个信息单位(aka记录，可定长/不定长)，每个记录都有数据项
> > >
> > > **2️⃣**文件的组成结构
> > >
> > > 1. 数据项：基本数据项(文件系统中最小/不可分的原子数据单位)+组合数据项(多个基本数据项)
> > > 2. 记录：描述对象某方面的属性
> > > 3. 文件：创建者定义的有关数据项集合，分为有结构/记录式文件+无结构/流式文件
> > >
> > > 举个例子：张三(基本数据项)→张三+18岁(组合数据项)→张三的所有有关属性(记录)→有结构文件(张三李四王五构成的学生信息文件)
> >
> > ### <font color='cornflowerblue'>1.1.2. 文件的属性</font>
> >
> > > **1️⃣**内容：名称(唯一)+标识符+文件类型+文件位置+其他(文件大小/建立时间/用户标识)
> > >
> > > PS1: 标识符——OS层面文件的唯一标签，对用户透明
> > >
> > > PS2: 文件位置——指向文件的指针
> > >
> > > **2️⃣**属性信息，放在目录中，存储在硬盘中
> >
> > ### <font color='cornflowerblue'>1.1.3. 文件的分类</font>
> >
> > > **1️⃣**按用途：系统文件(只允许用户调用)+库文件(只允许用户调用)+用户文件(所有者/授权用户访问)
> > >
> > > **2️⃣**按保护级别：只读+读写+执行文件(读/写/执行是三种分立的操作)+不保护文件(随你怎么搞)
> > >
> > > **3️⃣**按流向：输入文件(如光盘/键盘中的文件)+输出文件(如打印机上的文件)+IO文件(磁盘)
> > >
> > > **4️⃣**按数据形式：源文件(你写的代码文本&数据)+目标文件(源文件编译后)+可执行文件(编译后再链接)
> >
> > ### <font color='cornflowerblue'>1.1.4. 文件的操作</font>
> >
> > > #### <font color='cornflowerblue'>1.1.4.1. 基本操作</font>
> > >
> > > > **1️⃣**创建文件：分配空间+目录中建立目录项+建立新的FCB，返回一个文件描述符
> > > >
> > > > **2️⃣**删除文件：先删除目录项+回收存储空间
> > > >
> > > > **3️⃣**读/写：查找目录→找到指定目录项→得到被读/要写文件的外存地址(指针)→开始读写
> > > >
> > > > **4️⃣**截断文件：将文件缩减到指定大小，但保留文件属性
> > > >
> > > > **5️⃣**设置文件读写位置：其实就是调整文件指针，让读写不再从头开始
> > >
> > > #### <font color='cornflowerblue'>1.1.4.2. 打开/关闭文件</font>
> > >
> > > > **1️⃣**打开文件
> > > >
> > > > 1. OS把文件属性复制到内存，给用户返回一个索引
> > > > 2. 用户通过这个索引向OS请求操作(打开)这个文件
> > > >
> > > > **2️⃣**关闭文件
> > > >
> > > > 1. 撤销之前建立的索引信息，切断用户与该文件的联系
> > > > 2. 若文件打开期间修改了，则将其写回外存
>
> ## <font color='cornflowerblue'>1.2. 文件的逻辑结构：用户对文件的组织</font>
>
> > ### <font color='cornflowerblue'>1.2.1. 概述</font>
> >
> > > **1️⃣**含义：用户所观察到&处理的文件组织形式
> > >
> > > **2️⃣**分类：有结构的记录文件(顺序/索引/索引顺序)+无结构的流文件
> > >
> > > **3️⃣**文件访问方式
> > >
> > > 1. 顺序访问：按文件逻辑顺序依次存取
> > > 2. 随机存取：根据记录编号直接存取文件中的任意一个记录(可忽略前面的)
> >
> > ### <font color='cornflowerblue'>1.2.2. 有结构文件分类：由OS/程序决定</font>
> >
> > > #### <font color='cornflowerblue'>1.2.2.1. 顺序文件/连续结构</font>
> > >
> > > > **1️⃣**含义：将逻辑文件信息连续存放
> > > >
> > > > **2️⃣**分类：定成/不定长(记录长度是否固定)+串结构(记录顺序不按关键字排)/顺序结构(按关键字)
> > > >
> > > > **3️⃣**优缺点：<font color="red">常用于批量记录读取</font> ，访问某个记录请求性能不佳，会有碎片/无法动态扩充
> > >
> > > #### <font color='cornflowerblue'>1.2.2.2. 索引文件(好比一个目录)</font>
> > >
> > > > **1️⃣**索引表：
> > > >
> > > > 1.  存储逻辑文件记录信息的表，其本身就是一个定长文件
> > > > 2.  每个表目指出一个文件记录在逻辑文件中的位置+长度
> > > >
> > > > **2️⃣**索引文件：索引表+逻辑文件
> > > >
> > > > **3️⃣**优缺点：随机访问(而不是从头开始)/删除修改添加高效；索引表本身占空间/查找策略影响大
> > >
> > > #### <font color='cornflowerblue'>1.2.2.3. 索引顺序文件</font>
> > >
> > > > **1️⃣**含义：将顺序文件中所有记录分组，每组第一个记录在索引表有索引项(关键字+该记录的指针)
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/OfEKmQFd8y2s5nZ.png" alt="image-20231111161111346" style="zoom: 33%;" /> 
> > > >
> > > > **2️⃣**检索操作：根据关键字检索索引表→找到组中第一个记录→顺序查找改组直到找到记录
> > > >
> > > > **3️⃣**优缺点：存取快，担任有额外存储开销(索引表)
> > >
> > > #### <font color='orange'>1.2.2.4. 直接文件(散列HASH文件)</font>
> > >
> > > > **1️⃣**直接文件：由关键字值找到记录的物理地址
> > > >
> > > > **2️⃣**散列文件：典型直接文件，关键字$\xrightarrow{HASH函数}$物理地址，存取快但是有冲突
>
> ## <font color='cornflowerblue'>1.3. 物理结构：文件在外存的存储结构</font>
>
> > ### <font color='cornflowerblue'>1.3.1. 概述</font>
> >
> > > **1️⃣**用户按逻辑结构使用文件$\xleftrightarrow{转换}$文件系统按物理结构管理文件
> > >
> > > **2️⃣**含义：**文件在外存的存放组织形式**
> > >
> > > **3️⃣**物理结构的类型：取决于外存方式——连续/链接/缩引分配$\xleftrightarrow{}$连续/链接/缩引结构
> > >
> > > **4️⃣**文件存取方式：取决于存储设备特性(磁带是顺序存取，磁盘是直接存取)
> > >
> > > **5️⃣**物理块与逻辑记录
> > >
> > > 1. 物理块大小固定，逻辑记录大小可变，一个逻辑记录可只占物理块一部分也可跨越多个物理块
> > > 2. 逻辑块：OS会将文件信息分为与物理块大小相等的逻辑块
> >
> > ### <font color='cornflowerblue'>1.3.2. 连续/链接/缩引分配：见2.3. 文件(在存储器的)实现</font>
>
> ## <font color='cornflowerblue'>1.4. 目录结构</font>
>
> > ### <font color='cornflowerblue'>1.4.1. 文件控制块(FCB)</font>
> >
> > > **1️⃣**文件=FCB+文件体
> > >
> > > **2️⃣**含义：用于描述和控制文件的数据结构
> > >
> > > **3️⃣**内容：至少有文件名+文件物理地址，此外还有——
> > >
> > > 1. 文件结构：物理的(顺序/索引/索引)，逻辑的(记录/流)
> > > 2. 文件物理位置：存放设备名+存储位置+文件长度
> > > 3. 存取控制信息：存取权限，分为文件主or其他用户
> > > 4. 管理信息：文件建立/上次存取日期，当前使用状态，共享计数
> >
> > ### <font color='orange'>1.4.2. 索引结点</font>
> >
> > > **1️⃣**含义：将文件名和文件描述分开→文件名+索引结点(包含文件描述)
> > >
> > > **2️⃣**存储特点：索引结点在外存，文件名+索引结点指针在内存(FCB)
> > >
> > > **3️⃣**磁盘索引结点内容
> > >
> > > 文件的：主标识+类型+存取权限+物理地址+长度+链接计数+存取时间
> > >
> > > 1. 文件主标识：标识了文件大小/小组的标识符
> > > 2. 文件链接计数：文件系统中指向该文件名的指针数
> > >
> > > **4️⃣**内存索引结点：打开文件时，磁盘索引结点$\xrightarrow{复制}$内存索引结点，有如下新增内容
> > >
> > > 1. 索引结点编号：标识内存索引结点
> > > 2. 状态：标识该节点是否上锁/修改
> > > 3. 访问计数：正在访问该文件的进程数
> > > 4. 逻辑设备号：文件所在文件系统的逻辑设备号
> > > 5. 链接指针：指向空链表/散列队列的指针
> >
> > ### <font color='cornflowerblue'>1.4.3. 目录文件&文件目录</font>
> >
> > > **1️⃣**文件目录：FCB的有序集合
> > >
> > > 1. 用途：检索文件，实现按名存取，防止冲突 
> > >
> > > 2. 目录项：就是FCB
> > > 3. 目录结构会影响到：文件存取速度/共享性/安全性
> > >
> > > **2️⃣**目录文件：文件目录以文件形式保存在外存，这个文件就叫目录文件
> > >
> > > **3️⃣**目录操作：建立/寻找/删除一个文件，列出目录列表，重命名文件，遍历文件系统
> >
> > ### <font color='cornflowerblue'>1.4.4. 目录类型</font>
> >
> > > #### <font color='cornflowerblue'>1.4.4.1. 单级目录结构：仅一表，每个文件占一表项</font>
> > >
> > > > <img src="https://s2.loli.net/2023/11/11/oFqAUQw27IxJPkN.png" alt="image-20211222195413258" style="zoom:50%;" /> 
> > > >
> > > > **1️⃣**动态操作
> > > >
> > > > 1. 建立文件：验证不重名后→找出一个空表目然后将信息填入
> > > > 2. 删除文件：找到对应目录项→找到物理地址→回收物理空间→回收目录项
> > > > 3. 访问文件：检索到文件名→找出物理地址→然后操作文件
> > > >
> > > > **2️⃣**缺点：只有一个目录，不允许文件重名，查找慢
> > >
> > > #### <font color='cornflowerblue'>1.4.4.2. 二级目录</font>
> > >
> > > > **1️⃣**结构：主文件目录+用户文件目录
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/EHiQcBzeh79Grd5.png" alt="image-20211222195549196" style="zoom:60%;" /> 
> > > >
> > > > 1. 主文件目录MFD：给出用户名+用户子目录指针
> > > > 2. 用户子目录UFD：给出用户所有文件的FCB
> > > >
> > > > **2️⃣**动态操作
> > > >
> > > > 1. 访问：主目录中查找用户名→进入用户目录查找文件名→得到物理地址
> > > > 2. 新用户建立文件：主目录中建立表目→给新用户目录分配空间→用户目录中添加表目→填入信息
> > > >
> > > > 3. 删除：直接删用户目录的目录项，用户目录为空就把主目录对应项删除
> > > >
> > > > **5️⃣**优劣：文件可重名，查找块，但灵活性差，不利于共享
> > >
> > > #### <font color='cornflowerblue'>1.4.4.3. 树形(多级)目录结构</font>
> > >
> > > > <img src="https://s2.loli.net/2023/11/11/BMbwRZ9DVSkyuNU.png" alt="image-20211222195800206" style="zoom:50%;" />  
> > > >
> > > > **1️⃣**结构：根目录=第一级的目录，非叶结点=均为目录文件(子目录)，叶=文件(每个文件都有唯一内部标识)
> > > >
> > > > **2️⃣**有关概念
> > > >
> > > > 1. 路径名：一个字符串，文件的唯一标识，按照`\`级联，分文绝对(根目录开始)+相对目录
> > > >
> > > > 2. 当前目录(工作目录)：选取某目录为当前目录，进程访问文件都是以这个目录为对照
> > > >
> > > >    PS: 某目录的上一级用`..`标识
> > > >
> > > > **3️⃣**优劣：可重名/检索快/有利于分类，查找文件要多次访问目录文件(在外存)
> > >
> > > #### <font color='cornflowerblue'>1.4.4.4. (无环)图形目录：相比树形更便于共享</font>
> > >
> > > > <img src="https://s2.loli.net/2023/11/11/LGCrPFHXT5Ro1Bj.png" alt="image-20231030215013322" style="zoom:67%;" /> 
> > > >
> > > > **1️⃣**结构：树形目录+指向同一结点的有向边
> > > >
> > > > **2️⃣**共享计数器：
> > > >
> > > > 1. 向该节点增/减共享链时计数器+1/-1，同时增/减指针
> > > > 2. 当共享计数器为0时结点才算真正删除，删除文件本身
> >
> > ### 1.4.5. 文件目录改进：分解FCB为两部分
> >
> > > **1️⃣**符号文件目录：文件名+文件内部标识→树状结构，按文件名排序
> > >
> > > **2️⃣**基本文件目录：其余文件说明信息→线性结构，按文件内部标识排序
> > >
> > > 可以加快检索
>
> ## <font color='cornflowerblue'>1.5. 文件共享：不同用户使用一个文件</font>
>
> > 核心问题：如何实现共享+共享用户的存取控制
> >
> > ### <font color='cornflowerblue'>1.5.1. 基于索引结点的共享(硬链接)</font>
> >
> > > **1️⃣**两个/多个目录项指向相同索引结点
> > >
> > > **2️⃣**索引结点有一计数器，统计其对应目录项个数(为1时才可删除节点，大于1时只减1)
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231031001337259.png" alt="image-20231031001337259" style="zoom:67%;" /> 
> >
> > ### <font color='cornflowerblue'>1.5.2. 利用符号链实现文件共享(软链接)</font>
> >
> > > <img src="https://s2.loli.net/2023/11/11/FR1iuBD2abVYH5e.png" alt="image-20231031001502707" style="zoom:67%;" /> 
> > >
> > > **1️⃣**符号链接(link类型文件)：包含被链接(共享)文件的**路径名**
> > >
> > > **2️⃣**链接和指针：文件拥有者才拥有指针+其他用户路径名，共享给的用户只拥有链接(路径名)
> > >
> > > **3️⃣**动态操作：将C的文件，共享给用户
> > >
> > > 1. 共享：B目录中，建立符号链接指向文件 C
> > >
> > > 2. 访问：检索目录，若检索到的是链接，OS自动忽略
>
> ## <font color='orange'>1.6. 文件保护</font>
>
> > **1️⃣**限制文件访问类型：读/写/执行/添加/删除/列出属性/重命名/复制/粘贴
> >
> > **2️⃣**针对不同用户访问控制
> >
> > 1. 含义：不同权限用户访问同一文件，采取不同访问类型
> >
> > 2. 方式：访问控制矩阵/访问控制表/用户权限表(用数据结构记录用户的操作权限)+口令密码

# <font color='cornflowerblue'>2. 文件系统的实现</font>

> ## <font color='cornflowerblue'>2.1. 文件系统概述</font>
>
> > ### <font color='cornflowerblue'>2.1.1. 文件系统概念</font>
> >
> > > **1️⃣**定义：OS中，(以文件方式)管理软件资源的软件+被管理的文件+被管理的数据结构
> > >
> > > **2️⃣**文件系统的作用
> > >
> > > 1. OS角度的文件系统：**对存储文件的空间**组织/分配/回收，**对文件**存储/检索/共享/保护
> > >
> > > 2. 用户角度的文件系统：实现按名存取(用户知道文件名就可以获取文件信息)
> >
> > ### <font color='cornflowerblue'>2.1.2. 层次结构</font>
> >
> > > <img src="https://s2.loli.net/2023/11/11/PnwOjm7QteNY4rU.png" alt="image-20231031113206475" style="zoom:67%;" />  
> > >
> > > **1️⃣**用户接口：图形窗口/命令行→连接现实与虚拟，用户通过用户接口向OS发出文件操作命令
> > >
> > > **2️⃣**文件目录系统：查找目录，找到文件F索引信息
> > >
> > > **3️⃣**存取控制验证：即使有索引信息，也要看你有无访问权
> > >
> > > **4️⃣**逻辑文件系统与文件信息缓冲区：确定拥有访问权后，先找到逻辑地址
> > >
> > > **5️⃣**物理文件系统：再由逻辑地址找到物理地址，这一层分为外存分配管理+设备管理
>
> ## <font color='orange'>2.2. 目录的实现</font>
>
> > **1️⃣**线性表：按顺序存放文件信息(文件名+数据块)，创建删除文件就是线性表的插入和删除，创建是还要遍历检查文件是否已存在(因此低效)
> >
> > **2️⃣**散列表：(查找/删除时)将HASH函数将文件名转化为数字，用这个数字找到文件信息位置。但需要一个好的冲突解决策略
>
> ## <font color='cornflowerblue'>2.3. 文件在存储器的实现(文件的物理结构)</font>
>
> > ### <font color='cornflowerblue'>2.3.1. 外存分配方式: 如何为文件分配磁盘</font>
> >
> > > #### <font color='cornflowerblue'>2.3.1.1. 顺序分配：文件分配连续的磁盘区域</font>
> > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231031124445960.png" alt="image-20231031124445960" style="zoom: 50%;" /> 
> > > >
> > > > **1️⃣**文件创建过程：用户进程说明文件所需空间，OS查找空闲区管理表，若有足够空间就为文件分配，否则等待
> > > >
> > > > **2️⃣**结构：逻辑相邻可以是物理相邻
> > > >
> > > > **3️⃣**优劣：查找快，但是会产生外碎片，不适合文件大小动态变化
> > >
> > > #### <font color='cornflowerblue'>2.3.1.2.链接分配</font>
> > >
> > > > <img src="https://s2.loli.net/2023/11/11/rojeH6BPNZdimTI.png" alt="image-20231031130544970" style="zoom:60%;" /> 
> > > >
> > > > **1️⃣**隐式链接：
> > > >
> > > > 1. 含义：文件信息再若干不连续块中，每个块都指向文件的下一块，读文件只需找到第一块
> > > > 2. 缺点：<mark>存取速度慢(不适于随机存取)</mark>，可靠性差(一个指针烂了后面都没用了)
> > > >
> > > > **2️⃣**显式连接：所有指针被放在**文件分配表FAT**(整个磁盘只有一张)，列出了所有块及其位置。缺点是仍需从表顶开始找
> > >
> > > #### <font color='cornflowerblue'>2.3.1.3. 索引分配</font>
> > >
> > > >  <img src="https://s2.loli.net/2023/11/11/NYsicdgPxLntw3e.png" alt="image-20211111154450144" style="zoom: 50%;" /> 
> > > >
> > > >  **1️⃣**结构：每个文件分配一个索引块，块中放索引表，表中每个表项分给该文件一个物理块
> > > >
> > > >  PS：索引表——本质上是磁盘块地址数组，其中第i个条目指向文件第i块
> > > >
> > > >  **2️⃣**优点：能够随机存取，无外碎片
> > > >
> > > >  **3️⃣**缺点：索引块占空间(其大小也很重要)，存取需要两次访问(但可在访问文件前就把索引表调入内存)
> > > >
> > > >  **4️⃣**多级索引表：如果文件很大索引表也会很大，大到超过一块时，可以把索引表当作文件再为其建立索引表
> > >
> > > #### <font color='cornflowerblue'>2.3.1.4. 番外：多级索引分配补档</font>
> > >
> > > > **1️⃣**单级索引分配：文件名为test，索引表放在19块中，索引表指出的文件结构(块序)为9,16,1,10
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/Cwut59FTHqzZg8s.png" alt="image-20231031153326763" style="zoom:67%;" /> 
> > > >
> > > > **2️⃣**两级索引分配：文件名test，索引到主索引的块号(每块含有二级索引块号)，又索引到第二级索引块号(每块包含文件块号序列)，索引到文件块号
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/Lku35Hc7yOtGRIr.png" alt="image-20231031153834804" style="zoom:67%;" /> 
> > > >
> > > > **3️⃣**混合索引分配：假设每个盘块大小4K
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/wPAQTtcjDy6SO9i.png" alt="image-20231031155321772" style="zoom:67%;" /> 
> > > >
> > > > 1. 直接地址：主要是为提高检索速度，此处有10个直接地址项，可索引10块共40K地址。文件小于40K时直接到这里来
> > > >
> > > > 2. 一次间接地址：就是一级索引分配，其一次可索引1K个盘块，每块4KB，故允许文件长4MB
> > > >
> > > >    为什么是1K呢，因为一个表项4B，一块4KB，所以一块中就有4K个表项，一个表项索引到一块
> > > >
> > > > 3. 二次间接地址：两级索引分配，索引一次1K块，每块又索引1K块，总大小4MB*1K=4GB
> > > >
> > > > 4. 三次间接寻址：以此类推是4TB
> >
> > ### <font color='cornflowerblue'>2.3.2. (空闲)文件存储空间管理</font>
> >
> > > #### <font color='cornflowerblue'>2.3.2.1. 空闲文件表法</font>
> > >
> > > > **1️⃣**空闲文件/空白文件/自由文件：存储设备的一个连续空闲区
> > > >
> > > > **2️⃣**空闲盘块表：一个空闲文件占据一表项，表项包含第一空闲块号+空闲块号数+物理块号
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/vUdJBMHZOoNkDif.png" alt="image-20231031165117594" style="zoom: 50%;" /> 
> > > >
> > > > **3️⃣**动态操作：
> > > >
> > > > 1. 请求存储空间：扫描空闲目录然后请求，请求=空闲直接分配，请求<空闲则留下空余项并修改表项，请求>空闲就不请求
> > > >
> > > > 2. 撤销文件：扫描空闲目录，将释放空间的第一个物理块号填到表中
> > > >
> > > >    释放块与其他空闲块相邻则直接合并
> > >
> > > #### <font color='cornflowerblue'>2.3.2.2. 空闲块链表法</font>
> > >
> > > > **1️⃣**概述：将所有空闲块连接成一个链表+一个头指针
> > > >
> > > > **2️⃣**动态操作
> > > >
> > > > 1. 建立文件：从链首依次取下几个空闲块给文件
> > > > 2. 撤销文件/回收存储空间：将要回收的空闲块依次链接入空闲块链表
> > > >
> > > > **3️⃣**空闲盘区链：
> > > >
> > > > 1. 将链表元素从空闲盘块改为空闲盘区
> > > > 2. 每盘区有：若干空闲盘块+指向下一盘区指针+本盘区大小指示
> > >
> > > #### <font color='cornflowerblue'>2.3.2.3. 位视图法</font>
> > >
> > > > **1️⃣**概述：文件存储器在主存中建立一张表，每位都对应一物理块，1=已分配，0=空闲
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/iU3LNkat815MRJr.png" alt="image-20231031172855185" style="zoom:67%;" /> 
> > > >
> > > > **2️⃣**动态操作：请求分配时OS先要扫描这张表，找出一组0，得到其盘号，然后改为1；回收正好相反
> > >
> > > #### <font color='orange'>2.3.2.4. 成组链接法(UNIX)</font>
> > >
> > > > **1️⃣**基本结构
> > > >
> > > > <img src="https://s2.loli.net/2023/11/11/GCuqJrZhNBWUycd.png" alt="image-20231101141812714" style="zoom:67%;" /> 
> > > >
> > > > 1. 将所有空闲块，100块一组分很多组
> > > > 2. 每组需要记录两个数据：组中块数，所有块的编号。这两个数据放在前一组第一块中
> > > > 3. 第一块的这两个数据放在超级块中
> > > > 4. 总体结构：每组第一块链接成链表，组内多块构成堆栈
> > > >
> > > > **2️⃣**分配空闲盘块的方法
> > > >
> > > > 1. OS要为文件分配空闲块，先检查第一组中的块数
> > > > 2. 若第一组块数>1，则超级块中记录的空闲块数-1，第一组中栈顶的块分配给文件
> > > > 3. 重复2的操作，直到第一组中只剩一块了，这一块是来记录下一组的块号和块数的
> > > > 4. 则将第二组的信息读入超级块，然后继续分配
> > > > 5. 一直读到最后一组，栈顶盘块有结束标记0，代表所有块都用完了，停止分配
> > > >
> > > > **3️⃣**空闲盘块的回收
> > > >
> > > > 1. 若一组中不足100块，则直接把回收的块塞进去，然后超级块中放入该块号&空闲块数+1
> > > > 2. 若一组已经100块了，则先将第一组的块号+块数写入回收块
> > > > 3. 由此这个回收块就变成了新的第一组了(一组仅这一块)
> > > > 4. 最后跟新超级块，块数变为1，设置块号为回收块的块号

# <font color='cornflowerblue'>3. 外存储器</font>

> ## <font color='cornflowerblue'>3.1. 磁盘组：多磁盘绕中轴高速旋转</font>
>
> > ### <font color='cornflowerblue'>3.1.1. 物理记录定位</font>
> >
> > > **1️⃣**柱面：同一垂直位置，各盘面相应磁道的集合，编号从外向内0, 1, 2, ..., L
> > >
> > > **2️⃣**磁头：每个盘面一个磁头，编号从上而下0, 1, 2, ..., H，表示有效盘面
> > >
> > > **3️⃣**扇区：盘面被分为若干大小相同的扇区，编号为0, 1, 2, ..., n
> >
> > ### <font color='cornflowerblue'>3.1.2. 磁盘编址</font>
> >
> > > **1️⃣**逻辑块：传输数据的最小单位
> > >
> > > **2️⃣**映射方式：<font color='red'>逻辑块的一维数组$\xleftrightarrow{映射}$磁盘相连扇区</font>，磁道中扇区按顺序映射到逻辑块数组
> > >
> > > **3️⃣**映射的顺序：某一磁道$\xrightarrow{一个磁道映射完了}$同柱面其他磁道$\xrightarrow{柱面都用完了}$从外向里其他柱面
> >
> > ### <font color='cornflowerblue'>3.1.3. 盘块物理地址&盘块号</font>
> >
> > > **1️⃣**物理地址组成：[柱面号L] [磁头/盘面号M] [扇区号N]
> > >
> > > **2️⃣**物理块→唯一盘块号：$B = (i×M×N)+(j×N)+k$
> > >
> > > 范围：$i=0…,L-1; j=0,…,M-1; k=0, …, N-1$
> > >
> > > 1. $(i×M×N)$：达第 i个柱面之前的总扇区数
> > > 2. $(j×N)$：当前第i柱面，到达第 j个盘面之前的扇区数
> > > 3. $k$：当前盘面上的扇区号
> > >
> > > **3️⃣**块号→物理块(一下计算自动强制转换int)
> > >
> > > M×N=每柱面的扇区总数→B/(M×N)=之前经历了几个完整柱面
> > >
> > > B%(M × N)=当前柱面中扇区的偏移数→[B%(M × N)]/N=当前柱面中经历了几个完整盘块
> > >
> > > - 柱面号i=B/(M×N)
> > > - 盘面号j=[B%(M × N)]/N
> > > - 扇区号k=B%N
>
> ## <font color='cornflowerblue'>3.2. 磁盘访问时间</font>
>
> > 总时间$T_a=T_S+T_r+T_t$
> >
> > **1️⃣**寻道时间$T_S=mn+s$：移动磁头到指定磁道所需时间
> >
> > 1. m: 磁头移动一个磁道所需时间，一般磁盘=0.2/高速磁盘≤0.1
> > 2. n：移动磁道数
> > 3. s：磁臂启动时间，一般为2ms
> >
> > **2️⃣**旋转延迟时间$T_r=\cfrac{1}{2r}$：磁头到达了磁道后，让扇区移到磁头所需时间
> >
> > 1. r：磁盘的转速，公式基于假设——平均需要转0.5圈找到扇区
> >
> > **3️⃣**传输时间$T_t=\cfrac{b}{rN}$：读出或写入数据所需的时间
> >
> > 1. b：所读/写的字节数
> > 2. N：一条磁道上的字节数→b/N=需要读多少个磁道(转多少圈)
> >
> > ➕磁盘IO提速小妙招——提高磁盘性能/设置Cache/选择好的调度算法
>
> ## <font color='cornflowerblue'>3.3. 磁盘调度</font>
>
> > ### <font color='cornflowerblue'>3.3.1. FCFS</font>
> >
> > > 如图磁头共移动了640个柱面距离。
> > >
> > > <img src="https://s2.loli.net/2023/11/12/ZVAwrHkq7vLlIgU.png" alt="image-20211118151142233" style="zoom: 50%;" /> 
> >
> > ### <font color='cornflowerblue'>3.3.2. SSTF最短寻道时间优先</font>
> >
> > > **1️⃣**含义：选磁头当前位置，所需寻道时间最短的请求
> > >
> > > **2️⃣**特点：实质上是SJF(短作业优先)，会引起某些请求饥渴
> > >
> > > **3️⃣**示例：磁头移动总距离236柱面
> > >
> > > <img src="https://s2.loli.net/2023/11/12/AX9vNCzqt5ycQYE.png" alt="image-20211118151622285" style="zoom: 50%;" /> 
> >
> > ### <font color='cornflowerblue'>3.3.3. 各种SCAN算法</font>
> >
> > > #### <font color='cornflowerblue'>3.3.3.1. SCAN算法</font>
> > >
> > > > **1️⃣**含义：选择与磁头当前的移动方向一致且距离最近的请求
> > > >
> > > > **2️⃣**特点：磁头只会出现一次转向，转向时要先回到磁盘的最内/最外端
> > > >
> > > > **3️⃣**示例：磁头移动总距离236柱面
> > > >
> > > > <img src="https://s2.loli.net/2023/11/12/4ehDwd1S392kAXi.png" alt="image-20211118151722932" style="zoom: 40%;" /> 
> > >
> > > #### <font color='cornflowerblue'>3.3.3.2. C-SCAN算法</font>
> > >
> > > > **1️⃣**含义：磁头往同一方向移动→沿途响应最近请求→到顶后返回磁头开始处→再往原方向响应请求
> > > >
> > > > **2️⃣**特点：把所有柱面看成一个循环，最后一个柱面接第一个柱面
> > > >
> > > > **3️⃣**示例
> > > >
> > > > <img src="https://s2.loli.net/2023/11/12/dWEo497HbvGmFTw.png" alt="image-20211118152236215" style="zoom: 48%;" />  
> > >
> > > #### <font color='cornflowerblue'>3.3.3.3. 分步扫描算法</font>
> > >
> > > > **1️⃣**步骤：
> > > >
> > > > 1. 将请求队列分成若干个长度为N的子队列，按照FCFS处理这些子队列
> > > > 2. 在每个子队列中，按SCAN算法处理
> > > > 3. 处理某一子队列时，若又有新I/O请求，便将请求进程放入其他子队列
> > > >
> > > > **2️⃣**性能：N极大时接近SCAN，N=1时就是FCFS
> > > >
> > > > **3️⃣**优点：I/O请求等待时间不至于过长，不容易饿死
> > >
> > > #### <font color='cornflowerblue'>3.3.3.4. F-SCAN算法</font>
> > >
> > > > 只分两个子队列
> > > >
> > > > 1. 当前队列：所有请求磁盘I/O的进程，按SCAN处理
> > > > 2. 等待队列：SCAN期间新出现的请求进程
> >
> > ### <font color='cornflowerblue'>3.3.4. LOOK&C-LOOK算法</font>
> >
> > > **1️⃣**含义：区别于SCAN算法，转向/返回的时候不需要回到磁盘最内/最外端
> > >
> > > **2️⃣**示例
> > >
> > > <img src="https://s2.loli.net/2023/11/12/tnWIbDaAqrM7dLg.png" alt="image-20211118152405765" style="zoom: 43%;" /> 
> > >
> > > <img src="https://s2.loli.net/2023/11/12/HocTMBifVgKv4PD.png" alt="image-20211222212520283" style="zoom:48%;" /> 
>
> ## <font color='cornflowerblue'>3.4. 磁盘高速缓存</font>
>
> > **1️⃣**含义：用内存空间来暂存磁盘数据，物理属于内存，逻辑属于磁盘
> >
> > **2️⃣**形式：
> >
> > 1. 内存中开辟一个单独的**大小固定的**空间
> > 2. 把所有未利用内存空间变为一个**缓冲池**
> >
> > **3️⃣**数据交付：如何将磁盘Cache数据给请求的进程
> >
> > 1. 数据交付：Cache数据→请求进程的内存工作区
> > 2. 指针交付：将指向Cache某区域的指针，交给请求进程
> >
> > **4️⃣**置换算法：LRU

# <font color='cornflowerblue'>I/O(设备)管理</font>

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/5.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/5.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/5.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/5.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.html)==**

# <font color='cornflowerblue'>1. IO系统给的组成</font>

> ## <font color='cornflowerblue'>1.1. IO系统硬件：设备+控制器+通道+总线</font>
>
> > ### <font color='cornflowerblue'>1.1.1. IO设备</font>
> >
> > > 性能指标有：数据传输速率，数据传输单位，设备共享属性
> > >
> > > 分类：
> > >
> > > **1️⃣**按使用特性：存储(磁盘)+人机交互(键盘/显示器/打印机)+网络通信(网口)
> > >
> > > **2️⃣**按信息交换单位：
> > >
> > > 1. 字符设备：用于数据IO，如键盘/打印机/显示器
> > > 2. 块设备：用于存储信息，如磁盘
> > > 3. 其他：如时钟
> > >
> > > **3️⃣**传输速率：低速(键盘/鼠标)+中速(打印机)+高速设备(磁盘)
> > >
> > > **4️⃣**按共享属性：
> > >
> > > 1. 独占：不允许多进程访问，如打印机
> > > 2. 共享：允许多进程访问，如磁盘
> > > 3. 虚拟设备：一个设备逻辑上被共享给多个进程，如虚拟后的打印机
> >
> > ### <font color='cornflowerblue'>1.1.2. 设备控制器</font>
> >
> > > **1️⃣**IO设备的组成：电子部分(设备控制器，介于CPU和IO设备之间)+机械部分
> > >
> > > **2️⃣**设备控制器功能：
> > >
> > > 1. 接收CPU指令，在CPU/设备间交换数据
> > > 2. 记录设备状态供CPU查询
> > > 3. 识别所控制的设备的地址(设备数=设备地址数)
> > > 4. 缓冲CPU和设备间的数据，进行IO差错控制
> > >
> > > **3️⃣**设备控制器结构
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240201121705515.png" alt="image-20240201121705515" style="zoom: 43%;" />  
> >
> > ### <font color='cornflowerblue'>1.1.3. IO通道</font>
> >
> > > **1️⃣**概念：独立于CPU的处理器，负责IO控制
> > >
> > > **2️⃣**功能：统一管理外设，代替CPU独立执行I/O任务，使I/O与CPU可并行，
> > >
> > > **3️⃣**但是指令单一，无自己内存(所以通道程序放主存中)，贵
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20211222215101983.png" alt="image-20211222215101983" style="zoom:67%;" /> 
>
> ## <font color='cornflowerblue'>1.2. IO软件</font>
>
> > ### <font color='cornflowerblue'>1.2.1. I/O软件功能</font>
> >
> > > **1️⃣**提供设备与用户的接口
> > >
> > > **2️⃣**分配/释放设备：使用设备前，需分配设备/通道/控制器，然后把设备给进程
> > >
> > > **3️⃣**设备访问/控制：包括并发访问&差错处理
> > >
> > > **4️⃣**I/O缓冲调度：让CPU和IO速度匹配
> > >
> > > **5️⃣**设备独立性(无关性)：应用程序独立于物理设备，编程时不出现设备名，否则拔掉设备就会出Bug
> >
> > ### <font color='cornflowerblue'>1.2.2. 结构层次</font>
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240201121737047.png" alt="image-20240201121737047" style="zoom:45%;" />  
> > >
> > > **1️⃣**用户层软件：用户通过它发出IO请求，发出请求后用户进程中断等待，随后请求到达下一层:arrow_down:
> > >
> > > **2️⃣**设备独立性软件：提供统一接口，对软件屏蔽了硬件，将请求转发给合适设备驱动程序
> > >
> > > **3️⃣**设备驱动程序：与特定硬件通信，将从上层收到的指令转化为硬件指令，发给指定设备
> > >
> > > **4️⃣**硬件：接收来自设备驱动程序的指令，执行指令
> > >
> > > ➕ 中断处理程序：硬件IO完后，由它通知CPU前来处理中断，确定中断原因+唤醒之前阻塞的驱动程序，完成IO

# <font color='cornflowerblue'>2. IO控制方式</font>

> ## <font color='cornflowerblue'>2.1. 程序IO(轮询)方式</font>
>
> > CPU与设备串行工作，CPU循环测试(守着IO全过程)，大量CPU时间被浪费
>
> ## <font color='cornflowerblue'>2.2. 中断驱动I/O：现代计算机广泛使用</font>
>
> > **1️⃣**以**字(节)为单位**进行I/O
> >
> > **2️⃣**在I/O设备输入/输出每个数据的过程中，无须CPU干预。
> >
> > **3️⃣**仅当传输完一个数据时，才需CPU花极短时间去做些中断处理
>
> ## <font color='cornflowerblue'>2.3. DMA控制方式</font>
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240201123047964.png" alt="image-20240201123047964" style="zoom:50%;" />   
> >
> > **1️⃣**概述：
> >
> > 1. 外设-内存间开辟通道，直接交换数据(不通过CPU)
> > 2. 以块为单位传输数据
> > 3. 这一过程由DMA控制器完成
> >
> > **2️⃣**中断控制&DMA：
> >
> > 1. DMA在块数据传完后才中断CPU，频率低得多
> > 2. 中断方式处理中断的是CPU，DMA控制方式则是DMA处理中断
> >
> > **3️⃣**特点：
> >
> > 1. 设备可以和CPU并行工作
> > 2. 数据只能单向传输，DMA一次也只能执行一条IO指令
>
> ## <font color='cornflowerblue'>2.4. 通道控制方式：外设-内存直接交换数据</font>
>
> > <font color='orange'>**1️⃣**字节多路通道：多路低速</font>
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240201123212420.png" alt="image-2024023212420" style="zoom: 50%;" />  
> >
> > 1. 作用：连接多个以字节为单位传输的慢速设备
> > 2. 字节交叉：多个设备轮流在同一通道上发送和接收数据
> >
> > <font color='orange'>**2️⃣**数组选择通道：单路高速</font>
> >
> > 高速设备的通信通道，传输单位为数组，会被一台设备霸占，效率低
> >
> > **3️⃣**数组多路通道：多路高速
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/ed1RHZygS5Mzknb.png" alt="image-2024021123330207" style="zoom: 50%;" />  
> >
> > 1. IO通道工作方式：接受CPU委托，独立执行通道程序，实现I/O设备与内存间的信息交换
> > 2. 与DMA控制的区别：DMA要CPU控制块大小和传输内存地址，通道则全权负责

# <font color='cornflowerblue'>3. IO缓冲</font>

> ## <font color='cornflowerblue'>3.1. 缓冲引入</font>
>
> > **1️⃣**目的：缓和CPU与I/O设备间速度不匹配的矛盾，减少CPU中断频率，提高CPU和IO设备并行性
> >
> > **2️⃣**缓冲的设计：进程先输出数据给缓冲，慢速设备从缓冲中读取
> >
> > **3️⃣**缓冲的实现：硬件缓冲器(贵)，内存缓冲区(内存中专门划一块来缓存IO数据)
>
> ## <font color='cornflowerblue'>3.2. 三种缓冲</font>
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231102222338545.png" alt="image-20231102222338545" style="zoom: 67%;" /> 
> >
> > **1️⃣**单缓冲：只有一个IO缓冲区，在内存中，用户发出IO请求时会分配这个缓冲区
> >
> > **2️⃣**双缓冲：交替使用两个缓冲区(一个传数据给进程，另一个同时读数据)
> >
> > **3️⃣**循环缓冲：
> >
> > 1. 结构：多个大小相等的缓冲区构成循环链表
> >
> > 2. in/out指针：in指向首个可输入空缓冲区，out指向首个可提取数据满缓冲区
> >
> > 3. IO过程：数据通过in放入缓冲→通过out输出
>
> ## <font color='cornflowerblue'>3.3. 缓冲池：目前广泛使用的</font>
>
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240201123656922.png" alt="image-20240201123656922" style="zoom:50%;" />   
> > >
> > > **1️⃣**缓冲区分类：收容(h)/提取(s)+输入(in)/输出(out)→四种组合
> > >
> > > **2️⃣**缓冲池组成：
> > >
> > > 1. 空缓冲区→空缓冲队列
> > > 2. 输入缓冲区：装满输入数据→输入队列
> > > 3. 输出缓冲区输出数据队列
> > >
> > > **3️⃣**输入数据：
> > >
> > > 1. 收容输入：往空队列中的一个空区输入数据→丢给输入队列→进入缓冲区
> > > 2. 提取输入：进程从缓冲区取走数据
> > >
> > > **4️⃣**输出数据
> > >
> > > 1. 收容输出：往空队列中的一个空区输入数据→丢给输出队列→进入缓冲区
> > > 2. 提取输出：设备从缓冲区取走数据
> >
> > ## <font color='orange'>3.4. 高速缓存与缓冲区</font>
> >
> > > **1️⃣**存放内容不同：Cache缓存低速设备的数据备份，缓冲区存的是中转数据
> > >
> > > **2️⃣**目的不同：Cache是为减少内存访问次数，缓冲区解决速度不匹配

# <font color='cornflowerblue'>4. 设备的分配：有且只能由OS完成</font>

> ## <font color='cornflowerblue'>4.1. 设备管理中的数据结构</font>
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20211125142402239.png" alt="image-20211125142402239" style="zoom:50%;" /> 
> >
> > **1️⃣**SDT系统设备表：整个系统只有一张，一个表目待变一个连接的设备
> >
> > **2️⃣**DCT设备控制表：与控设备一一对应
> >
> > **3️⃣**COCT控制器控制表：与控制器一一对应
> >
> > **4️⃣**CHCT通道控制表：与通道一一对应
>
> ## <font color='cornflowerblue'>4.2. 设备分配策略/考虑因素</font>
>
> > ### <font color='cornflowerblue'>4.2.1. 设备使用性质</font>
> >
> > > **1️⃣**一进程独占：可以静态/动态分配
> > >
> > > **2️⃣**多进程共享：提出I/O请求的不同进程以排队方式分时地占用设备进行I/O
> > >
> > > **3️⃣**虚拟化：多进程共享，但每个进程看似独占
> >
> > ### <font color='cornflowerblue'>4.2.2. 设备分配算法</font>
> >
> > > FCFS，优先级高这优先(优先级相同时采用FCFS)
> >
> > ### <font color='cornflowerblue'>4.2.3. 安全性：设备分配时不死锁</font>
> >
> > > **1️⃣**静态分配(不死锁)：作业执行前就分配所有设备和控制器，执行时始终占用
> > >
> > > **2️⃣**动态分配：进程执行时根据进程的申请分配/释放设备
> > >
> > > 1. 安全分配(不死锁)：进程每请求一次IO，就被阻塞一次，IO完成后才唤醒，效率低
> > >
> > > 2. 不安全分配(可能死锁)：进程发出IO请求，进程还可能继续发出IO请求
>
> ## <font color='cornflowerblue'>4.3. 设备独立性</font>
>
> > **1️⃣**目的：提高OS的可适应性和可扩展性
> >
> > **2️⃣**含义：应用程序独立于具体使用的物理设备
> >
> > **3️⃣**逻辑设备&物理设备
> >
> > 1. OS使用物理设备名，应用程序使用逻辑设备名
> > 2. OS将逻辑设备名→物理设备名
> >
> > **4️⃣**逻辑设备表(LUT)：OS中每个用户一个表
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20211125143617795.png" alt="image-20211125143617795" style="zoom: 67%;" /> 
>
> ## <font color='orange'>4.4. 设备分配程序</font>
>
> > **1️⃣**单通路I/O系统的设备分配：进程请求分配→一次性分配设备+控制器+通道，忙则到等待队列去
> >
> > **2️⃣**多通路I/O系统的设备分配：一个设备连接多个设备控制器，设备控制器连接多通道
> >
> > 1. 进程提出IO请求
> > 2. 找到第一个空闲设备，验证安全后分配(反之等待)
> > 3. 找到第一个与设备相连的空闲控制器，分配(若无返回第一步)
> > 4. 找到第一个与控制器相连的空闲通道，分配(若无返回第二步)
> > 5. IO启动

# <font color='cornflowerblue'>5. 假脱机技术(SPOOLing)</font>

> ## <font color='cornflowerblue'>5.1. 概述</font>
>
> > **1️⃣**目的：将独占设备改为共享设备技术，使得主机直接控制下实现脱机IO
> >
> > **2️⃣**原理：
> >
> > 1. 一道程序模拟脱机输入时的外围控制机：数据从低速IO设备→高速磁盘
> > 2. 一道程序模拟脱机输出时的外围控制机：数据从磁盘→低速输出设备
>
> ## <font color='cornflowerblue'>5.2. 组成</font>
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/g9SHwPzvGxq7Nu1.png" alt="image-20231103152137976" style="zoom: 67%;" /> 
> >
> > **1️⃣**输入/输出井：都为磁盘上存储区
> >
> > 1. 输入井：模拟脱机输入的磁盘，收容IO输入数据
> > 2. 输出井：模拟脱机输出的磁盘，收容用户程序输出的数据
> >
> > **2️⃣**输入/输出缓冲区：在内存中，暂存中转数据
> >
> > **3️⃣**输入输出进程：模拟脱机输入/输出的外围控制机
>
> ## <font color='cornflowerblue'>5.3. 实现&工作流程</font>
>
> > **1️⃣**用户请求打印输出
> >
> > **2️⃣**输出进程在输出井申请一块空闲盘块区，把打印数据塞进去
> >
> > **3️⃣**输出进程申请一张空白的用户请求打印表，填入打印要求，然后把表挂上请求打印队列
> >
> > **4️⃣**输出进程从请求打印队列中取出请求打印表，根据表中要求再从输出井中取出打印内容

# 6. 设备处理：驱动程序+中断处理

> ## 6.1. 设备驱动程序
>
> > **1️⃣**目的：封装不同的IO设备及其具体差异，使得OS能统一处理他们
> >
> > **2️⃣**含义：处理或操作硬件控制器的软件
> >
> > **3️⃣**处理过程：
> >
> > 抽象要求转为具体的→检查IO合法性→检测设备状态→传输必要参数→设置方式→启动IO
>
> ## 6.2. 中断处理程序
>
> > **1️⃣**中断过程：
> >
> > 1. 设备控制器准备好服务(输入数据已有/输出完成/检测到错误)，会向CPU发中断请求
> >
> > 2. CPU收到中断请求后，转而去执行中断程序
> >
> > **2️⃣**中断处理程序的步骤
> >
> > 1. 唤醒被阻塞的驱动程序进程
> >
> > 2. 保护被中断进程的CPU环境
> >
> > 3. 分析中断原因，转入相应的设备中断处理程序
> >
> > 4. 进行中断处理
> >
> > 5. 恢复被中断进程的现场

# 记住-<font color='cornflowerblue'>考过</font>-<font color='orange'>常考</font>-<font color='red'>必考</font>-<mark>重点</mark>

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/OS%E5%A4%8D%E4%B9%A0_%E6%A6%82%E5%BF%B5%E7%AF%87.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/OS%E5%A4%8D%E4%B9%A0_%E6%A6%82%E5%BF%B5%E7%AF%87.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/OS%E5%A4%8D%E4%B9%A0_%E6%A6%82%E5%BF%B5%E7%AF%87.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/OS%E5%A4%8D%E4%B9%A0_%E6%A6%82%E5%BF%B5%E7%AF%87.html)==**

# 1. 操作系统基本概念

> ## 1.1. OS的特性
>
> > **1️⃣**<font color='red'>**最基本的是**</font>：<mark>并发性，共享性(资源的互斥使用以及同时使用)</mark>，这两点基于多道程序技术实现
> >
> > **2️⃣**虚拟性：一个物理实体映射为多个逻辑实体
> >
> > **3️⃣**<font color='cornflowerblue'>**异步性(不确定性)**</font>：多道程序下，每个程序推进的顺序不确定，执行结果也不确定
>
> ## **<font color='red'>1.2. OS给用户的接口</font>**
>
> > **1️⃣命令接口**：<mark>供用户控制作业的执行，管理计算机系统</mark>，有命令行，GUI，批处理
> >
> > **2️⃣程序接口**：<mark>供程序员使用OS提供的系统调用，来请求操作系统提供服务</mark>
>
> ## **<font color='cornflowerblue'>1.3. OS的目标/作用/地位</font>**
>
> > **1️⃣**目标：方便性(方便用户使用计算机)，有效性(提高系统资源的利用率)，可扩充性，开放性
> >
> > **2️⃣**作用(资源管理观点)：控制和管理计算机软硬件资源，包括CPU管理，存储器管理，文件管理，设备管理
> >
> > **3️⃣**作用(用户观点)：用户与裸机之间的接口，裸机的扩充机器
> >
> > **4️⃣**地位：是紧挨着硬件的第一层软件，是供其他软件运行的环境
>
> ## <font color='orange'>1.4. 三大类操作系统</font>
>
> > **1️⃣**分时系统：
> >
> > 1. **<font color='cornflowerblue'>分时技术</font>**：通过把CPU时间分成很短的时间片，按照时间片轮流把CPU分给作业使用，使多个用户可以同时使用一台计算机
> >
> > 2. <font color='cornflowerblue'>**特点**</font>：
> >    - 同时性：多个用户逻辑上共享一台计算机，而微观上是在轮流使用CPU等资源
> >    - 独立性：各个用户彼此独立，互不干扰地使用一台计算机
> >    - 及时性：系统对终端用户的请求能在足够快的时间之内得到响应
> >    - 交互性：采用人机对话方式
> >
> > **2️⃣**实时系统
> >
> > 1. **含义**：专为处理实时任务而设计的操作系统，能够快速响应请求
> >
> > 2. <font color='cornflowerblue'>**最基本特点**</font>
> >    - <mark>及时性</mark>：要求对外部请求在严格时间范围内做出响应
> >    - <mark>可靠性</mark>
> >
> > **3️⃣**批处理系统的特点
> >
> > - 多道：内存中同时存放多个作业，一个时刻只有一个作业运行
> > - 成批：用户和作业之间没有交互性。用户不能干预作业的运行
> > - 系统吞吐量和资源的利用率有所提高
> >
> > **4️⃣**<font color='orange'>**分时vs实时**</font>：
> >
> > - 分时系统是为了给用户一个交互式开发运行环境，实时系统则是为特使用途提供专用系统
> > - 相比分时系统，实时系统的及时性和可靠性更高
> > - 相比实时系统，分时系统的交互性更高
>
> ## <font color='red'>1.5. 操作系统的两种接口&系统调用</font>
>
> > **1️⃣**用户接口(作业级接口)：OS给终端用户的界面，用于与操作系统交互；有命令行，GUI，批处理
> >
> > **2️⃣**系统调用接口(程序级接口)：OS提供给程序的接口，用于请求操作系统的服务
> >
> > **3️⃣**<font color='red'>**系统调用**</font>：
> >
> > 1. 含义：程序请求操作系统服务的接口
> > 2. 分类：分为<mark>可中断的调用</mark>(如IO)和<mark>不可中断的调用</mark>(如原子操作)
> > 3. 作用：**扩充机器功能**、**增强系统能力**、**方便用户使用**
>
> ## <font color='cornflowerblue'>1.6. 多道程序设计</font>
>
> > **1️⃣**含义：在内存中同时存放多道用户作业，使他们都处于执行的开始与结束点之间
> >
> > **2️⃣**特点：特点是多道，宏观并行，微观串行
> >
> > **3️⃣**原理：利用了<mark>CPU和I/O设备的并行</mark>工作能力来提高系统效率的
> >
> > 或者说：让<mark>CPU和IO设备并行</mark>的技术是多道程序设计，分时技术
> >
> > **4️⃣**多道程序的基础是：**存储保护与程序浮动；处理器的管理和分配；系统资源的管理和调度**
> >
> > **5️⃣**好处：提高CPU和系统资源的利用率，增加吞吐量，减少程序响应时间，提高系统的并发性能
>
> ## 1.7. 其他
>
> >  **1️⃣**系统吞吐量：指系统在单位时间内所完成的总工作量

# 2. 进程与线程

> ## <font color='orange'>2.1. PCB</font>
>
> > **1️⃣**<font color='orange'>**概念**</font>：是OS管理进程的专门数据结构，常驻内存
> >
> > **2️⃣**<font color='orange'>**功能**</font>：记录进程的外部特征，描述进程的动态变化，OS用它控制和管理进程，感知进程的存在
> >
> > **4️⃣**内容：进程标识符，CPU现场，进程调度信息(优先级/时间/时间)，进程控制信息(资源/地址)
> >
> > **3️⃣**<font color='orange'>**PCB的初始化工作**</font>：初始化进程标识符，初始化处理机状态信息，<mark>初始化进程调度和控制信息</mark>
>
> ## 2.2. 进程
>
> > **1️⃣**<font color='cornflowerblue'>**进程概念**</font>：程序在一个数据集合上的一次动态执行过程，是系统分配资源和调度的基本单位
> >
> > **2️⃣**为何引入进程
> >
> > 1. 多道程序下程序并发执行，破坏了程序的封闭性和可再现性
> > 2. 由于资源共享，各个程序间相互制约，导致了动态性，独立性，异步性
> > 3. 程序是静态的不能反映上述特征，需要引入动态的概念来描述系统和用户的活动，即进程
> >
> > **3️⃣**进程特性
> >
> > 1. 动态性：有生命周期
> > 2. 并发性：并发执行
> > 3. 独立性：独立获得资源，独立运行
> > 4. 异步性：推进速度未知
> > 5. 结构性：由程序段，数据段，PCB组成
> >
> > **4️⃣**进程与程序
> >
> > 1. 进程是程序执行的动态过程，程序是进程运行的静态文本
> > 2. 一个进程可以执行多个程序，同一程序也可能由多个进程同时执行
> > 3. 程序可长期保存，而进程有生命周期
> > 4. 进程是并发实体，程序不是
> >
> > **5️⃣**进程与线程
> >
> > 1. 进程是调度和资源分配的单位，线程是调度单位只拥有极少数必须的资源
> > 2. 进程间可并发，同一进程的线程也可并发
> > 3. 线程切换只涉及少量寄存器，开销小得多
>
> ## <font color='orange'>2.3. 进程的状态与控制</font>
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231104164623020.png" alt="image-20231104164623020" style="zoom:58%;" /> 
> >
> > **1️⃣**<font color='cornflowerblue'>**进入就绪态的进程来自**</font>：<mark>创建，运行，阻塞</mark>
> >
> > **2️⃣**进程控制原理
> >
> > 1. 由OS内核完成，或者说是由OS内核调用原语完成
> > 2. 控制原语：创建/终止、阻塞/唤醒、挂起/激活
>
> ## 2.4. 线程
>
> > **1️⃣**<font color='red'>**线程概念**</font>：是进程中可调度的一个实体，是处理机调度的基本单位
> >
> > **2️⃣**线程特点：只拥有少量必要资源，同一进程的所有线程共享进程的资源
> >
> > **3️⃣**<font color='orange'>**引入线程的目的**</font>：提高系统效率，提高资源利用率，减少进程并发的开销，使得OS并发性更好
> >
> > **4️⃣**多线程模型：多个/一个/多个用户级线程，映射到一个/一个/多个内核级线程
> >
> > **5️⃣**两种线程：
> >
> > 1. 用户线程：存在于用户空间，其创建/撤销/切换，不需要OS支持
> > 2. 内核线程：依赖于内核，其创建/撤销/切换，由内核实现

# 3. CPU调度(=进程调度)

> ## 3.1. 三级调度
>
> > **1️⃣**高级调度/作业调度：选取外存中后备状态的作业→装入内存/IO后建立进程→进程就绪
> >
> > **2️⃣**<font color='red'>**低级调度/进程调度**</font>：按照一定的策略，从就绪队列中选择一个特定进程将CPU分配给它
> >
> > **3️⃣**中级调度/交换调度：把内存中阻塞进程交换到外存对换区(挂起)，必要时再调入内存
> >
> > ➕<font color='red'>**作业调度+进程调度**</font>
> >
> > ![image-20231114223950473](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231114223950473.png)
>
> ## <font color='cornflowerblue'>3.2. CPU调度算法</font>
>
> > **1️⃣**调度算法：
> >
> > 1. 短作业优先：<mark>平均等待最短</mark>
> >
> > 2. <font color='cornflowerblue'>**轮转法**</font>：适合分时系统，<mark>时间片轮转调度不会让进程饥饿</mark>
> >
> >   ➕<font color='cornflowerblue'>**时间片**</font>：分时操作系统分配给每个进程微观上的一段CPU时间
> >
> > 3. 多队列反馈：不同队列不同算法
> >
> > **2️⃣**算法评价的指标
> >
> > 1. 等待时间：进程在就绪队列中等待CPU的时间
> > 2. 周转时间：等待时间+进程执行时间
> > 3. 响应时间：进程请求服务，到首次开始执行的时间差
>
> ## <font color='red'>3.3. 进程的抢占/非抢占调度</font>
>
> > **1️⃣**概念
> >
> > - 可抢占：允许系统中断正在运行的进程以启动更高优先级的进程
> > - 非抢占式：一旦进程开始执行，便会持续运行直到结束或主动放弃CPU
> >
> > **2️⃣**二者所适用的环境：
> >
> > - 可抢占：适用于实时系统，便于中紧急情况的处理
> > - 不可抢占：适用于分时系统，批处理系统
> >
> > **3️⃣**系统开销：
> >
> > <mark>可抢占方式开销更大</mark>，为确保优先级高的进程先执行，需要**频繁进行处理机调度，频繁上下文切换**
>
> ## 3.4. 其他
>
> > **1️⃣** **所有进程都挂起时，系统不会陷入死锁**，进程挂起不代表其不能执行完
> >
> > **2️⃣** 进程调度的时机：进程完成或异常，进程阻塞，时间片用完，被更高优先级进程抢占
> >
> > **4️⃣** 当一个进程从等待状态变为就绪状态时，不一定会发生CPU调度，CPU发生在就绪到执行

# 4. 进程同步

> ## 4.1. 基本概念与名词
>
> > **1️⃣**<font color='orange'>**进程同步/互斥**</font>
> >
> > 1. 同步：异步环境下，互相合作的进程按各自独立的速度向前推进，但在某些确定点上协调工作
> > 2. 互斥：确保多个进程，不会同时访问同一独占型资源
> >
> > **2️⃣**原语：OS中不可分割的最小功能单位，<mark>原语的执行是不能被中断的</mark>
> >
> > **3️⃣**<font color='cornflowerblue'>**信号量**</font>：一个与队列有关的整型变量，其值表示当前可用资源数/等待该资源的进程数，保证某个代码段不被并发调用，其值只能由<mark><font color='cornflowerblue'>**P(申请一个单位资源)/V(释放一个单位资源)**</font></mark>操作改变
>
> ## 4.2. 临界资源&临界区
>
> > **1️⃣**<font color='cornflowerblue'>**临界资源**</font>：一次仅允许一个进程使用的资源，如打印机
> >
> > **2️⃣**<font color='red'>**临界区**</font>：在进程中**访问临界资源**的代码
>
> ## 4.3. 管程
>
> > **1️⃣**概念：**是一个封装了共享资源及其操作的对象，用于控制对共享资源的访问**
> >
> > **2️⃣**<font color='cornflowerblue'>**Note**</font>：管程的互斥是在进程调用其过程时，由OS来保证的

# 5. 死锁

> ## <font color='red'>5.1. 死锁概念</font>
>
> > 1. 系统的一组进程中，每个进程都占用了某些资源
> > 2. 每个又都在无限等待该组中其它进程释放资源
> > 3. 造成他们都无法向前推进
>
> ## <font color='red'>5.2. 死锁的产生</font>
>
> > **1️⃣**根本原因：系统资源不足，进程推进顺序不合理
> >
> > **2️⃣**<font color='red'>**死锁的必要条件**</font>
> >
> > 1. 互斥条件：资源仅为一个进程占有
> >
> > 2. 不可剥夺：资源在未使用完之前，不能被其他进程夺走
> >
> > 3. <mark>保持和等待(请求)：进程已经持有了一些资源，同时还在等待其他进程所持有的资源</mark>
> >
> > 4. 环路等待 
>
> ## <font color='cornflowerblue'>5.3. 动态/静态避免死锁的原理</font>
>
> > **1️⃣**静态预防死锁的原理：
> >
> > - <mark>对进程申请资源**施加限制**</mark>
> > - 进程开始执行前便申请所需的所有资源，仅当系统满足进程申请要求时才分配资源，进程执行时不申请资源
> > - 破坏了死锁的占有和等待条件
> >
> > **2️⃣**动态避免死锁的原理：
> >
> > - <mark>对进程发出的资源申请加以**动态检查**</mark>，根据检查结果决定是否分配资源
> > - 银行家算法的原理
>
> ## <font color='red'>5.4. 银行家算法</font>
>
> > **1️⃣**银行家算法思想：
> >
> > - OS(占有有限资源)当作银行家(占有有限资金)，资源当作周转资金，进程当作借款人
> > - 银行先借出有限资金满足部分借款人，还款后再借给另一批客户
> > - 原则是银行家的资金不能被借完
> >
> > **2️⃣**安全检查测算法的思想
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231021163115979.png" alt="image-20231021163115979" style="zoom: 40%;" /> 

# 6. 内存管理

> ## 6.1. 内部与外部碎片
>
> > **1️⃣**内部碎片：给进程分配的内存略大于进程实际使用的内存， 从而造成其中一部分内存闲置
> >
> > **2️⃣**外部碎片：由于内存空间太小而无法分配给作业的部分内存
>
> ## 6.2. 装入连续内存：分区存储管理
>
> > **1️⃣**单一连续分配：低地址给OS高地址给用户，再其余的浪费掉，有内部碎片
> >
> > **2️⃣**静态多分区分配：OS分区+多个用户分区，用户分区大小在装入前预先确定，每个分区装一个程序
> >
> > **3️⃣**<font color='cornflowerblue'>**动态多分区分配**</font>：作业进入主存时再简历分区，涉及三种分配算法
> >
> > 1. 首次适应：空闲分区链中从头顺序找到第一个大小合适的空闲区，<mark>倾向于找到低地址空闲分区</mark>
> > 2. 最佳适应：空闲分区链中<mark>从小到大</mark>找到第一个大小合适的空闲区
> > 3. 最差适应：最佳适应改成<mark>从大到小</mark>
> >
> > 找到合适空闲区后，劈成两半：和作业一样大的(占用)+剩余部分(空闲)
> >
> > **4️⃣**<font color='cornflowerblue'>**可重定位分区**</font>：允许分区的物理地址在内存中移动，可以移动现有进程在内存的位置来放置新进程
> >
> > 1. 静态重定位在<mark>装入</mark>时完成，动态重定位依靠<mark>重定位寄存器(</mark>提供基址)完成
> > 2. 重定位寄存器：用于存储基址，通过与虚拟地址相加得到逻辑地址
> > 3. 紧凑(碎片拼接)技术：向一个方向移动已分配的作业，碎片就此紧缩在另一端
>
> ## <font color='cornflowerblue'>6.3. 分区的保护</font>
>
> > **1️⃣**界地址寄存器：上界地址寄存器内容 <= 物理地址 <= 下界地址寄存器内容
> >
> > **2️⃣**<font color='cornflowerblue'>基址+限长寄存器法：物理地址-基址寄存器内容 <= 限长寄存器内容</font>
>
> ## 6.4. 对换技术
>
> > **1️⃣**含义：把主存中暂时不能运行的进程调出到外存，再将具备运行条件的进程调入内存
> >
> > **2️⃣**目的：从逻辑上扩充内存空间 从而使整个系统资源利用率提高
> >
> > **3️⃣**分类：整体兑换(进程对换)，部分对换(页面/分段对换)
> >
> > **5️⃣**<font color='cornflowerblue'>**对换技术的代价**</font>：时间(交换操作需要时间)和空间(需要外存的空间)
>
> ## <font color='red'>6.5. 全部页装入离散内存：基本分页</font>
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231114215533343.png" alt="image-20231114215533343" style="zoom: 80%;" /> 
> >
> > 注意
> >
> > 1. 页表起始地址，页表长度这两个内容来自于PCB
> > 2. **<font color='cornflowerblue'>快表</font>**：存放被频繁访问的页面的页表项，提高了内存访问速度
> > 3. PS：多级页表，为页表分配大段连续内存→将页表分页，离散地将各个页表存放到内存块中
>
> ## <font color='red'>6.6. 虚拟存储器</font>
>
> > **1️⃣**理论基础：程序局部性
> >
> > **2️⃣**概念：具有请求调入功能、置换功能，能从逻辑上对内存容量加以扩充的存储器系统
> >
> > **3️⃣**软件支持：建立在<mark>离散分配</mark>基础上，如请求分页，全球分段
> >
> > **4️⃣**硬件支持：一定容量的内存，较大的外存<mark>(且有对换区，这是关键)</mark>，缺页中断机构，地址变换机构
> >
> > **5️⃣**<font color='cornflowerblue'>**虚存的好处(引入原因)**</font>
> >
> > 1. 从逻辑上扩展内存的空间，是的用户层面能使用到更大的内存空间
> > 2. 使得作业部分装入内存便可开启运行，使得内存中可以装入更大的作业，也提高了多道程序的性能
> >
> > **6️⃣**虚存的寻址空间由CPU字长觉醒，虚存的实际大小=min{外存大小，寻址空间}
>
> ## 6.7. 请求分页
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231117000628589.png" alt="image-20231117000628589" style="zoom:50%;" /> 
> >
> > **1️⃣**原理：基本分页基础上，加上请求调页+页面置换，内容如上图
> >
> > **2️⃣**页表新增内容：存在位(是否存在)+访问字段(是否被访问)+修改位(是否被修改)
> >
> > **3️⃣**缺页中断处理程序：完成页面的调入
>
> ## 6.8. 请求分页的页面置换算法
>
> > **1️⃣**最佳置换算法：已知未来页面访问的顺序，淘汰以后不再使用/最迟被使用的页
> >
> > **2️⃣**先进先出
> >
> > **3️⃣**最近最久未使用
> >
> > **4️⃣**CLOCK算法：基于局部性原理，淘汰不被访问的
> >
> > 1. 每页设置访问位=1代表访问过，所有页构成循环链表
> > 2. 指针遍历循环链表，一路上将所有=1的访问位置零，淘汰所有访问位=0的(不被访问就滚)
> >
> > **5️⃣**改进CLOCK：考虑到淘汰未修改的页开销小，所以优先淘汰不被修改的页
> >
> > 1. 增设修改位=1表示被修改过
> > 2. 先试图找(**访问位=0**, **修改位=0**)页替换，若没找到:arrow_down:
> > 3. 再试图找(**访问位=0**, **修改位=1**)页替换，所扫描过之处皆置**访问位=0**
> > 4. 一直找下去一定能找到
>
> ## 6.9. 抖动
>
> > **1️⃣**抖动概念：页面频繁地调入或换出，CPU利用率低下
> >
> > **2️⃣**解决方案：
> >
> > 1. 采用局部置换策略：抖动进程不会去抢别的进程的页，不会导致别的进程也抖动
> > 2. 给进程足够的物理块
> > 3. 控制缺页率
>
> ## 6.10. 其他
>
> > **1️⃣**<font color='cornflowerblue'>**一条指令有可能引发多次缺页中断**</font>，**比如一条指令中两个变量都在外存，而普通中断和指令则一一对应**
> >
> > **2️⃣**<font color='cornflowerblue'>**清理内存指令应该是特权指令**</font>，**<mark>内存清理是指重新分配前释放内存</mark>**，**<mark>特权指令是指只能由OS内核执行的指令</mark>**

# 7. 文件管理

> ## 7.1. 文件与文件管理
>
> > **1️⃣文件**：具有文件名的一组相关信息的集合
> >
> > **2️⃣**文件系统：OS中文件管理有关软件，被管理的文件，文件属性的集合
> >
> > **3️⃣**文件系统的组成：文件集合(储存有关数据)，目录结构(组织并提供关于系统中的所有文件)
> >
> > **4️⃣**<font color='cornflowerblue'>**文件管理的任务**</font>：将逻辑文件映射到磁带或磁盘等物理设备上
> >
> > **5️⃣**文件的使用：用户通过文件系统提供的系统调用来实施对文件的操作
>
> ## 7.2. 文件逻辑结构
>
> > **1️⃣**无结构文件：流式文件
> >
> > **2️⃣**记录式文件
> >
> > 1. 顺序文件：记录定长，顺序存取
> > 2. 索引文件：记录边长，直接存取
> > 3. 索引顺序文件：将顺序文件的记录分组，索引找到组，在组内顺序找到记录
>
> ## 7.3. 文件操作：OPEN和CLOSE
>
> > **1️⃣**引入OPEN/CLOSE的意义：管理文件访问，分配资源，保证数据一致性
> >
> > **2️⃣**OPEN操作
> >
> > 1. 检查路径和文件名的有效性，检车用户圈子按
> > 2. 在文件系统中定位文件
> > 3. 分配必要资源，如内存，文件描述符
> > 4. 更新文件系统的状态信息，如打开文件表
> >
> > **3️⃣**CLOSE操作
> >
> > 1. 确保所有打开文件的修改都已经写回外存
> > 2. 释放打开文件时分配的资源
> > 3. 更新文件系统的状态信息，如修改文件最后访问的时间，从打开文件表中删除改目录项
>
> ## <font color='cornflowerblue'>7.4. 文件物理结构</font>
>
> > **1️⃣**连续分配：顺序访问，可随机存取，但是有外碎片
> >
> > **2️⃣**<font color='cornflowerblue'>**链接分配**</font>：
> >
> > 1. 隐式链接：提高了文件存储空间的利用率，只能顺序存取
> > 2. 显式链接：FAT占据空间，但也只能低效随机存取
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/rojeH6BPNZdimTI.png" alt="image-20231031130544970" style="zoom:60%;" />
> >
> > **3️⃣**索引分配：每个文件一张缩引表，指出给文件的所有物理块号和顺序；可高效随机存取，无外部碎片，文件可动态增长
> >
> > **4️⃣**混合缩引(UNIX)
> >
> > 1. i结点存储文件的管理信息，和文件名一一对应实现了按名存取
> > 2. i结点有13个地址项：直接地址0-9、1次间址10、2 次间址11、3次间址12
>
> ## <font color='orange'>7.5. 空闲存储空间管理</font>
>
> > **1️⃣**空闲表：空闲表的每个表项对应一个空闲区，记录了起始块号+块数，按照首次适应/最佳适应分配
> >
> > **2️⃣**空闲链：所用空闲块组织成一个链表
> >
> > **3️⃣**<font color='cornflowerblue'>**位视图**</font>：图位于外存，图中每一位对应文件存储器中的一个物理块，取值0/1分别代表空闲/占用
> >
> > **4️⃣**成组链接法：
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/GCuqJrZhNBWUycd.png" alt="image-20231101141812714" style="zoom: 50%;" /> 
> >
> > 1. 结构：100空闲块分一组，每组在前一组第一块记录块数+所有块编号，第一组的这两数据记录在超级块中，每组第一块链成链表，组内多块构成堆栈
> > 2. 分配：检查第一组空闲块数，若有空闲块则超级块中空闲块数-1&第一组栈顶块分给文件，以此类推一块块一组组，但注意如果第一组块用完了超级块会指向第二组
> >
> > 3. 回收：
> >    - 若第一组不足100块，则直接把回收的块塞进去，然后超级块中放入该块号&空闲块数+1
> >    - 若第一组已经100块，则**将该块独立建组，然后插入超级块和原来第一组中**，更新超级块和新建组中的空闲块&块号信息
>
> ## 7.6. 目录管理
>
> > **1️⃣**<font color='red'>**目录管理目标**</font>：实现按名存取，提供快速的目录查询方法来加快文件检索速度
> >
> > **2️⃣**<font color='red'>**FCB**</font>：是文件存在的标志，OS通过FCB来管理文件，<mark>记录了如下信息</mark>
> >
> > - 文件结构信息：物理/逻辑结构信息
> > - 文件管理信息：文件名称，大小，长度，属性，建立日期，上次存取日期
> > - 文件存取控制信息：问价主任的权限，同组用户权限，其他用户权限
> >
> > **3️⃣**<font color='red'>**文件目录**</font>：FCB的有序集合，每个FCB叫做一个目录项
> >
> > **4️⃣**如何提高目录检索效率：将文件名，描述信息分开(如UNIX的iNode)；或者用哈希表
> >
> > **5️⃣**目录结构：
> >
> > 1. 单级目录
> > 2. 两级目录：主文件目录，用户文件目录，用户不可建立目录
> > 3. 多级目录：<font color='cornflowerblue'>**当前目录**</font>(OS中用户正在操作的文件夹位置)，绝对路径，相对路径
> >
> > **6️⃣**目录查询：用户给定路径名→OS查询目录→找到对应FCB或索引结点→找到具体文件
>
> ## 7.7. 其他
>
> > **1️⃣**<font color='orange'>**访问文件的方式**</font>：<mark>顺序/连续访问，直接/随机访问</mark>
> >
> > **2️⃣**不同存储介质文件物理结构<mark>**必定不相同**</mark>

# 8. 设备管理

> ## <font color='orange'>8.1. 四种IO控制方式</font>
>
> > **1️⃣**轮询/程序IO
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231117133102794.png" alt="image-20231117133102794" style="zoom:50%;" /> 
> >
> > **2️⃣**中断驱动
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231117133128813.png" alt="image-20231117133128813" style="zoom:50%;" /> 
> >
> > **3️⃣**DMA控制方式
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231117133256257.png" alt="image-20231117133256257" style="zoom:50%;" /> 
> >
> > **4️⃣**通道控制
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231117133323020.png" alt="image-20231117133323020" style="zoom:53%;" /> 
> >
> > **5️⃣**总结
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/3d9bb532c881ba460ecd24e8bb96444.jpg" alt="3d9bb532c881ba460ecd24e8bb96444" style="zoom: 43%;" /> 
>
> ## <font color='cornflowerblue'>8.2. 缓冲管理</font>
>
> > **1️⃣**目的：
> >
> > 1. 缓和 CPU 和 I/O 设备速度不匹配的矛盾
> > 2. 降低CPU中断频率
> > 3. 提高 CPU 和 I/O 设备之间的并行性，从而提高系统的吞吐量和设备的利用率
> >
> > **2️⃣**<font color='cornflowerblue'>**缓冲池**</font>：由多个缓冲区组成，临时存储IO设备读出或写入的数据，调和CPU和I/O设备间速度不匹配问题
>
> ## 8.3. 设备分配
>
> > **1️⃣**含义：按一定的策略分配设备、控制器和通道
> >
> > **2️⃣**<font color='orange'>**设备分配的数据结构**</font>：**系统**设备表SDT，**设备**控制表DCT，**控制器**控制表COCT，**通道**控制表CHCT
> >
> > **3️⃣**<font color='cornflowerblue'>**设备独立性**</font>：
> >
> > 1. 含义：应用程序独立于具体使用的物理设备，它可提高设备分配的**灵活性**和设备的**利用率**
> > 2. 原理：编程时只使用设备的逻辑名，OS执行时将逻辑设备名转化为具体物理设备名，再实施IO
>
> ## 8.4. SPOOLing：假脱机技术
>
> > **1️⃣**<font color='cornflowerblue'>**含义**</font>：
> >
> > 1. 多道程序下，利用一道或两道程序来模拟脱机 I/O 中的外围控制机的功能，以达到脱机I/O目的
> > 2. 由此将一台独占物理设备虚拟为多台逻辑设备，从而使该物理设备可被多个进程共享
> >
> > **2️⃣**SPOOLing组成：磁盘上的输入/输出井，内存的输入/输出缓冲区，输入进程和输出进程
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20231117135611127.png" alt="image-20231117135611127" style="zoom: 67%;" /> 
> >
> > **3️⃣** <font color='cornflowerblue'>**虚拟设备**</font>：<mark>通过虚拟技术，将一台独占设备虚拟成多台逻辑设备，供多个用户进程同时使用</mark>
> >
> > **4️⃣**<font color='cornflowerblue'>**虚拟打印机实现的原理**</font>
> >
> > - 进程要求打印输出时，OS分给进程一块磁盘输出井区域
> > - 进程的输出数据快速存入输出井某区域，输出井该区域此时相当于一台虚拟打印机
> > - 各进程的打印输出数据在输出井形成一个输出队列
> > - 由SPOOLing的缓输出程序，依次将输出队列中的数据实际地打印输出

# 9. 磁盘管理

> **1️⃣**<font color='cornflowerblue'>**磁盘调度**</font>：
>
> 1. 含义：OS管理硬盘驱动器读写请求的一种技术
> 2. 目的：优化磁盘访问效率，减少读写头移动时间，平衡请求的响应时间
> 3. 算法：FCFS，SSTF(最短寻找时间优先)，SCAN，C-SCAN，LOOK，C-LOOK
>
> **2️⃣**<font color='cornflowerblue'>**磁盘调度优化的目标**</font>：使磁盘的<mark>平均寻道时间</mark>最短
>
> **3️⃣**<font color='orange'>**磁盘访问时间**</font>：<mark>寻道时间，旋转等待时间，传输时间</mark>
>
> **4️⃣**提高磁盘IO的方法：磁盘高速缓存，提前读，延迟写，优化物理块布局，虚拟盘
