[TOC]

# XJTUSE计算机图形学总结笔记

## 第一章 绪论

### 研究内容

#### 图形系统的主要任务

利用计算机来显示、生成和处理图形。

> 建模(Modeling)
>
> 几何处理(Geometric Processing)
>
> 光栅化(Rasterization)：三维物体二维表示
>
> 片元处理(Fragment Processing)：对逐个像素进行处理

#### 计算机图形学的研究对象

> 能在人的视觉系统中产生视觉印象的客观对象
>
> 包括自然景物、拍摄到的图片、用数学方法描述的图形等等

#### 图形的要素<mark>【填空题】</mark>

> **几何要素**：刻画对象的轮廓、形状等
>
> **非几何要素**：刻画对象的颜色、材质等

#### 图形图像表示法

:one: 点阵表示：点阵图

枚举出图形中所有的点,简称为**图像(Image)**。

![image-20220105211929495](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220105211940238.png)

:two: 参数表示：矢量图

由图形的**形状参数**(方程或分析表达式的系数,线段的端点坐标等)+属性参数(颜色、线型等)来表示,简称为**图形(Graphics)。**


<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220105212032188.png" alt="image-20220105212032188" style="zoom:33%;" />

> 图像纯指计算机内以位图(Bitmap)形式存在的灰度信息。
>
> 图形含有几何属性，更强调场景的几何表示，是由场景的几何模型和景物的物理属性共同组成的。
>
> > 一类是基于线条信息表示的，如工程图、等高线地图、曲面的线框图等；
> >
> > 另一类是真实感图形（明暗图）

#### 图形研究例子

**图形的输入**：如何开发利用图形输入设备及软件将图形输入到计算机中去，以便作各种处理

**图形的处理**：

几何变换 平移,缩放,旋转……

投影变换 平行投影,透视投影 

运算（集合运算）交,并,差… 着色 形变……

**图形的输出**: 将图形特定的表示形式转换成图形输出系统便于接受的表示形式，并将图形在显示屏或打印机等输出设备上输出。 

#### 相关学科

![image-20220105213206761](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220105213206761.png)

### 发展历史

#### 历史追溯

1950年，MIT，**旋风一号**(Whirlwind I)计算机图形显示器，类似于示波器的CRT来显示简单图形

>   <mark>**CRT的出现为计算机生成和显示图形提供了可能**</mark>

50年代末期，MIT林肯实验室，在Whirlwind上开发SAGE空中防御系统，通过光笔在屏幕上指点与系统交互

> <mark>标志着交互式图形技术的诞生</mark>

1962年MIT林肯室验室Ivan.E.Sutherland的博士论文：Sketchpad：一个人机通信的图形系统。该系统确定了交互图形学作为一个学科分支

60年代：MIT、Bell Lab、 通用汽车公司、剑桥大学 开展大规模的研究

70年代进入技术实用化

80年代初，图形学依然是较小的学科，原因是图形硬件设备十分昂贵，且基于图形的应用相对较少

80年代中期以来，超大规模集成电路的发展，为图形学的飞速发展奠定了基础

#### 硬件发展

**图形显示器的发展**

![image-20220105215955956](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220105215955956.png)

**图形输入设备的发展**

> 第一阶段：控制开关、穿孔纸等等
>
> 第二阶段：键盘
>
> 第三阶段：二维定位设备，如鼠标、光笔、图形输入板、触摸屏等等，语音
>
> 第四阶段：三维输入设备（如空间球、数据手套、数据衣），用户的手势、表情等等
>
> 第五阶段：用户的思维

**软件发展及软件标准**

三种类型的计算机图形软件系统：

:one: 用某种语言写成的子程序包

如:GKS (Graphics Kernel System) ,OpenGL

**便于移植和推广、但执行速度相对较慢，效率低**

:two: 扩充计算机语言，使其具有图形生成和处理功能

​    如：Turbo Pascal、Turbo C，AutoLisp等。 

**简练、紧凑、执行速度快，但不可移植**

:three: 专用图形系统：效率高，但系统开发量大，可移植性差

通用标准：GKS (第一个官方标准，1977)、PHIGS

事实标准：DirectX (MS)、OpenGL(SGI)、Adobe公司Postscript

#### 计算机图形学的应用

早期的计算机动画：**基于“关键帧”的动画**

> 基于特征的动画
>
> 基于变形物体的动画

最新：基于物理模型的计算机动画生成方法

> 运用弹性和流体力学的物理方程进行计算，力求
>
> 使动画过程最体现出最符合真实世界的运动规律：关节动画与人体动画

![image-20220105222053771](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220105222053771.png)

### 当前研究动态

> **真实感图形实时绘制**
>
> **自然景物模拟**
>
> **造型技术**
>
> **几何处理**

**图形学的杂志和会议**

> **会议：**
>
> > Siggraph， Eurograph，Asiagraph
> > IEEE Virtual Reality
> > IEEE Visualization Conference
>
> **杂志** 
>
> > ACM Transaction on Graphics
> > IEEE Computer Graphics and Application
> > IEEE Visualization and Computer Graphics
> > IEEE T. on Visualization and Computer Graphics
> > Graphical Models 
> > Computer Graphics Forum
> > The Visual Computer 

### 图形设备

#### 图形输出设备

图形输出包括图形的**显示**和**图形**的绘制

##### 图形显示

###### 彩色CRT显示器

CRT（CRT Cathode－Ray Tube，阴极射线管）组成：

> 电子枪、聚焦系统、加速系统、荧光屏磁偏转系统

工作原理： 荧光物质在高速电子的轰击下会发生电子跃迁（低能态到高能态），高能态很不稳定，返回低能态，发出荧光。

刷新频率

> 刷新一次是指电子束从上到下扫描一次的过程；刷新频率高到一定值后，图象才能稳定显示
>
> 隔行扫描与逐行扫描

###### 球面显示器与柱面显示器

球面管：**荫罩式结构，**呈略微凸起的球面状；

柱面管：**荫栅式结构，**在水平方向略微凸起，在垂直方向上却是笔直的，呈圆柱状（色彩鲜艳）

###### LCD(Liquid Crystal Display)显示器

使用**液晶**：液晶受到电压的影响时，改变物理性质而发生形变，通过它的光的折射角度就会发生变化

###### LED（Light Emitting Diode）显示器

点亮(不同电压，不同灰度)，低电压维持。由细小氖气灯泡矩阵组成，由于氖泡有两种状态：开启、关闭，且状态可保持。高电压

![image-20220105225233233](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220105225233233.png)

有记忆功能，无需“刷新”、可动态修改图形

##### 图形绘制

###### 打印机【重点】

:one: **针式打印机**：依靠打印针击打色带在打印介质上形成色点的组合来实现规定字符和图像（24针）

控制驱动电路：

> 微处理器：处理打印命令，寻址，读取编码
>
> ROM存储器：存储管理程序、字符库和汉字库
>
> RAM存储器：需要打印的内容

:two: **喷墨打印机**：打印头上的喷口将墨滴按特定的方式喷到打印介质上形成文字或图像, 分为**热汽泡式**和**压电式**

> 打印质量较好、噪音低、较易实现低成本彩色打印等优点，适合于家用打印机领域
>
> **连续喷墨**(喷绘机)、**随机喷墨**（用的比较多）
>
> 三色混合所产生的黑色是不纯的，为了产生真正的黑色需加入了第四种颜色的墨水-K。 

:three: **激光打印机**：采用电子成像技术，激光束扫描感光 鼓，将墨粉吸附到感光区域，再将墨粉转印到打印介质上，最后通过加热装置将墨粉熔化固定到打印介质上

> 光、机、电一体化的精密设备，结构比较复杂
>
> 电荷“同性相吸”的现像被用作一种“临时性的粘合剂”：墨粉带正电荷，纸张和硒鼓带负电，而且纸张的电荷更大
>
> 核心：电子成像，融合了影像学与电子学的原理和技术以生成图像，核心部件是可以感光的感光鼓
>
> <img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220105232435618.png" alt="image-20220105232435618" style="zoom: 80%;" />

#### 图形处理器

图形系统结构的重要元件，连接计算机和显示终端的纽带

早期只包含简单的存储器和帧缓冲区，起了图形的存储和传递作用，操作须有CPU来控制

当前不仅存储图形，且能完成大部分图形函数，专业的图形卡已具有很强的3D处理能力，减轻了CPU的负担，提高了显示质量和显示速度

![image-20220106101700070](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106101700070.png)

> 显示主芯片（ GPU ）：对系统输入的视频信息进行构建和渲染
>
> 显示缓存：存储将要显示的图形信息及保存图形运算的中间数据；大小和速度直接影响着主芯片性能的发挥
>
> <img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106101915126.png" alt="image-20220106101915126" style="zoom: 80%;" />
>
> 数字模拟转换器：把二进制的数字转换成为和显示器相适应的模拟信号

#### 图形输入设备

最常用最基本的计算机输入设备——**键盘和鼠标**

跟踪球和空间球：根据球在不同方向受到的推或拉的压力来实现定位和选择

数据手套：通过传感器和天线来获得和发送手指的位置和方向的信息

## 第二章 光栅图形学

### 基本概念

扫描转换（光栅化）：确定最佳逼近图形的像素几何，并用指定属性写像素的过程

区域填充：光栅化过程中确定区域对应的像素集，并用指定的属性或图案显示

裁减：确定一个图形的哪部分在窗口内显示

<font color="red">**走样**</font>：**由于显示器的空间分辨率有限，因像素逼近误差，使所画图形产生畸变（台阶、锯齿）的现象**

**<font color="red">反走样</font>：减少或消除走样的技术：硬件、软件的方法**

隐藏部分：当不透光的物体遮挡了来自某些物体部分的光线，使其无法到达观察者

消隐：把隐藏的部分从图中删除，消除歧义性

### 直线段的扫描转换算法

**直线的扫描转换**: 确定最佳逼近于直线的一组象素，且按扫描线顺序，对这些象素进行写操作

#### 数值微分(DDA)法

已知过端点$P_0(x_0,y_0),P_1(x_1,y_1)$的直线段L：$y=kx+b$直线斜率为 
$$
k=\frac{y_1-y_0}{x_1-x_0}
$$
从$x$的左端点$x_0$开始，向$x$右端点步进。步长=1(个象素)，计算相应的y坐标$y=kx+b$；取象素点(x, round(y))  作为当前点的坐标

> <mark>方法直观，效率低</mark>
>
> 作为最底层的光栅图形算法，在通常的CAD/图形系统中，会被大量应用
>
> 由此出发，导致增量算法的思想

##### 增量算法

在一个迭代算法中，每一步的x、y值是用前一步的值加上一个增量来获得
$$
计算y_{i+1}=kx_{i+1}+b=kx_i+b+k\Delta x=y_i+k\Delta x\\
当\Delta x=1时: y_{i+1}=y_i+k
$$
当x每递增1，y递增k(即直线斜率)；

> 由此注意上述分析的算法仅适用于|k| ≤1的情形。在这种情况下，x每增加1，y最多增加1
>
> 当 |k| >1时，必须把x，y位置互换

![image-20220106105953735](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106105953735.png)

```c
void DDALine(int x0,int y0,int x1,int y1,int color)     
{     
      int x；							
	float dx, dy, y, k;						
	dx= x1-x0, dy=y1-y0;					   
	k=dy/dx, y=y0;	 					   
	for (x=x0; x<=x1, x++)					   
	{drawpixel (x, int(y+0.5), color);		   
	   y=y+k;
     }
}
```

在此算法中，y、k必须是float，且每一步都必须对y进行舍入取整，**不利于硬件实现**

#### 中点画线法[重点]

将一个加法改为一个整数加法

**基本思想**

对于理想直线$L(p_0(x_0,y_0),p_1(x_1,y_1))$,采用直线$F(x,y)=ax+by+c=0$表示。其中$a=y_0-y_1, b=x_1-x_0, c=x_0y_1-x_1y_0$

当前象素点为$(x_p, y_p) $，下一个象素点为$P_1$ 或$P_2$ 。设$M=(x_p+1, y_p+0.5)$为$P_1$ 与$P_2$之中点，Q为理想直线与$x=x_p+1$垂线的交点。将Q与M的y坐标进行比较。

> 当M在Q的下方，则$P_2$应为下一个象素点
>
> M在Q的上方，应取$P_1$为下一点
>
> <img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106110837433.png" alt="image-20220106110837433" style="zoom:67%;" />

<font color="red">**构造判别式**</font>
$$
d=F(M)=F(x_p+1,y_p+0.5)=a(x_p+1)+b(y_p+0.5)+c\\

其中a=y_0-y_1, b=x_1-x_0, c=x_0y_1-x_1y_0
$$

> 当d<0，M在L(Q点)下方，取右上方P2为下一个象素
>
> 当d>0，M在L(Q点)上方，取右下方P1为下一个象素
>
> 当d=0，选P1或P2均可，约定取P1为下一个象素

**计算量**：每一个象素的是四个加法，两个乘法。采用增量算法如下：

:label: 若当前象素处于$d\ge0$情况，则取正右方象素$P_1 (x_p+1, y_p)$, 要判下一个象素位置，应计算

 $  d_1=F(x_p+2, y_p+0.5)=a(x_p+2)+b(y_p+0.5)=d+a$； **增量为a**

:label: 若$d<0$时，则取右上方象素$P_2 (x_p+1, y_p+1)$。要判断下一象素，则要计算

 $ d_2= F(x_p+2, y_p+1.5)=a(x_p+2)+b(y_p+1.5)+c=d+a+b$；**增量为a＋b**

即

> $d\ge 0\rarr d+a$
>
> $d\le 0\rarr d+a+b$

**进一步改进，实现整数运算**

画线从$(x_0, y_0)$开始，$F(x_0,y_0)=0$ ,d的初值
$$
d_0=F(x_0+1, y_0+0.5)=F(x_0, y_0)+a+0.5b =a+0.5b\\

a=y_0-y_1, b=x_1-x_0
$$
可以用2d代替d来摆脱小数，提高效率。

令 $d_0=2a+b, d_1=2a, d_2=2a+2b$,我们有如下算法 。

```c
void Midpoint Line (int x0, int y0, int x1, int y1, int color) {
	int a, b, d1, d2, d, x, y;
	a = y0 - y1, b = x1 - x0, d = 2 * a + b;
	d1 = 2 * a, d2 = 2 * (a + b);
	x = x0, y = y0;
	drawpixel(x, y, color);
	while (x < x1) {
		if (d < 0)       {
			x++, y++, d += d2;//取右上方
		} else       {
			x++, d += d1;//取右方
		}
		drawpixel (x, y, color);
	}  /* while */
} /* mid PointLine */
```

:label: d只影响判断取哪一个点，并不影响坐标本身的值，所以乘上2不影响直线

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106115521255.png" alt="image-20220106115521255" style="zoom:80%;" />

#### Bresenham算法[重点 很有可能会考]

**基本思想**

–DDA算法采用点斜式，中点法采用隐式表示。

–中点法可以有整数算法。还有其它整数算法吗？

–过各行各列象素中心构造虚拟网格线：按直线从起点到终点顺序计算直线与各垂直网格线的交点，根据误差项符号确定该列象素中与此交点最近的象素

![image-20220106115900576](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106115900576.png)

设直线方程为$y=kx+b\ 则有y_{i+1}=y_i+k(x_{i+1}-x_i)=y_i+k$，其中k=dy/dx。 因为直线的起始点在象素中心，所以误差项d的初值$d_0＝0$

X下标每增加1，d的值相应递增直线的斜率值k，即d＝d＋k。一旦d≥0.5，就把它减去1

> :one: 当d≥0.5时，最接近于当前象素的右上方象素$(x_{i+1},y_{i+1})$
>
> :two: 而当d<0.5时，更接近于右方象素$(x_{i+1},y_i)$。

为方便计算，令e＝d-0.5，e的初值为-0.5，增量为k。

> :one: 当e≥0时，取当前象素$(x_i,y_i)$的右上方象素$(x_{i+1},y_{i+1})$
>
> :two: 而当e<0时，更接近于右方象素$(x_{i+1},y_i)$。

```c
void Bresenhamline (int x0, int y0, int x1, int y1, int color) {
	int x, y, dx, dy;
	float k, e;
	dx = x1 - x0, dy = y1 - y0, k = dy / dx;
	e = -0.5, x = x0, y = y0;
	for (i = 0; i <= dx; i++) {
		drawpixel (x, y, color);
		x = x + 1，e = e + k;
		if (e >= 0) {
			y++, e = e - 1;
		}
	}
}
```

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106160219331.png" alt="image-20220106160219331" style="zoom:60%;" />

可以改用整数以避免除法。由于算法中只用到误差项的符号，因此可作如下替换$e'=2\times e\times dx$， e的初值为-0.5

```c
void Bresenhamline (int x0, int y0, int x1, int y1, int color) {
	int x, y, dx, dy;
	float k, e;
	dx = x1 - x0, dy = y1 - y0, e = -dx;
	x = x0, y = y0;
	for (i = 0; i <= dx; i++) {
		drawpixel (x, y, color);
		x = x++，e = e + 2 * dy;
		if (e ? 0)   {
			y++, e = e - 2 * dx;
		}
	}
}
```

#### 总结

:label: DDA方法：根据直线方程 X→Y；

:label: 其它两种的原理：0<K<1时，下一像素只可能是当前像素的右点或右上点

:label: 如何决定取右点或右上点？构造判别式（二者区别）

> –中点算法：根据直线正负划分性，将中点坐标代入方程得到判别式
>
> –Bresenham算法：误差项d->e
>
> ![image-20220106160849896](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106160849896.png)

### 圆弧的扫描转换算法

**圆的特征**：八对称性。只要扫描转换八分之一圆弧，就可以求出整个圆弧的象素集

```c
void CirclePoints(int x, int y, int color) {
	drawpixel(x, y, color);
	drawpixel(y, x, color);
	drawpixel(-x, y, color);
	drawpixel(-y, x, color);
	drawpixel(x, -y, color);
	drawpixel(y, -x, color);
	drawpixel(-x, -y, color);
	drawpixel(-y, -x, color);
}
```

![image-20220106161302317](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106161302317.png)

以圆心在原点、半径R为整数的圆为例，讨论圆的生成算法。假设圆的方程为：$ X^2 + Y^2 = R^2$

#### 圆弧扫描算法

$Y=\pm \sqrt{R^2-X^2}$

在一定范围内，每给定 X值，可得一Y值

> –缺点：浮点运算，开方，取整，不均匀。

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106161600997.png" alt="image-20220106161600997" style="zoom:50%;float:left" />

#### 角度DDA法

$$
x_n+1 =x_n + dx\qquad y_n+1 =y_n + dy\\

x = x_0 + Rcos\theta\qquad y = y0 + Rsin\theta\\

dx =- Rsin\theta d\theta\qquad dy = Rcos\theta d\theta\\

  x_{n+1} = x_n + dx = x_n - Rsin\theta d\theta =x_n - (y_n - y_0 )d\theta\\

  y_{n+1} = y_n + dy = y_n + Rcos\theta d\theta =y_n + (x_n - x_0 )d\theta\\
$$

确定x,y的初值及dq值后，即可以增量方式获得圆周上的坐标，然后取整可得象素坐标。

但要采用浮点运算、乘法运算、取整运算。

#### 中点画圆法

考虑中心在原点，半径为R的第二个8分圆，构造函数$F(x,y)=x^2+y^2-R^2$

构造**判别式（圆方程）**
$$
d=F(M)=F（x_p+1,y_p-0.5）=(x_p+1)^2+(y_p-0.5)^2-R	^2
$$
<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106162743077.png" alt="image-20220106162743077" style="zoom:50%;" />

若 d<0, 则取P1为下一象素，而且再下一象素的判别式为
$$
d_1=F(P_1)=F（x_p+2,y_p-0.5）=(x_p+2)^2+(y_p-0.5)^2-R	^2=d+2x_p+3
$$
 若d>=0, 则应取P2为下一象素，而且下一象素的判别式为
$$
d_2=F(P_2)=F（x_p+2,y_p-1.5）=(x_p+2)^2+(y_p-0.5)^2-R	^2=d+2(x_p-y_p)+5
$$
 第一个象素是（0,R），判别式d的初始值为
$$
d_0=F(1,R-0.5)=1.25-R
$$
<font color="red">**优化过程**</font>

:label: 有浮点数，用e=d-0.25代替：

:label: 初始值：$d_0=1.25–R 对应于e_0=1-R$

:label: 判别式：d<0对应于e<-0.25(因为e的初值e0为整数，运算过程中的增量$2(x_p-y_p)+5或2x_p+3$也为整数，故e**始终为整数**，**所以e<-0.25 等价于e<0**

经优化，程序不存在浮点数

```c
void MidPointCircle(int r, int color) {
	int x, y, d;
	x = 0;
	y = r;
	e = 1 - r;                    // 初值e=1-r
	Circlepoints (x, y, color);         // 画八分对称性的其他点
	while (x <= y) {                        // 画到直线x=y结束
		if (e < 0) e += 2 * x + 3;        // 取右侧点
		else {
			e += 2 * (x - y) + 5;    // 取右下点
			y--;
		}
		x++;
		Circlepoints (x, y, color);       // 画八分对称性的其他点
	}
}
```

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106163457914.png" alt="image-20220106163457914" style="zoom:67%;" />

### 多边形的扫描转换与区域填充

多边形两种重要的表示方法：

> **顶点表示**：用多边形的顶点序列来表示
>
> >  直观，占内存少，便于几何变换，不能用于面着色
>
> **点阵表示**：用位于多边形内部的像素几何刻画
>
> >  便于帧缓冲器表示图形且是面着色所需的多边形表示形式

多边形的扫描转换:把多边形的**顶点表示转换为点阵表示**

出于简化的目的，这里讨论的多边形都是凸多边形

#### 扫描线算法【需要完全掌握】

##### 基本思想

按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的象素，即完成填充工作

对于一条扫描线填充过程可以分为四个步骤：求交、排序、配对、填色

![image-20220106164409919](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106164409919.png)

##### 数据结构【要掌握】

:label: **活性边表(AET)**：把**与当前扫描线相交的边称为活性**边，并把它们按与扫描线交点x坐标递增的顺序存放在一个链表中，**结点内容**

>  x：当前扫描线与边的交点坐标；
>
>  △x：从当前扫描线到下一条扫描线间x的增量(边的斜率)
>
>  $y_{max}$：该边所交的最高扫描线号$y_{max}$。

![image-20220106164616084](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106164616084.png)

:label: **新边表（NET）**：需为每条扫描线建立一个新边表，存放在该扫描线第一次出现的边。若某边的较低端点为ymin，则该边就放在扫描线ymin的新边表中:

![image-20220106165036944](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106165036944.png)

假定当前扫描线与多边形某一条边的交点的X坐标为x，则下一条扫描线与该边的交点不要重计算，只要加一个增量△x。

设该边的直线方程为：ax+by+c=0；$\Delta x=\frac{-b}{a}$

##### 交点的取舍

:one: 如扫描线与多边形相交的边分别处于扫描线的两侧，则计一个交点，如P5 , P6。

:two: 如扫描线与多边形相交的边分处扫描线同侧，且yi<yi+1, yi<yi-1,则计两个交点,如P2 ；如yi>yi+1, yi>yi-1,则计0个交点,如P1 

:three: 如扫描线与多边形边界重合，则计一个交点,如边P3P4。 

只需检查顶点的两条边的另外两个端点的y值。按这两个y值中大于交点y值的个数是0,1,2来决定。

##### 算法过程

:one:创建新边表NET；

:two: 把新边表NET［i］中的边结点，用插入排序法插入活性边表

​    AET，使之按X坐标递增顺序排序；

:three: 遍历AET表，把配对交点之间的区间(左闭右开)上的各象素(X，Y)，用drawpixel(x,y,color)**改写象素颜色值**；

:four: 遍历AET表，把Ymax=i的结点从AET表中**删除**，并把**Ymax＞i** 的结点的**X值递增△X**；

:five: 重复各扫描线。

##### 示例

点按照逆时针来构成边

![image-20220106170627889](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106170627889.png)

![image-20220106170753485](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106170753485.png)

![image-20220106170804348](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106170804348.png)

![image-20220106170814187](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106170814187.png)

**优点**：

> 对每个像素只访问一次
>
> 与设备无关

**缺点**：

> 数据结构复杂
>
> 只适合软件实现

#### 边界标志算法【了解】

##### 基本思想

–帧缓冲器中对多边形的每条边进行直线扫描转换，亦即对多边形边界所经过的象素打上**标志**，然后再采用和扫描线算法类似的方法将位于多边形内的各个区段着上所需颜色

##### 实现步骤

:one: 扫描线依从左到右顺序访问该扫描线上的像素

:two: 使用一个布尔量inside来指示当前点是否在多边形内的状态:初值为假，访问到边界像素时，取反

:three: 对于被访问的像素，如inside为真，则填充颜色

```c
void edgemark_fill(polydef, color)
多边形定义  polydef；   int color;
{
	对多边形polydef每条边进行直线扫描转换；
	inside = FALSE;
	for (每条与多边形polydef相交的扫描线y )
		for (扫描线上每个象素x ) {
			if (象素 x 被打上边标志)
				inside = ! (inside);
			if (inside！ = FALSE)
				drawpixel (x, y, color);
			else drawpixel (x, y, background);
		}
}
```

–用软件实现时，扫描线算法与边界标志算法的执行速度几乎相同

–由于边界标志算法不必建立维护边表以及对它进行排序，所**更适合硬件实现**，其执行速度比有序边表算法快一至两个数量级

#### 区域填充算法【了解】

区域：已表示成点阵形式的填充图形，象素集

区域可采用两种表示形式：

:one: 内点表示

> 枚举出区域内部的所有像素
>
> 内部的所有像素着同一个颜色
>
> ![image-20220106173218710](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106173218710.png)

:two: 边界表示

> 枚举出边界上所有的像素
>
> 边界上的所有像素着同一颜色
>
> ![image-20220106173225468](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106173225468.png)

区域填充:先将区域的一点赋予指定的颜色，然后将该颜色扩展到整个区域的过程

**区域填充算法要求区域是连通的**

**4连通**：两个像素点是上下或左右相连

**8连通**：两个像素点是上下或左右相连的，或者是对角线方向相连的

![image-20220106173424645](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106173424645.png)

默认是四连通

##### 种子填充算法

**种子填充算法**：设G为一内点表示的区域，(x,y)为区域内一点，old_color为G的原色。现取(x,y)为种子点对区域G进行填充：种子象素入栈，当栈非空时，执行如下三步操作：

:one: 栈顶象素出栈

:two: 将**出栈象素置成*new*_*color*** 

:three: 按**右、上、左、下**的顺序检查与出栈象素相邻的四个象素，若其中某个象素在边界内且未置成*new*_*color* ，则把该象素入栈

![image-20220106173701989](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106173701989.png)

同一个像素可能入栈多次

**解决方法**：扫描线填充算法：一次填充种子所在行；适用于边界表示的4连通区域

##### 扫描线算法

–首先填充种子点所在扫描线上的位于给定区域的一个区段

–然后确定与这一区段相连通的上、下两条扫描线上位于给定区域内的区段，并依次保存下来

–反复这个过程，直到填充结束

### 字符

**字符**：指数字、字母、汉字等符号

> 计算机中由一个数字编码唯一标识
>
> 国际上最流行的字符集： ASCII码，用7位二进制数进行编码表示128个字符
>
> 汉字编码的标准字符集：GB2312－80，分为94个区，94个位，每个符号由一个区码和一个位码共同标识
>
> 采用字节的最高位来标识：最高位为0表示ASCII码；最高位为1表示表示汉字编码

**字库**：为了在显示器等输出设备上输出字符，系统中必须装备有相应的字库

矢量型和点阵型

![image-20220106174505062](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106174505062.png)

#### 点阵字符

每个字符由一个位图表示，用矩阵（字符掩膜）表示

显示：从字库中将它的位图检索出来；将检索到的位图写到帧缓冲器中

字库的存储空间十分庞大，压缩技术：**轮廓字形法**

采用直线或Bezier曲线的集合描述字符的轮廓线，形成封闭的平面区域，外加控制信息构成字符的压缩数据

压缩比大，且能保证字符质量

#### 矢量字符

矢量字符记录字符的笔画信息，具有存储空间小，美观、变换方便等优点

只需对其几何图素进行变换即可实现字符的旋转、放大、缩小等几何变换

**显示**：从字库中检索字符信息；取出端点坐标，对其进行适当的几何变换，再显示字符

### 裁剪

用计算机处理图形信息时，计算机内部存储的图形往往比较大，而屏幕显示的只是一部分。

**裁剪**：确定图形中哪些部分落在**显示区(剪裁窗口)**之内，以便只显示落在显示区内的那部分图形

**先裁剪再扫描**

分类：直线段裁，多边形裁剪。

![image-20220106203232713](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106203232713.png)

•图形裁剪中最基本的问题：

–假设窗口为矩形，其左下角坐标为$(x_L,y_B)$，右上角坐标为$(x_R,y_T)$，对于给定点P(x,y),则P点在窗口内的条件是要满足下列不等式：
$$
xL\le x\le xR\ 且\ yB\le y \le yT
$$
否则，P点就在窗口外。

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106203140325.png" alt="image-20220106203140325" style="zoom:67%;" />

#### 直线段裁剪

##### 直接求交算法

直线与窗口边都写成参数形式，求参数值

将线段P0P1和矩形窗口的下边写成参数形式

![image-20220106203750851](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106203750851.png)

P0P1与窗口的下边的交点满足

![image-20220106203809620](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106203809620.png)

–求解得到交点对应参数对$(t_{line,}t_{edge})$，只有当它们落在[0,1]区间, $(t_{line,}t_{edge})$对应交点有效。

![image-20220106204208551](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106204208551.png)

•**裁剪线段与窗口的关系**: 线段完全可见、显然不可见、其它

##### Cohen-Sutherland裁剪

###### 基本思想

对于每条线段P1P2分为三种情况处理:

:one: 若P1P2完全在窗口内，则显示该线段P1P2简称“取”之；

:two: 若P1P2明显在窗口外，则丢弃该线段，简称“弃”之；

:three: 若线段不满足“取”或 “弃”的条件，则在交点处把线段分为两段。其中一段完全在窗口外，可弃之。然后对另一段重复上述处理。

为快速判断，采用如下编码方法：

> 将裁减窗口边线两边沿长，得到九个区域，每一个区域都用一个四位二进制数标识，直线的端点都按其所处区域赋予相应的区域码，用来标识出端点相对于裁剪矩形边界的位置。

![image-20220106204447458](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106204447458.png)

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106204530141.png" alt="image-20220106204530141" style="zoom:67%;" />

###### 法则

:one: 若P1P2完全在窗口内code1=0,且code2=0,则“取”；

:two: 若P1P2明显在窗口外code1&code2≠0，则“弃” ；(按位取与)

:three: 在交点处把线段分为两段。其中一段完全在窗口外，可弃之。然后对另一段重复上述处理

•如何判定应该与窗口的哪条边求交呢：编码中对应位为1的边.**上下右左**

```c
if (LEFT & code != 0) {
	x = XL;
	y = y1 + (y2 - y1) * (XL - x1) / (x2 - x1);
} else if (RIGHT & code != 0) {
	x = XR;
	y = y1 + (y2 - y1) * (XR - x1) / (x2 - x1);
} else if (BOTTOM & code != 0) {
	y = YB;
	x = x1 + (x2 - x1) * (YB - y1) / (y2 - y1);
} else if (TOP & code != 0) {
	y = YT;
	x = x1 + (x2 - x1) * (YT - y1) / (y2 - y1);
}
```

**特点**：用编码方法可快速判断线段--完全可见和显然不可见。

特别适用二种场合：

> 大窗口场合(大多数对象都在窗口中)；
>
> 窗口特别小的场合(如光标拾取图形时，光标看作小的裁剪窗口。)

•最坏情形，线段求交四次，

###### 优点

> 简单，易于实现。在这个算法中求交点是很重要的，它决定了算法的速度。
>
> 编码方法可快速判断线段的完全可见和显然不可见。

###### 缺点

> 对于其他形状的窗口未必同样有效；
>
> 全部摒弃的判断只适合于那些仅在 窗口同一侧的线段。

##### 中点分割裁剪算法

对线段端点进行编码，并把线段与窗口的关系分为：

> 前两种，进行一样的处理；
>
> 第三种，用中点分割的方法求线段与窗口的交点。

–从P0点出发找出离P0最近的可见点，从P1点出发找出离P1最近可见点：两个可见点的连线就是原线段的可见部分。

![image-20220106210153895](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106210153895.png)

**二分寻找最近点**

###### 算法特点

> 分辩率为$2^N*2^N$的显示器，上述二分过程至多进行N次；
>
> 主要过程只用到加法和除法运算，适合硬件实现
>
> 适合于并行计算

##### 梁友栋－Barsky算法

###### 特点

> 把**二维裁剪问题化成二次一维裁剪**问题，且把裁剪问题转化为解一组不等式的问题；
>
> 改善了Cohen-Sutherland 的编码算法中全部摒弃的判断只适合于那些仅在窗口同一侧线段的不足。

##### Nicholls-Lee-Nicholl算法[考试不作要求]

通过在剪裁窗口周围创建多个区域，在求交点之前进行更多的区域测试，从而减少求交计算。

**算法步骤**

:one: 从P1点向窗口的四个顶角点发出射线，这四条射线和窗口的四条边所在的直线一起将二维平面划分为更多的小区域；

:two: 确定P2相对于的P1位置；

:three: 计算直线段P1P2和窗口边界的交点

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106211059668.png" alt="image-20220106211059668" style="zoom:67%;" />

•端点与裁剪窗口的关系：

–端点P1相对于裁剪窗口有九个可能的区域位置，只需考虑其中三个区域，其它几个区域可以利用简单变换其变换到所考虑的三个区域中的任一个中。

![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106211243716.png)

![image-20220106211548653](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106211548653.png)

##### 总结

:one: 直接求交法原理简单，效率低；

:two: Cohen-Sutherland与中点法在区域码测试阶段能以位运算方式高效率地进行，因而当大多数线段能够简单的取舍时，效率较好。**中点分割线法适合于用硬件实现；**

:three: 梁友栋—Barskey算法只能应用于矩形窗口的情形，但其效率比前两者要高，这是因为运算只涉及到参数，仅到必要时才进行坐标计算；

:four: Nicholl-Lee-Nicholl算法仅适用于二维裁减。

#### 多边形裁剪

多边形裁剪的解，不是它每条边裁剪的解的叠加

##### 逐边裁剪算法

分割处理策略

> 将多边形关于矩形窗口的裁剪分解为多边形关于窗口四边所在直线(裁剪器)的裁剪。

流水线过程(左上右下)

> 一个裁剪器完成一对顶点的处理后，将获得的结果立即送给下一个裁剪器。

**基本思想**

一次用窗口的一条边裁剪多边形。

窗口的一条边以及延长线构成的裁剪线把平面分成两个部分:可见一侧(包含裁减窗口的一侧)；不可见一侧(不包含裁减窗口的一侧)。

多边形的各条边的两端点S、P。它们与裁剪线的位置关系只有四种[**四个规则要记清楚**]

![image-20220106212128020](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106212128020.png)

:one: 情况（1）仅输出顶点P；

:two: 情况（2）输出0个顶点；

:three: 情况（3）输出线段SP与裁剪线的交点I；

:four: 情况（4）输出线段SP与裁剪线的交点I和终点P。

![image-20220106212735928](C:/Users/26969/Desktop/image-20220106212735928.png)

> - 凹多边形：当裁剪后的多边形有两个或者多个分离部分时，会出现多余的直线。
> - 把凹多边形分割成若干个凸多边形，分别处理；
> - 修改本算法：沿着任何一个裁剪窗口边检查顶点表，正确的连接顶点对：采用Weiler-Atherton算法

#### 字符裁剪【填空题】

**字符裁剪问题**：字符和文本部分在窗内、部分在窗外时而出现的问题。

> **串精度**：将包围字串的外接矩形对窗口作裁剪,当字符串方框整个在窗口内时予以显示，否则不显示。
>
> **字符精度**：将包围字的外接矩形对窗口作裁剪,当字符方框整个在窗口内时予以显示，否则不显示。
>
> **笔画\象素精度**：将矢量字符的笔划分解成直线段对窗口作裁剪；将点阵字符像素相对窗口边界作取舍当字符方框整个在窗口内时予以显示，否则不显示。

![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106213232560.png)

### 反走样【重点】

在光栅显示器上显示图形时，直线段或图形边界或多或少会呈锯齿状：

![image-20220106220459094](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106220459094.png)

–图形信号是连续的，而在光栅显示系统中，采用离散的象素表示图形；

<font color="red">**走样：用离散量表示连续量引起的失真现象**</font>

–阶梯状边界；

–图形细节失真；

狭小图形遗失：动画序列中时隐时现，产生闪烁

<font color="red">**反走样：在图形显示过程中，用于减少或消除走样现象的方法或技术**</font>

<mark>反走样几种方法</mark>

> 提高分辨率方法
>
> 非加权区域采样
>
> 加权区域采样
>
> 半色调技术

#### 提高分辨率

假如把显示器分辨率（水平、垂直）提高一倍

![image-20220106221557088](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106221557088.png)

帧缓存容量则增加到原来的4倍，而扫描转换同样大小的图形却要花4倍时间

方法简单，但代价非常大，不经济

#### 区域采样

**改变直线段模型**

**方法步骤**：

> 将直线段看作具有一定宽度的狭长矩形；
>
> 直线段与某象素有交时，求两者相交区域的面积；
>
> 根据相交区域的面积，确定该象素的亮度值。

![image-20220106222050573](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106222050573.png)

直线段对一个像素亮度的贡献：

> 与两者相交区域的面积成正比；
>
> 和像素中心点距直线段的距离成反比。

![image-20220106222542238](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106222542238.png)

> 首先将屏幕象素均分成n个子象素；
>
> 然后计算中心点落在直线段内的子象素的个数k；
>
> 将屏幕该象素的亮度置为相交区域面积的近似值可k/n。

**缺点**

> 象素的亮度与相交区域的面积成正比，而与相交区域落在象素内的位置无关，仍然会导致锯齿效应；
>
> 直线条上沿理想直线方向的相邻两个象素有时会有较大的灰度差。

#### 加权区域取样

相交区域对象素亮度的贡献依赖于该区域与象素中心的距离。

![image-20220106222843098](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106222843098.png)

权函数可以取高斯函数(左)或恒等函数(右)

:one: 高斯函数![image-20220106223200692](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106223200692.png)

:two: 取恒等函数时,加权区域采样方法退化为非加权区域采样方法

![image-20220106223215406](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106223215406.png)

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106223222437.png" alt="image-20220106223222437" style="zoom:67%;" />

可采用离散计算方法 

> 将象素分割成n个等面积的子象素,计算每个子象素对原象素的贡献，并保存在一张二维的加权表中；
>
> 求出所有中心落于直线段内的子象素；
>
> 计算所有这些子象素对原象素亮度贡献之和的值；
>
> 该值乘以象素的最大灰度值作为该象素的显示灰度值。

![image-20220106223745335](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106223745335.png)

#### 半色调技术

简单和加权区域取样技术的**前提**是多级灰度，利用多级灰度来提高视觉分辨率

:question: 如果只有两级灰度

对于给定的分辨率，通过将几个像素组合成一个单元来获得多级灰度；

例：在一个显示器中将四个像素组成一个单元，可产生5种光强。

![image-20220106223927535](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106223927535.png)

用如下矩阵来表示

![image-20220106223954996](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220106223954996.png)

它表示黑色像素填入2´2个位置中的次序，每一级灰度再添上一个黑色像素就得到下一级灰度

> 要尽量避免连成一条直线的花样；
>
> 花样是可以选择的，单元也可以是长方形

**以牺牲空间分辨率为代价的**

### 消隐

#### 基本概念

**投影变换**失去了深度信息，往往导致图形的二义性

<mark>消隐</mark>：**为了消除二义性，必须在绘制时消除被遮挡的不可见的线或面，习惯上称作消除隐藏线和隐藏面；**

经过消隐得到的投影图称为物体的真实图形。

![image-20220107095649285](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107095649285.png)

消隐的对象是三维物体。三维体的表示主要有边界表示和构造实体几何表示等。

**最简单的方法**：用表面上的平面多边形表示。

消隐结果与观察物体有关，也与视点有关。

![image-20220107095756500](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107095756500.png)

<mark>**几个假设**</mark>

:one: 投影平面是oxy平面；

:two: 投影方向为负z轴方向的平行投影；

> 值越大，离视点越近；
>
> 透视变换转化为平行投影。

:three: 不能处理相互贯穿或循环遮挡的物体，此时应做特殊处理。

![image-20220107095914682](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107095914682.png)

在实时模拟过程中，要求消隐算法速度快，通常生成的图形质量一般；

在真实感图形生成过程中，要生成高质量的图形，通常消隐算法速度较慢。

消隐算法的权衡：**消隐效率**、**图形质量**。

<mark>与消隐与密切相关的因素</mark>

> **物体排序**：判断场景中的物体全部或者部分与视点之间的远近；
>
> **连贯性**：场景中物体或其投影所表现出来的相似程度。

#### 提高消隐算法效率的常见方法

利用连贯性、包围盒技术、背面剔除、空间分割技术、物体分层表示

##### 利用连贯性

**利用连贯性**：相邻事物的属性之间有一定的连贯性，其属性值通常是平缓过渡的，如颜色值、空间位置关系等

> 物体连贯性
>
> 面的连贯性
>
> 区域连贯性
>
> 扫描线的连贯性
>
> 深度连贯性

##### 包围盒技术

一个形体的包围盒指的是**包围它的简单形体**

> 假设包围和充分紧密包围着形体；
>
> 对其的测试比较简单。

常用包围盒:**长方体**、**球**、**圆柱**

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107100748712.png" alt="image-20220107100748712" style="zoom:67%;" />

##### 背面剔除

**外法向**：规定每个多边形的外法向都是指向物体外部的。

**前向面**：若多边形的外法向与投影方向（观察方向）的夹角为钝角（V· N<0），称为前向面。

**后向面**：若多边形的外法向与投影方向（观察方向）的夹角为锐角（V· N>0），称为后向面（背面）。

后向面总是看不见的，不会由于后向面的遮挡，而使别的棱成为不可见的。因此计算时，可以把这些后向面全部去掉，这并不影响消隐结果。

##### 空间分割技术

将投影平面上的窗口分成若干小区域；为每个小区域建立相关物体表，表中物体的投影于该区域有相交部分；则在小区域中判断那个物体可见时，只要对该区域的相关物体表中的物体进行比较即可

##### 物体分层表示

![image-20220107101337599](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107101337599.png)

减少场景中物体的个数，降低算法复杂度

#### 消隐的分类

##### 按消隐对象和输出结果分类

> **线消隐**：消除的是物体上不可见的边。 
>
> **面消隐**：消除的是物体上不可见的面。 

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107101446906.png" alt="image-20220107101446906" style="zoom:67%;" />

##### 根据消隐空间分类

:one: **物体空间的消隐算法**：以场景中的物体为处理单元；

```c
for (场景中的每一个物体)
{
	将其与场景中的其它物体比较，确定其表面的可见部分；
	显示该物体表面的可见部分；
}
```

假设场景中有k个物体，平均每个物体表面由h个多边形构成，显示区域中有m*n个像素，则算法的复杂度为：O((kh)\*(kh))

![image-20220107101755615](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107101755615.png)

:two: **图像空间的消隐算法**：以窗口内的每个像素为处理单元；

```c
for(窗口内的每一个像素)
{
 确定距视点最近的物体，以该物体表面的颜色来显示像素
}
```

假设场景中有k个物体，平均每个物体表面由h个多边形构成，显示区域中有m*n个像素，则算法的复杂度为：O(mnkh)

![image-20220107101853016](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107101853016.png)

•实际应用中通常会考虑画面的连贯性，所以图像空间算法的效率有可能更高。

:three: **物体空间和图像空间的消隐算法**：在物体空间中预先计算面的可见性优先级，再在图像空间中生成消隐图；

> 代表性算法：画家算法

#### 消除隐藏线

**对造型的要求**

> 在线框表示模型中，要求造型系统中有面的信息，最好有体的信息。

**坐标变换**

> 通过坐标变换，将视点变换到Z轴的正无穷大处，视线方向变为Z轴的负方向。

**最基本的运算**

> 线消隐中，判断面对线的遮挡关系：体分解成面，再判断面与线关系。判断过程中需反复地进行线线、线面之间的求交运算。

**算法**

:one: 若线段的两端点及视点在给定平面的同侧，线段不被给定平面遮挡，转(7)；

:two: 若线段的投影与平面投影的包围盒无交，线段不被给定平面遮挡，转(7)；

:three: 求直线与相应无穷平面的交：

> •无交点转(4)；
>
> •若交点在线段内部，交点将线段分成两段，与视点同侧一段不被遮挡，另一段在视点异侧转(4)；
>
> •若交点在线段外部,转(4)。

:four: 求所剩线段的投影与平面边界投影的所有交点。若无交点，转(7)。

:five: 以上所求得的各交点将线段的投影分成若干段，求出第一段中点。

:six: 若第一段中点在平面的投影内，则相应的段被遮挡，否则不被遮挡；其他段的遮挡关系可依次交替取值进行判断。

:seven: 结束。  

假设E为面F的一条边, 需判别F以外每一个面与E的遮挡关系。

假设消隐对象有n条边和m个面，当n和m很大时，两两求交的消隐方法工作量很大：

> 解决方法：背面剔除。

#### 消除隐藏面（不太好出考题）

##### 画家算法

**列表优先算法**：画家的作画顺序暗示出所画物体之间的相互遮挡关系。

**基本思想**

> :one: 先把屏幕置成背景色；
>
> :two: 再把物体的各个面按其离视点的远近进行排序，排序结果存在一张深度**优先级表**中；
>
> :three: 然后按照从远到近的顺序逐个绘制各个面。
>
> 关键是如何对场景中的物体按深度排序。
>

**多边形排序算法**

> 在规范投影坐标系里 *XYZ* 中，投影方向是 *Z*轴的负方向，因而 *Z*坐标大者距观察者更近。*Z*min(*P*)和 *Z*max(*P*) 分别为 *P* 各顶点 *Z*坐标的最小和最大值。[投影为正平行投影]
>
> **Step 1**:将场景中所有多边形存入一个线性表，记为L；
>
> **Step 2**:如果L中仅有一个多边形，算法结束；否则根据每个多边形的Zmin对它们预排序。不妨假定多边形P落在表首，即Zmin(P)为最小。再记Q为L–{P}(表中其余多边形）中任意一个；
>
> **Step 3**:判别P, Q之间的关系，有如下二种：
>
> > 对所有的Q，有Zmax(P)< Zmin(Q), 则多边形P的确距观察点最远，它不可能遮挡别的多边形。令L=L–{P}, 返回第二步；
> >
> > 存在某一个多边形Q，使Zmax(P)>Zmin(Q),需进一步判别：![image-20220107103622817](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107103622817.png)
>
> **优点**：简单（如何对场景中的物体按深度排序）。
>
> **缺点**：只能处理互不相交的面，且深度优先级表中面的顺序可能出错

##### Z缓冲区算法

**组成**

> 帧缓冲器--保存各像素颜色值；
>
> Z 缓冲器 --保存各像素处物体**深度值**；
>
> ![image-20220107103923683](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107103923683.png)Z缓冲器中的单元与帧缓冲器中的单元一一对应

**算法思想**

:one: 将 Z 缓冲器中个单元的初始值置为最小值。

:two: 多边形投影时，当要改变某个像素的颜色值时，首先检查当前多边形的深度值是否大于该像素原来的深度值：

> 大于，说明当前多边形更靠近观察点，用它的颜色替换像素原来的颜色；同时更新深度值；
>
> 否则说明在当前像素处，当前多边形被前面所绘制的多边形遮挡了，是不可见的， 像素的颜色值不改变。

```c
Z-Buffer算法（）
{ 	
	帧缓存全置为背景色
	深度缓存全置为最小Z值
	for(每一个多边形)
	{   
		扫描转换该多边形
	    for(该多边形所覆盖的每个象素(x,y) )
	   {	
	   		计算该多边形在该象素的深度值Z(x,y);
			if(Z(x,y)大于Z缓存在(x,y)的值)
			{    
				把Z(x,y)存入Z缓存中(x,y)处
				把多边形在(x,y)处的颜色值存入帧缓存的(x,y)处
			}	
	  }                       
     }                                                
}

```

需要计算的像素深度值次数 =多边形个数*多边形平均占据的像素个数

所有图像空间算法中**最简单**的一种隐藏面消除算法

**优点**：

> 简单稳定，利于硬件实现；
>
> 不需要整个场景的几何数据。

**缺点**:

> 空间：需要一个额外的Z缓冲器；
>
> 时间：在每个多边形占据的每个像素处都要计算深度值。

只用一个深度缓存变量zb的改进算法：需要开一个与图象大小相等的缓存数组ZB

```c
{
	帧缓存全置为背景色
	for (屏幕上的每个象素(i, j)) {
		深度缓存变量zb置最小值MinValue
		for (多面体上的每个多边形Pk) {
			if (象素点(i, j)在Pk的投影多边形之内) {
				计算Pk在(i, j)处的深度值depth;
				if (depth大于zb) {
					zb = depth;
					indexp = k;
				}
			}
		}
		if (zb != MinValue)
			在交点 (i, j) 处用多边形Pindexp的颜色显示
		}
}
```

<font color="red">先像素后多边形</font>

**关键问题**

:one: 计算多边形 在点（i，j）处的深度。设多边形的平面方程为：

![image-20220107105550460](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107105550460.png)

:two: 判断象素点(i,j)是否在 的投影多边形之内（点与多边形的包含性检测）

**射线法**

![image-20220107105648534](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107105648534.png)

由被测点P处向 y = - ¥方向作射线

> 交点个数是**奇数，则被测点在多边形内部**；
>
> 否则，**偶数，在多边形外部**；
>
> 若射线正好经过多边形的顶点，则采用“左开右闭”的原则来实现。

**弧长法（单位圆）**

–以被测点为圆心作单位圆，计算其在单位圆上弧长的代数和

> 代数和为0，点在多边形外部；
>
> 代数和为$2\pi$，点在多边形内部；
>
> 代数和为$\pi$，点在多边形边上。

![image-20220107140435401](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107140435401.png)

弧长累加方法：以顶点符号为基础。

> 将坐标原点移到被测点P。各象限内点的符号对分别为(＋,＋)，（－，＋)，(－，－)，(＋，－)。
>
> 算法规定：若顶点pi的某个坐标为0,则其符号为＋。若顶点pi的x、y坐标都为0，则说明这个顶点为被测点，我们在这之前予以排除。于是弧长变化如下表。

注意：当边的终点Pi+1在起点Pi的相对象限时，弧长变化可能增加或减少p：

##### 扫描线Z-buffer算法[了解就行]

Z 缓冲器算法中所需要的Z 缓冲器容量较大，可以将整个绘图区域分割成若干个小区域，然后**一个区域一个区域地显示**，以减少Z 缓冲器的单元数；

**如果将小区域取成屏幕上的扫描线，就得到扫描线 Z 缓冲器算法。**

**算法思想**

> :one: 面Buffer到线Buffer；
>
> :two: 利用图形的连贯性(指深度计算)；
>
> :three: 在处理当前扫描线时，开个一维数组作为当前扫描线的Z-buffer。找出与当前扫描线相关的多边形，以及每个多边形中相关的边对；
>
> :four: 对每一个边对之间的小区间上的各象素，计算深度，并与Z-buffer中的值比较，找出各象素处可见平面；
>
> :five: 确定颜色，写帧缓存：采用增量算法计算深度。
>

**改进**

> :one: 将窗口分割成扫描线：Z缓冲器的单元数只要等于一条扫描线内像素的个数就可以了。
>
> ![image-20220107141259785](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107141259785.png)
>
> :two: 采用多边形Y(分类)表、活化多边形表避免**多边形**与扫描线的盲目求交；
>
> :three: 利用边、边的分类表、边对、活化边对表避免**边**与扫描线的盲目求交。
>
> :four: 利用连贯性计算深度
>

**水平方向**：当沿扫描线x递增一个像素时，多边形所在平面在z坐标的增量，对方程ax+by+cz+d=0来说，$\Delta z_a=-a/c$ 

**竖直方向**

$\Delta z_b$ ：当沿扫描线y递增一个像素时，多边形所在平面 z坐标的增量， $\Delta z_b=-b/c$

下一条扫描线与边对左侧边交点处的深度值：$z_1=z_1+\Delta x_1 \Delta z_a+\Delta z_b$

![image-20220107142216586](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107142216586.png)

**数据结构**

> 多边形Y表； 活化多边形表(APT);边表(ET);活化边对表(AET)。
>
> **多边形Y表**
>
> 存放所有多边形信息。
>
> 根据多边形顶点中最小的y坐标，插入多边形Y表中的相应位置；
>
> 根据序号可从定义多边形的数据结构中取多边形信息。(ax+by+cz+d=0的系数，多边形的边，顶点坐标和颜色
>
> ![image-20220107142623370](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107142623370.png)
>
> **活化多边形表APT**：与当前扫描线相交的多边形。
>
> APT是一个动态的链表。
>
> ![image-20220107142747773](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107142747773.png)
>
> **边表ET**：活化多边形表中的每一个多边形都有一个边表ET(每条边端点中较大者，增量 Dx，y值较小一端的x坐标和z坐标)
>
> ![image-20220107142944395](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107142944395.png)
>
> **活化边对表**AET
>
> 在一条扫描线上，同一多边形的相邻两条边构成一个**边对**。活化边表AET中存放当前多边形中与当前扫描线相交的各边对的信息。
>
> ![image-20220107143020380](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107143020380.png)
>
> ![image-20220107143115098](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107143115098.png)
>

```shell
扫描线Z - buffer算法() {
	建多边形y表；根据多边形顶点最小y值，将多边形置入多边形y表。
	活化多边形表APT，活化边对表AET初始化为空。
	For(每条扫描线i，i从小到大) {
		1. 帧缓存CB置为背景色。
		2. 深度缓存ZB (一维数组) 置为负无穷大。
		3. 将对应扫描线i的，多边形Y表中的多边形加入到活化多边形表APT中。
		4. 对新加入的多边形，生成其相应的边表。
		5. 对APT中每一个多边形，若其边表中对应扫描线i增加了新的边，将新的边配对，加到活化边对表AET中。
		6. 对AET中的每一对边：
			6.1 对xl < j < xr 的每一个象素，按增量公式z = z + ? za计算各点depth 。
		    6.2 与ZB中的量比较，depth > ZB(j), 则令ZB(j) = depth，并确定颜色
		                值，写帧缓存。
		7. 删除APT中多边形顶点最大y坐标为i的多边形，并删除相应的边。
		8. 对AET中的每一个边对，作如下处理：
		    8.1 删除ylmax或yrmax 已等于i的边。若一边对中只删除了其中一边，
		        对该多边形的边重新配对。
		    8.2 用增量公式计算新的xl 、 xr 和zl
	}
}

```

**缺点**

在每一个被多边形覆盖像素处需要计算深度值；

被多个多边形覆盖的像素需要多次计算深度值。

**对比**

> 与Z-Buffer算法相比，扫描线算法有了很大改进
>
> **优点：**
>
> > 将整个绘图窗口内的消隐问题分解到一条条扫描线上解决，使所需的Z-Buffer大大减少 ；
> >
> > 计算深度值时，利用了面连贯性，只用了一个加法 。
>
> **缺点**：
>
> > 每个像素处都计算深度值，甚至不止一次的计算（多边形重叠区域），运算量仍然很大。
>

**改进**

在一条扫描线上，每个区间只计算一次深度，即区间扫描线算法，又称扫描线算法

##### 区间扫描线算法

**基本思想**

把当前扫描线与各多边形在投影平面的投影的交点进行排序后，使扫描线分为若干子区间。只要在区间任一点处找出在该处z值最大的一个面，这个区间上的每一个象素就用这个面的颜色来显示。

**注意**：该算法要求多边形不能相互贯穿，否则在同一区间上，多边形深度值的次序会发生变化。

**如何确定小区间的颜色可分为三种情况**

> 小区间上没有任何多边形，如[a4,a5]，这时该小区间用背景色显示；
>
> 小区间上只有一个多边形，如[a1,a2][a5,a6]这时可以对应多边形在该处的颜色显示；
>
> 小区间上存在两个或两个以上的多边,形如[a6,a7]，必须通过深度测试判断哪个多边形可见。
>
> ![image-20220107144037607](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107144037607.png)
>
> 若允许物体表面相互贯穿时，还必须求出它们在扫描平面的交点。用这些交点把该小区间分成更小的子区间，在这些间隔上决定哪个多边形可见。如将[a2,a3]区间分成[a2,b][b,a3]两个子区间

类似于扫描线Z-Buffer算法中的数据结构

> 多边形分类表、活化多边形表、边表、活化边表
>
> 活化边表中的结点是**边，而非边对**

:question: 如何知道每一个区间中，有几个相关的多边形？是哪几个？

:label: 解决方案：活化多边形表中增加一个标志，flag=0, 每遇到它的边，flag取反。

```c
for (绘图窗口内的每一条扫描线）
{   求投影与当前扫描线相交的所有多边形
     求上述多边形中投影与当前扫描线相交的所有边，将它们记录在活化边表AEL中
     求AEL中每条边的投影与扫描线的交点；
     按交点的u坐标将AEL中各边从左到右排序，  两两配对组成一个区间；
      for （AEL中每个区间）
       {
          求覆盖该区间的所有多边形，将它们记入活化多边形表APL中；
          在区间上任取一点，计算APL中各多边形在该点的深度值，记深度最大者为P；
           用多边形P的颜色填充该区间
        }
}
```

**算法的优点**：将逐点(象素、Pixel)计算改为逐段计算,效率大大提高！

##### 区域子分割算法

**基本思想**

首先将场景中的多边形投影到绘图窗口内，判断窗口是否足够简单，若是则算法结束；否则将窗口进一步分为四块。对此四个小窗口重复上述过程，直到窗口仅为一个像素大小。此时可能有多个多边形覆盖了该像素，计算它们的深度值，以最近的颜色显示该像素即可。

**何谓窗口足够简单**

窗口为空，即多边形与窗口的关系是分离的；

窗口内仅含一个多边形，即有一个多边形与窗口的关系是**包含或相交**。此时先对多边形投影进行裁剪，再对裁剪结果进行填充；

有一个多边形的投影包围了窗口，并且它是最靠近观察点的，以该多边形颜色填充窗口。

![image-20220107144633771](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220107144633771.png)

•分离和包围多边形的判别方法：射线检查法；转角累计检查法；区域检查法（考试不考）

##### 光线投射算法

**基本思想**：

:one: 考察由视点出发穿过观察屏幕一象素而射入场景的一条射线，则可确定出场景中与该射线相交的物体；

:two: 在计算出光线与物体表面的交点之后，离象素最近的交点的所在面片的颜色为该象素的颜色；

:three: 如果没有交点，说明没有多边形的投影覆盖此象素，用背景色显示它即可。

```
for屏幕上的每一象素
  {形成通过该屏幕象素(u,v)的射线；
	 for 场景中的每个物体
         {将射线与该物体求交；
		if 存在交点
		     以最近的交点所属的颜色显示象素(u,v)
		 else
		      以背景色显示象素(u,v)
	    }
    }
```

光线投射算法与Z缓冲器算法相比，它们仅仅是内外循环颠倒了一下顺序，算法复杂度类似

> 区别在于光线投射算法不需要Z缓冲器；
>
> 为了提高本算法的效率可以使用包围盒技术，空间分割技术以及物体的层次表示方法等来加速。

**几何造型技术**

> 研究在计算机中，如何表达物体模型形状的技术；
>
> 70年代，已有不少实用化系统；
>
> 已应用于航空航天、汽车、机械、造船、建筑和电子等领域。

<mark>描述物体的三维模型</mark>: **线框模型、曲面模型、实体模型**。

> **线框模型**:  利用形体的**顶点和棱边**来表示物体。
>
> **曲面模型**：通过有向棱边构成形体的表面，用**面的几何**表达相应的形体。
>
> **实体模型**：定义一些基本体素，并通过集合运算将它们组合成复杂的几何形体。

## 第三章——参数曲线和曲面

### 曲线曲面参数表示

#### 非参数表示

**显式表示**:y=f(x)，无法表示封闭或多值曲线，如圆。

**隐式表示**:f(x,y)=0，易于判断函数值与零的关系，确定点与曲线的关系。

存在下述问题：

> 与坐标轴相关；
>
> 会出现斜率为无穷大的情形(如垂线)。

#### 参数表示

**参数表示**:曲线上任一点的坐标均表示成给定参数的函数。假定用t表示参数

平面曲线上任一点P: $P(t)=[x(t),y(t)]$

空间曲线上任一三维点P: $P(t)=[x(t),y(t),z(t)]$

参数表示例子：

> 直线：$P(t)=P_1+(P_2-P_1)t$
>
> 圆：$P(t)=[\frac{1-t^2}{1+t^2},\frac{2t}{1+t^2}]$

参数表示的**优点**：

> 满足几何不变性的要求；
> 有更大的自由度来控制曲线、曲面的形状；
> 对参数方程进行几何变换即实现对曲线(面)的变换；
> 便于处理斜率为无穷大的情形；
> 参数方程中，代数、几何相关和无关的变量是完全分离的，且对变量个数不限，便于用户把低维空间中曲线、曲面扩展到高维空间去；
> 规格化的参数变量t∈[0,1]，使其相应的几何分量是有界的，不必用另外的参数去定义边界；
> 易于用矢量和矩阵表示几何分量，简化了计算。

### 曲线的基本概念

:one: **三维曲线**

用参数表示的三维曲线是一个有界的点集，可以表示成一个带参数的、连续的和单值的数学函数：
$$
\left\{ 
    \begin{array}{lc}
        x=x(t) \\
        y=y(t),\quad 0\le t\le 1\\
        z=z(t)
    \end{array}
\right.
$$

:two: **位置矢量**

曲线上任一点的位置矢量可表示为：$P(t)=[x(t),y(t),z(t)]$

如存在k阶导数矢量，则：$P^k(t)=\frac{d^kP}{dt^k}$

:three: **切矢量**

选择弧长**s**作为参数，则 $T=\frac{dP}{ds}=\underset{\Delta s \to0}{\lim}\frac{\Delta P}{\Delta s} $        是单位切矢量

根据弧长微分公式有：

![image-20220213123228060](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213123228060.png)

于是有  <mark>$\frac{dP}{ds}=\frac{dP}{dt}.\frac{dt}{ds}=\frac{P'(t)}{|P'(t)|}$</mark>

 即*T* 为单位矢量

:four: **法矢量**

所有垂直于切矢量*T* 的矢量有一束，且位于法平面上

$\frac{dT}{ds}$是与T垂直的矢量；与$\frac{dT}{ds}$平行的法矢称为曲线在该点的**主法矢(N)**

矢量积 $B=T\times N$ 是第三个单位矢量，它垂直于T和N。把平行于矢量B的法矢称为曲线的**副法矢**量；

可以推导出：

![image-20220213123733723](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213123733723.png)

T(切矢)、N(主法矢)和B(副法矢)构成了曲线上的活动坐标架；

N、B构成的平面称为**法平面**，N、T构成的平面称为**密切平面**，B、T构成的平面称为**从切平面**。

:five: 曲率和挠率

圆的半径越小，曲率越大

![image-20220213124835263](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213124835263.png)

![image-20220213124818254](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213124818254.png)

![image-20220213125013086](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213125013086.png)

### 插值、拟合和光顺(掌握概念)

:one: **<mark>插值</mark>**: 给定一组有序的数据点*P*i构造一条曲线顺序**通过这些数据点**，所构造的曲线称为插值曲线。

> **线性插值**：$y=ax+b$
>
> **抛物线插值**：$\varphi(x)=ax^2+bx+c$
>
> ![image-20220213125636751](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213125636751.png)

:two: **<mark>拟合</mark>**：构造一条曲线使之在某种意义下**最接近给定的数据点**，所构造的曲线为**拟合**曲线。

:three: **逼近**:在计算数学中，逼近通常指用一些性质较好的函数近似表示一些性质不好的函数。在计算机图形学中，逼近继承了这方面的含义

> <mark>包含插值和拟合</mark>

:four: **过拟合：**模型在训练集上效果很好，在测试集上效果差(不考)

:five: **光顺**(Fairing)：指曲线的拐点不能太多。对平面曲线而言，相对光顺的条件是：

> a. 具有<mark>二阶几何连续性(G2)</mark>
>
> b. 不存在多余拐点和奇异点；
>
> c. 曲率变化较小。

### 参数化

#### 概念

过三点P0、P1和P2构造参数表示的插值多项式可以有无数条：

> 对应地参数*t*, 在[0,1]区间中有无数种取法；
>
> 参数值称为节点(knot)。

对于一条插值曲线，型值点$P_0,P_1,...,P_n$与其参数域$t\in[t_0,t_n]$内的节点之间有一种对应关系：

对于一组有序的型值点，所确定一种参数分割，称之为这**组型值点的参数化**。

#### 参数化常用方法

:one: 均匀参数化(等距参数化)； 

节点在参数轴上呈等距分布,  $t_{i+1}=t_i+正常数$。

:two: 累加弦长参数化；
$$
\left\{     
\begin{array}{lc}       
t_0=0 \\        
t_i=t_{i-1}+|\Delta P_{i-1}|,\ i=1,2,...,n,\\        
  
\end{array}
\right.
\qquad \Delta P_i=P_{i+1}-P_i
$$
反映型值点按弦长的分布情况；

能克服均匀参数化所出现的问题。

:three: 向心参数化法；

:four: 修正弦长参数化法。

#### 参数区间的规格化

我们通常将参数区间$[t_0,t_n]$规格化为[0,1]，$[t_0,t_n]\not = [0,1]$，只需对参数化区间作如下处理：
$$
t_0=0,\ t_i=\frac{t_i}{t_n},\ i=0,1,...,n
$$

### 参数曲线的代数和几何形式(了解一下)

以三次参数曲线为例，讨论参数曲线的代数和几何形式

#### 代数形式

![image-20220213141426456](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213141426456.png)

上述代数式写成矢量式是<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213141438490.png" alt="image-20220213141438490" style="zoom:50%;" />

#### 几何形式

对三次参数曲线，可用其端点位矢P(0)、P(1)和切矢P¢(0)、P‘(1)描述。

将P(0)、P(1)、P’(0)和P‘(1)简记为P0、P1、P‘0和P’1，代入

![image-20220213141527888](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213141527888.png)，得

![image-20220213141544736](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213141544736.png)

![image-20220213141549416](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213141549416.png)

令![image-20220213141628288](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213141628288.png)

简化为<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213141639553.png" alt="image-20220213141639553" style="zoom:67%;" />

上式是三次Hermite(Ferguson)曲线的**几何形式**

> •**几何系数**：$ P_0、P_1、P'_0和P'_1$
>
> •**调和系数**：$F_0、F_1、G_0、G_1$

![image-20220213141911351](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213141911351.png)

参数$F_0,F_1$专门控制端点的函数值对曲线的影响；

参数$G_0,G_1$专门控制端点的一阶导数值对曲线的影响。

### 连续性

设计制造时，组合多段曲线，因此需要解决曲线段之间的**光滑连接问题**。

<mark>曲线间连接的光滑度的度量</mark>(会考概念)

> **参数连续性**：组合参数曲线在连接处具有直到*n*阶连续导矢，即*n*阶连续可微，称为*n*阶参数连续性$C^n$
>
> **几何连续性**：组合曲线在连接处满足不同于$C^n$的某一组约束条件，称为具有*n*阶几何连续性$G^n$。
>
> > 介于n-1阶参数连续性和n阶参数连续性之间
>
> 同阶参数连续性的要求比几何连续性高

#### 引进几何连续的重要性

:label: **举例**

![image-20220213142246320](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213142246320.png)

> 第$\Phi(t)$在[0,2]上表示一条连接$V_0,V_1$的直线段；
>
> 左右导数不等: $\Phi(1^-)=\frac{1}{3}(V_1-V_0),\ \Phi(1^+)=\frac{2}{3}(V_1-V_0)$
>
> 参数连续描述光滑性不恰当。

#### <mark>举例说明</mark>

对于参数$t\in [0,1]$的两条曲线*P*(t)和*Q*(*t*)

![image-20220213144235983](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213144235983.png)

:one: 若要求在结合处达到$C^0$连续或$G^0$连续，即两曲线在结合处位置连续：$P(1)=Q(0)$

:two: 若要求在结合处达到$G^1$连续，就是说两条曲线在结合处在满足$G^0$连续的条件下，并有公共的切矢
$$
Q'(0)=\alpha P'(1)\qquad (\alpha >0)
$$
当$\alpha = 1$时， $G^1$连续就成为$C^1$ 连续

> 若*P* 和*Q* 在连接处已有$C^0 C^1$连续性且曲率的大小和方向均相等，即$P''(1)=Q''(0)$则*P* 和*Q* 在连接处具有$C^2$连续
>
> 若*P* 和*Q* 在连接处已有$C^0 C^1$连续性且曲率的**大小不相等但方向相等**，则*P* 和*Q* 在连接处具有$G^2$连续。

:three: 若要求在结合处达到$G^2$连续，就是说两条曲线在结合处在满足$G^1$连续的条件下，并**有公共的曲率矢**：

![image-20220213144734310](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213144734310.png)

这个关系可写为<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213144756444.png" alt="image-20220213144756444" style="zoom: 67%;" />

$\beta$为任意常数，当$\alpha =1 , \beta = 0$时，$G^2$连续就成了$C^2$连续

### 参数曲面基本概念

一张定义在矩形域上的参数曲面可以表示为

![image-20220213145226314](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213145226314.png)

可记为<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213145231332.png" alt="image-20220213145231332" style="zoom:50%;" />

曲面上的点：将给定的参数值$u_0,v_0$代入参数方程，可得曲面上的点$P(u_0,v_0)$

曲面上一点的切向量(切矢)：
$$
\frac{\partial{}P(u,v)}{\partial{}u}|u=u_0,v=v_0 \qquad \frac{\partial{}P(u,v)}{\partial{}v}|u=u_0,v=v_0
$$
曲面上一点的法向(法矢)：

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213150457701.png" alt="image-20220213150457701" style="zoom: 67%;" />

角点：$P(0,0),P(0,1),P(1,0),P(1,1)$

边界线：$P(u,0),P(u,1),P(0,w),P(1,w)$

![image-20220213150623023](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213150623023.png)

## 第三章—Bezier 曲线与曲面(11分)

**起源**

由于几何外形设计的要求越来越高，传统的曲线曲面表示方法, 已不能满足用户的需求；

1962年，P.E.Bezier构造了一种以逼近为基础的参数曲线和曲面的设计方法，并用这种方法完成了UNISURF系统(1972年投入了应用)；

Bezier方法将函数逼近同几何表示结合起来，使得设计师在计算机上就象使用作图工具一样得心应手。

**优点**

输入的控制点与生成曲线之间的关系明确；

能方便地改变曲线的形状和阶次；

无论是直线或曲线都能在数学上予以描述 (为计算机矢量图形学奠定了基础 )。

**应用领域**

:one: 计算机辅助设计与制造（CAD/CAM）

> 飞机、汽车、船舶外形的设计；
>
> 水泵叶轮和齿轮等机械零件的设计。

:two: 桥梁建筑物以及日用品的设计

:three: 曲线字形轮廓描述

:four: 地图图形管理系统

:five: 移动机器人运动规划

> 处于A点，需要达到D点；
>
> AD之间有障碍物；
>
> 运动往往是沿着曲线进行的。

### Bezier 曲线的定义与性质

#### 定义

给定空间*n*+1个点的位置矢量*Pi*（*i*=0,1,2,…,*n*），则Bezier参数曲线上各点坐标的插值公式是：

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213161512575.png" alt="image-20220213161512575" style="zoom:67%;" />

$P_i$构成该Bezier曲线的特征多边形

$B_{i,n}(t)$是n次Bernstein**基函数**：

![![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213161653148.png)](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213161653148.png)

**举例**![image-20220213161916870](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213161916870.png)

#### 习题

:one: 设有控制顶点为P0(0,0)，P1(48,96)，P2(120,120)，P3(216,72)的三次Bézier曲线P(t)，试计算P(0,4)的(x,y)坐标，并写出(x(t),y(t))的多项式表示。

![image-20220213163220219](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213163220219.png)

:two: 设一条三次Bézier曲线的控制顶点为P0，P1，P2，P3。对曲线上一点P(0.5)，及一个给定的目标点T，给出一种调整Bézier曲线形状的方法，使得P(0.5)精确通过点T。

![image-20220213164204503](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213164204503.png)

#### Bernstein基函数性质

:one: **正性**

![image-20220213164640737](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213164640737.png)

:two: **端点性质**

![image-20220213164907949](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213164907949.png)

:three: **权性**

![image-20220213164931020](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213164931020.png)

:four: **对称性**

![image-20220213165000146](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213165000146.png)

**推导**

![image-20220213165014714](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213165014714.png)

![image-20220213165119631](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213165119631.png)

:five: **递推性**

![image-20220213165158514](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213165158514.png)

**推导**

![image-20220213165215822](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213165215822.png)

<mark>即高一次的Bernstein基函数可由两个低一次Bernstein基函数线性组合而成。</mark>>

:six: **导函数**

![image-20220213165313812](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213165313812.png)

**推导**

![image-20220213165332468](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213165332468.png)

:seven: **最大值**

![image-20220213165343864](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213165343864.png)

:eight: **积分**

![image-20220213165354560](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213165354560.png)

:nine: **升阶公式**

![image-20220213165404786](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213165404786.png)

#### <mark>Bezier曲线的性质</mark>(选择)

:one: **端点性质**

**曲线端点位置矢量**

> 由Bernstein基函数的端点性质可以推得，当t=0时，$P(0)=P_0$ ；当t=1时，$P(1)=P_n$。由此可见，Bezier曲线的<mark>**起点、终点与相应的特征多边形的起点、终点重合**</mark>。

**切矢量**

> 因为<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213165707531.png" alt="image-20220213165707531" style="zoom: 80%;" />  所以当t=0时，$P’(0)=n(P_1-P_0)$，当t=1时，$P’(1)=n(P_n-P_{n-1})$，Bezier曲线的<mark>**起点和终点处的切线方向和特征多边形的第一条边及最后一条边的走向一致**</mark>

**二阶导矢**

![image-20220213170004104](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213170004104.png)

<mark>**2阶导矢只与相邻的3个顶点有关，事实上，*r*阶导矢只与（*r*+1）个相邻点有关，与更远点无关**</mark>

**:two: *k*阶导函数的差分表示**

n次Bezier曲线的k阶导数可用差分公式为：

![image-20220213170205275](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213170205275.png)

其中**高阶向前差分矢量**由低阶向前差分矢量递推地定义：

![image-20220213170212572](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213170212572.png)

例如

![image-20220213170225825](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213170225825.png)

<font color="red">**题目**</font>

试证明n次Bezier曲线退化为（n-1）次Bezier曲线的条件为$\Delta ^0 P_0=0$ 。 

![image-20220213171428110](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213171428110.png )

:three: **对称性**

由控制顶点$P_i^*=P_{n-i},(i=0,1,...,n)$构造出的新Bezier曲线，与原Bezier曲线形状相同，走向相反。因为：

![image-20220213173655651](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213173655651.png)这个性质说明Bezier曲线在起点处有什么几何性质，在终点处也有相同的性质。

:four: **凸包性**

由于$\underset{i=0}{\overset{n}{\sum}}B_{i,n}(t)\equiv 0$，且$0\le B_{i,n}(t)\le 1(0\le t \le 1,i=0,1,...,n)$，这一结果说明当*t*在[0,1]区间变化时，对某一个*t*值，*P(t)*是特征多边形各顶点的加权平均，权因子依次是$B_{i,n}(t)$  ；

在几何图形上，意味着Bezier曲线*P(t)*在$t\in [0,1]$中各点是控制点*P*i的**凸线性组合**，即曲线落在*P*i构成的凸包之中 。

:five: **几何不变性**

某些几何特性不随坐标变换而变化的特性；

Bezier曲线位置与形状与其特征多边形顶点$P_i(i=0,1,...,n)$ 的位置有关：

![image-20220213174351235](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213174351235.png)

<mark>:six: **变差缩减性**</mark>(考点)

若Bezier曲线的特征多边形$P_0P_1...P_n$ 是一个平面图形，则平面内任意直线与*P*(*t*)的交点个数不多于该直线与其特征多边形的交点个数；

反映了Bezier曲线**比其特征多边形的波动还小**

:seven: **仿射不变性**

对于任意的仿射变换*A*：

![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213174756396.png)

即在仿射变换下，   的形式不变。

#### 矩阵表示形式

![image-20220213174912045](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213174912045.png)

### Bezier曲线的递推算法(必考)

#### 算法原理

de Casteljau(德卡斯特里奥)递推算法

便于计算Bezier曲线上的点

<img src="https://upload-images.jianshu.io/upload_images/24521788-3db3d179dce6fa10.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="img" style="zoom:50%;" />

如图所示，设$P_0、P_0^2、P_2$是一条抛物线上顺序三个不同的点。过$P_0$和$P_2$点的两切线交于$P_1$点,在$P_0^2$点的切线交$P_0P_1$和$P_2P_1$于$P_0^1$和 $P_1^1$，则如下比例成立：

![image-20220213175528804](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213175528804.png)



[证明过程](https://www.jianshu.com/p/6e53086030c8)

当$P_0$，$P_2$固定，引入参数*t*，令上述比值为*t*:(1-*t*)，即有：

![image-20220213181349195](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213181349195.png)

*t*从0变到1，第(1)、(2)式就分别表示控制二边形的第一、二条边，它们是两条一次Bezier曲线。

将(1)、(2)式代入第(3)式得

![image-20220213181419189](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213181419189.png)

当*t*从0变到1时，它表示了由三顶点*P*0、*P*1、*P*2三点定义的一条二次Bezier曲线；

这二次Bezier曲线可以定义为分别由前两个顶点(*P*0,*P*1)和后两个顶点(*P*1,*P*2)决定的一次Bezier曲线的线性组合。

依次类推，由四个控制点定义的三次Bezier曲线  可被定义为分别由(*P*0,*P*1,*P*2)和(*P*1,*P*2,*P*3)确定的两条二次Bezier曲线的线性组合

<mark>由(n+1)个控制点$P_i(i=0,1,...,n)$定义的n次Bezier曲线$P_0^n$可被定义为分别由前、后n个控制点定义的两条(n-1)次Bezier曲线$P_0^{n-1}$与$P_1^{n-1}$的线性组合</mark>

![image-20220213181809957](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213181809957.png)

由此得到Bezier曲线的递推计算公式：

![image-20220213181839981](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213181839981.png)

> 在给定参数下，求Bezier曲线上一点*P*(*t*)非常有效。
>
> 上式中：  $P_i^0=P_i$是定义Bezier曲线的控制点，$P_0^n$即为曲线P(t)上具有参数*t*的点。
>
> 算法稳定可靠，直观简便，可以编出十分简捷的程序，是计算Bezier曲线的基本算法和标准算法。

当*n*=3时，算法递推出的$P_i^k$呈直角三角形，对应结果如图所示。从左向右递推，最右边点$P_0^3$即为曲线上的点。

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213182222210.png" alt="image-20220213182222210" style="zoom: 67%;" />

#### 习题举例

:one: 已知三次Bezier曲线上的4个点分别为Q0(50,0), Q1(100,0), Q2(0,50), Q3(0,100),它们对应的参数分别为0,1/3, 2/3,1,求Bezier曲线的控制顶点。[了解一下]

![image-20220213182619293](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213182619293.png)<mark>:two: 计算以(30,0),(60,10),(80,30),(90,60),(90,90)为控制顶点的4次Bezier曲线在t=1/2处的值,并画出de Casteljau三角形</mark>

![image-20220213183117515](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213183117515.png)

:three: 给出三次Bezier曲线退化为二次Bezier，控制顶点P0,P1,P2,P3应该满足的条件。 

![image-20220213183848289](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213183848289.png)

:four: 设一条二次Bezier曲线的控制顶点为P0,P1,P2,另一条二次Bezier曲线的控制顶点为Q0,Q1,Q2, P2 =Q0.写出两条曲线可以精确合并(表示)为一条二次Bezier曲线的条件。 

![image-20220213190309738](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213190309738.png)

### Bezier曲线的拼接(了解)

几何设计中，一条Bezier曲线往往难以描述复杂的曲线形状。

> 增加特征多边形的顶点数，会引起Bezier曲线次数的提高，而高次多项式又会带来计算上的困难；
>
> 可采用**分段设计**，然后将各段曲线相互连接起来，并在接合处保持一定的连续条件。

两段Bezier曲线达到不同阶几何连续的条件

![image-20220213195628738](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213195628738.png)

•给定两条Bezier曲线*P*(*t*)和*Q*(*t*)，相应控制点为*P*i(*i*=*0*,1,...,*n*)和*Q*j(*j=*0,1,..., *m*)，且令        $a_i=P_i-P_{i-1},b_j=Q_j-Q_{j-1}$，如图所示，我们现在把两条曲线连接起来。

:one: 达到$G^0$连续的充要条件是：$P_n=Q_0$；

:two: 达到$G^1$连续的充要条件是：$P_{n-1},P_n=Q_0,Q_1$三点共线，即：$b_1=\alpha a_n(\alpha>0)$

:three: 达到$G^2$连续的充要条件是：$G^1$在连续的条件下，并满足方程   

![image-20220213200121585](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213200121585.png)

![image-20220213200149637](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213200149637.png)

> 选择$\alpha$和 $\beta$的值，可以利用该式确定曲线段$Q(t)$的特征多边形顶点$Q_2$
>
> 顶点$Q_0$、$Q_1$已被$G^1$连续条件所确定，要达到$G^2$连续的话，只剩下顶点$Q_2$可以自由选取；
>
> 如果上式的两边都减去$P_n$，则等式右边可以表示为$(P_n-P_{n-1})$和 $(P_{n-1}-P_{n-2})$ 的线性组合：
>
> ![image-20220213200456320](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213200456320.png)
>
> 这表明$P_{n-2}、P_{n-1}、P_n=Q_0、Q_1和Q_2$ 五点共面

### Bezier曲线的升阶与降阶（考过了）

#### Bezier曲线的升阶

##### 定义

**升阶**：**保持Bezier曲线的形状与方向不变，增加定义它的控制顶点数，提高该Bezier曲线的次数。**

增加了控制顶点数，增加了对曲线进行形状控制的灵活性，还在构造曲面方面有着重要的应用：

> 对于由曲线生成曲面的算法，要求那些曲线必须是同次的。

应用升阶的方法，可以把低于最高次数的的曲线提升到最高次数，而获得相同的次数。

##### 新控制顶点的计算

设给定原始控制顶点$P_0,P_1,...,P_n$，定义了一条*n*次Bezier曲线：

![image-20220213200936277](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213200936277.png)

增加一个顶点后，仍定义同一条曲线的新控制顶点为$P_0^*,P_1^*,...,P_{n+1}^*$,则有

![image-20220213201047222](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213201047222.png)

对上式左边乘以(t+(1-t))，得到

![image-20220213201110375](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213201110375.png)

比较等式两边$t_i(1-t)^{n+1-i}$项的系数，得到

![image-20220213201157729](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213201157729.png)

![image-20220213201202957](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213201202957.png)

其中$P_{-1}=P_{n+1}=(0,0)$

上述结果说明：

> 新的控制顶点$P_i^*$是以参数值$\frac{i}{n+1}$按分段线性插值从原始特征多边形得出的
>
> 升阶后的新的特征多边形在原始特征多边形的凸包内
>
> 特征多边形更靠近曲线。

##### 题目

推导Beizer曲线的升阶公式；给定三次Bezier曲线的控制顶点(0,0), (0,100), (100,0), (100,100),计算升阶一次后的控制顶点。

![image-20220213201927227](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213201927227.png)

#### Bezier曲线的降阶

给定一条由原始控制顶点定义的*n*次Bezier曲线，要求找到一条由新控制顶点定义的*n*-1次Bezier曲线来逼近原始曲线。

##### 新控制点的计算

–假定$P_i$是由$P_i^*$升阶得到，则由升阶公式有：

![image-20220213202136239](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213202136239.png)

从前述方程可以导出两个递推公式

![image-20220213202223564](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213202223564.png)

其中第一个递推公式在靠近*P*0处趋向生成较好的逼近，而第二个递推公式在靠近*Pn*处趋向生成较好的逼近

### Bezier曲面(不考)

#### 定义

设$P_{ij}(i=0,1,...,m;j=0,1,...,n)$为$(m+1)\times (n+1)$个空间点列，则    $m\times n$次张量积形式的Bezier曲面定义为：

![image-20220213203141710](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213203141710.png)

其中$B_{i,m}(u),B_{j,n}(v)$是Bernstein基函数。

依次用线段连接点列$P_{ij}(i=0,1,...,m;j=0,1,...,n)$中相邻两点所形成的空间网格，称之为特征网格。

矩阵表示式是

![image-20220213203322817](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213203322817.png)

在一般实际应用中*m*,*n* 不大于4

#### 性质

> 几何不变性。
>
> 对称性。
>
> 凸包性。 

**除变差缩减性质**外，Bezier曲线的其它性质可推广到Bezier曲面：

曲面特征网格的四个角点正好是Bezier曲面的四个角点，即![image-20220213203428766](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213203428766.png)

曲面特征网格最外一圈顶点定义曲面的四条边界；

#### 曲面的拼接

设两张*m*×*n*次Bezier曲面片

![image-20220213203701325](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213203701325.png)

分别由控制顶点Pij和Qij定义。

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213204344724.png" alt="image-20220213204344724" style="zoom:80%;float:left" />

#### 递推算法

![image-20220213204655145](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220213204655145.png)

## 第三章——B样条曲线与曲面

Bezier曲线缺陷：

> **缺乏灵活性**：一旦确定了多边形的顶点数，就确定了曲线的阶数；
>
> **控制性差**：当顶点数较多，曲线的阶次将比较高，此时，特征多边形对曲线形状的控制将明显减弱；
>
> **不易修改**：由曲线的方程可看出，其Bernstein基函数的值在开区间(0,1)内不为零。因此，所定义之曲线(0<*t*<1)在区间内的任何一点均要受到全部顶点的影响，这使得对曲线进行局部修改成为不可能。

**B样条曲线**：为克服Bezier曲线的缺陷，Gordon等人拓展了Bezier曲线，从外形设计的需求出发，希望新曲线易于进行局部修改、更逼近特征多边形、低阶次曲线

于是，用*k*阶B样条基函数替换了Bernstein基函数，构成了称之为B样条曲线的新型曲线。

### B样条的递推定义与性质 

#### 基本概念

半开区间$[t_i,t_{i+1}]$ 是第*i+1*个节点区间；

集合*T*称为**节点矢量**；

**重节点**：如果一个节点*ti*出现*r*次 (即$t_i=t_{i+1}=...=t_{t+r-1},r>1$),*ti* 是重复度为*r*的多重节点

#### 定义

![image-20220214143500352](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214143500352.png)

$P_i(i=0,1,...,n)$是控制多边形的顶点

$N_{i,k}(t)(i=0,1,...,n)$称为k阶(k-1次)B样条基函数

多种基函数的定义：![image-20220214143708173](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214143708173.png)

#### de Boor-Cox递推定义

第*i*个*k*阶（基函数度数）B-样条基函数$N_{i,k}(t)$

![image-20220214143907691](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214143907691.png)

约定$\frac{0}{0}=0$

通常称为*de Boor-Cox*递归公式；

如果次数为零(*k*= 1)，这些基函数都是阶梯函数。

![image-20220214154954575](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214154954575.png)

#### <mark>特殊观察</mark>

:one: 基函数$N_{i,k}(t)$在$[t_i,t_{i+k})$上非零；

:two: 在任何一个节点区间$[t_i,t_{i+	1})$, 最多有*k*个(*k*-1)次基函数非零：$N_{i-k+1,k}(t),N_{i-k+2,k}(t),...,N_{i,k}(t)$

![image-20220214161607989](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214161607989.png)

#### 性质

$N_{i,k}(t)$是t的k阶多项式

:one: **局部支撑性**：$N_{i,k}(t)$是在$[t_i,t_{i+k})$上的非零多项式

![image-20220214162124034](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214162124034.png)

:two:  **权性**(**单位分解** )

![image-20220214162230256](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214162230256.png)

:three: **微分公式**

![image-20220214162249351](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214162249351.png)

:four: **非负性**：对所有的*i*,*k*和*t*, $N_{i,k}(t)$是非负的

:five: <mark>重要结论</mark>

基函数$N_{i,k}(t)$是(*k-1*)次多项式的复合曲线，连接点在$[t_i,t_{i+k})$上的节点处；

在重复度*r*的节点处，基函数$N_{i,k}(t)$是$C^{k-r-1}$连续的；

<mark>如果节点数目是(*m*+1),函数的阶数是*k*,控制点的个数是(n+1)，则*m*=(*n*+*k*)，即**节点数等于控制点数+阶数**</mark>

:question: 五个控制顶点的三次B样条曲线由几个节点构成

> 5+4=9
>
> 注意阶数=次数+1

#### B样条曲线类型的划分

两个标准：**首末节点是否重合**和节点的分布情况。

:one: 首末节点是否重合

**开曲线**：曲线不会与控制折线的第一边和最后一边接触；图1

**闭曲线**：第1个节点和最后1个节点是重复节点。

> –Clamped：第一个节点和最后一个节点必须是重复度为*k* ；图2
>
> –Closed：重复某些节点和控制点。图3

![image-20220214163341383](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214163341383.png)

:two: 节点的分布情况

假定控制多边形的顶点为$P_i(i=0,1,...n)$，阶数为k（次数为k-1），则节点矢量为$T=[t_0,t_1,...,t_{n+k}]$

**均匀样条曲线**

> 节点矢量中节点为沿参数轴均匀或等距分布，所有节点区间长度为常数。这样的节点矢量定义了均匀的B样条基
>
> ![image-20220214164108581](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214164108581.png)
>
> 节点矢量为[0, 1/8, 2/8, 3/8, 4/8, 5/8, 6/8, 7/8, 1]

**准均匀样条曲线**

> 两端点的重复度为*k*,内部其它节点呈均匀分布，且重复度为1。
>
> 端点过特征多边形的端点
>
> ![image-20220214164310578](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214164310578.png)
>
> 节点矢量为[0, 0, 0, 0.2, 0.4, 0.6, 0.8, 1, 1, 1]

**分段Bezier曲线**

> 节点矢量中两端节点具有重复度*k*，所有内节点重复度为*k*-1，这样的节点矢量定义了分段的Bernstein基。
>
> ![image-20220214164416878](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214164416878.png)
>
> 图中有7个控制顶点，n=6，阶数为4，因此节点数为6+4+1=11，节点矢量为$T=[t_0,t_1,...,t_{10}]=[0,0,0,0,0.5,0.5,0.5,1,1,1,1]$

**一般的非均匀B样条曲线**

### B样条曲线的性质

#### <mark>局部性</mark>

:one: k阶B样条曲线上参数为$t\in [t_i,t_{i+1}]$的一点至多与*k*个控制顶点$P_j(j=i-k+1,...i)$有关，与其它控制顶点无关；

:two: $P_i$只影响在区间$[t_i,t_{i+k})$上的曲线*P*(*t*)；

> 基函数$N_{i,k}(t)$在$[t_i,t_{i+k})$上非零；

:three: 基函数$N_{i,k}(t)$在区间$[t_i,t_{i+k})$上都是次数不高于(*k*-1)的多项式。

:question: <mark>改变一条以P0,P1,…,P9为控制顶点的4阶B样条曲线的一个顶点P5，有几段曲线的形状会改变?</mark>

> P5影响在区间$[t5,t9)\in[t3,t10]$上的曲线，影响了4段曲线[t5,t6)、[t6,t7)、[t7,t8)、[t8,t9)
>
> <mark>注意看定义域,可能有陷阱</mark>

#### <mark>开曲线定义域</mark>

有*k*个基函数的支持，定义域是$[t_{k-1},t_{n+1}]$(k-1是次数，n+1是控制顶点数)

**举例**

使用节点向量*T*={0,0.25,0.5,0.75,1},如果基函数是2阶的(即*k*=2),那么有三个基函数*N*0,2(*t*),*N*1,2(*t*)和*N*2,2(*t*)；

第一个和最后一个节点区间只有一个非零基函数，而第二和第三节点区间(即[0.25,0.5)和[0.5,0.75))有两个非零基函数。

节点区间[0,0.25)和[0.75,1)没有基函数的“完全支持”。

一般来说，区间$[t_0,t_{k-1})$和$[t_{n+1},u_{n+k}]$不会有基函数的“完全支持”，当B样条曲线是开曲线时被忽略。

#### 凸包性

![image-20220214203644625](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214203644625.png)

#### 贝塞尔曲线是B样条曲线的特例

![image-20220214203706151](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214203706151.png)

#### 分段参数多项式

P(t)在每一区间上都是次数不高于k-1的参数t的多项式，因此P(t)是参数t的次数不高于k-1的分段多项式。

#### 连续性

![image-20220214203741056](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214203741056.png)

#### 导数公式

![image-20220214203827223](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214203827223.png)

#### 变差缩减性

![image-20220214203911117](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214203911117.png)

#### 仿射不变性

![image-20220214203927881](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214203927881.png)

即在仿射变换下，P(t)的表达式具有形式不变性。

如果一个仿射变换应用于B样条曲线，得到的结果可以从它的控制点的仿射像构建得到。

#### 几何不变性

由于定义式所表示的B样条曲线是参数形式，因此，B样条曲线的形状和位置与坐标系选择无关。

#### 直线保持性

控制多边形退化为一条直线时曲线也退化为一条直线

#### <mark>习题</mark>

:one: 五个控制顶点的三次B样条曲线由几个节点构成

> 5+4=9

:two: 一条以P0,P1,P2,P3,P4为控制顶点的4阶(三次)B样条曲线，其节点向量为{0,0,0,1,2,3,4,4, 4},则其定义域为?

![image-20220214204856268](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214204856268.png)

:three: 由五个控制顶点所决定的3次B样条曲线，由几段3次B样条曲线段光滑连接而成？

> 定义域是$[t3,t5]$，有两段连接

:four: 改变一条以P0,P1,…,P9为控制顶点的4阶B样条曲线的一个顶点P5，有几段曲线的形状会改变?

> ![image-20220214205412561](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214205412561.png)
>
> P5影响在区间$[t5,t9)\in[t3,t10]$上的曲线，影响了4段曲线[t5,t6)、[t6,t7)、[t7,t8)、[t8,t9)

### De Door算法（了解）

![image-20220214211029249](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214211029249.png)

de Boor 算法的递推关系如图

![image-20220214211044987](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214211044987.png)

### 三次B样条的Bezier表示（了解）

![image-20220214211300521](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214211300521.png)

### 节点插入算法

进一步改善B样条曲线的局部性质，提高曲线的形状控制的灵活性，可实现对曲线的分割等

给定一条*k*阶B样条曲线$P(t)=\underset{i=0}{\overset{n}{\sum}}P_i N_{i,k}(t) $，B样条基由节点矢量$T={[t_0,t_1,...,t_{n+k}]}$完全决定

插入一个节点

> 在定义域某个节点区间$[t_i,t_{i+1}]$内插入一个节点*t*，得到新的节点矢量：$T^1={[t_0,t_1,...,t_i,t,t_{i+1},...,t_{n+k}]}$
>
> 重新编号成为：$T^1={[t_0^1,t_1^1,...,t_i^1,t_{i+1}^1,t_{i+2}^1,...,t_{n+k+1}^1]}$

新节点矢量*T*1决定了一组新B样条基$N_{i,k}^1(t),i=0,1,...,n+1$。原始的曲线可用这组新的B样条基与未知新顶点 $P_i^1$表示

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214211939434.png" alt="image-20220214211939434" style="zoom: 80%;" />

未知新顶点的计算公式(Boehm)

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214212004664.png" alt="image-20220214212004664" style="zoom:80%;" />

**算法过程**

![image-20220214212253869](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214212253869.png)

### B样条曲线的优点

优点：

可以是贝塞尔曲线；满足贝塞尔曲线有的所有重要性质；提供了**比贝塞尔曲线更灵活的控制**

> 曲线的次数与控制点数目是分开的，可使用更低次曲线而仍然保持很多控制点；
>
> 可以改变一个控制点位置而不会全局地改变整个曲线形状； 
>
> 还有其他设计和编辑形状的技术比如改变节点。 

B样条曲线仍然是多项式曲线，而**多项式曲线不能表示许多有用的简单的曲线比如圆和椭圆**。

### B样条曲面

![image-20220214212442489](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220214212442489.png)



## 第四章——真实感图形学

生成三维场景的真实图形的步骤：

> :one: 建立景物的几何模型；
>
> :two: 进行取景变换和透视变换；
>
> :three: 进行消隐处理；
>
> :four: 进行真实感图形绘制。

真实感图形学：

> 研究如何用计算机生成三维场景的真实感图形图像。
>
> 根据假定的光照条件和景物外观因素，依据一定的光照模型，计算可见面投射到观察者眼中的光强度大小，并将它转换成适合图形设备的颜色值，生成投影画面上每一个象素的光强度，使观察者产生身临其境的感觉。

应用：

> 真实产品外形设计；
>
> 飞行驾驶模拟训练；
>
> 动画制作、城市规划、医学气象等。

特点：

> 表现物体质感；
>
> 真实反映物体表面颜色和亮度；
>
> 能模拟透明物体的透明效果和镜面物体的镜像效果；
>
> 能通过光照下物体的阴影，改善场景的深度感和层次感。

影响真实感图形的因素:

> 真实物体本身形状；
>
> 物体表面特征：材质、感光度和纹理等；
>
> 照射物体的光源；
>
> 物体与光源相对位置；
>
> 物体周围环境。

如已知场景的光照明效果的物理**模型**，则可用计算机模拟真实世界。

观察者对图像光函数的亮度响应，通常采用光场的瞬时光亮度计量：

![image-20220215165948574](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215165948574.png)

$I(x,y,t,\lambda)$表示成像**平面的空间辐射能量**；

$V_s(\lambda)$代表相对光效函数，即人视觉的光谱响应。

生成具有真实感的图像，关键在于$I$的计算：核心在于如何仿真光源发出的光线在物体间的传播

的照明效果包括**反射**、**透射**、**折射**、**表面纹理**和**阴影**等。

**光照明模型**：已知物体物理形态和光源性质的条件下，能计算出场景光照明效果的数学模型。

> 可以用描述物体表面光强度的物理公式推导出来；
>
> 实用价值模型：实际光照效果的不同层次的简化；
>
> 早期模型(基于经验)：只反映光源直接照射的情况；
>
> 精确的模型：模拟物体之间光的相互作用。

## 第四章——颜色视觉

要产生具有高度真实感的图像，颜色是最重要的因素。

颜色是外来的光刺激作用于人的视觉器官而产生的主观感觉，影响的因素有：

> 物体本身；
>
> 光源；
>
> 周围环境；
>
> 观察者的视觉系统。

### 基本概念

#### 光源(了解)

**点光源**，如果光源大小比场景中的物体小得多，可以假定光线是从一个点向四周均匀发散的，最简单的模型。

**线光源**，可以看作是多个点光源在一维空间上的合成，例如模拟荧光灯管这类长条形的光源。

**面光源**，即可以看作线光源在高一维空间的合成，也可看作点光源在二维空间的合成。它可以用来模拟发光的块状物体。

#### 颜色类型

非彩色：黑色、白色和各种不同深浅的灰色；

彩色：指黑白系列以外的各种颜色

#### 颜色的属性

非彩色只有一个属性：明度（图）

彩色具有三属性：（常称颜色的心理三属性）

#### <mark>颜色的三个视觉特性(心理学属性）</mark>——HSV

**色调(Hue) ；**

**饱和度(Saturation) ；**

**亮度(Value)。**

#### <mark>颜色的物理特性</mark>

**主波长（Dominant Wavelength)**：产生颜色光的波长，对应于视觉感知的色调；

**纯度(Purity)**：对应于饱和度；

**明度(Luminance)**：对应于光的亮度。

#### 色调

一种颜色区别于其他颜色的因素

单色光：对应着它的波长；

复色光：比例最大的单色光的波长（主波长）；

人眼可分辨的光谱色有100多种，谱外色30多种，共计130多种。

#### 色调环

同类色：相距15°以内；

邻近色：相距15°～45°以内；

对比色：位于100°～197°之间；

互补色：相距180°。

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215170946067.png" alt="image-20220215170946067" style="zoom:67%;" />

#### 辨认阈限

人的视觉在辨认波长的微小变化方面的能力。

![image-20220215171014127](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215171014127.png)

在可见光谱的两端，人眼对波长变化的反应能力近乎迟钝，特别是在波长大于655nm及小于430nm的区域，人眼几乎无法分辨颜色上的差别。

#### 亮度

人眼所能感受到色彩的明暗程度，是与人的心理、生理有关的一个属性。

单色光:光线越强，其色彩越明亮；

物体表面的光辐射率越高，亮度越高；发光体的明度越高，亮度越高。

白颜料是反射率极高的物质：如果在其它颜料中加入白色，可以提高混合色的亮度；加入黑色，可以降低混合色的亮度。

#### 饱和度

颜色的纯度

单色光的饱和度最高；

复色光的波长范围越窄，光色越饱和；

色料中含灰分的比例低，则其饱和度高；

物体色饱和度取决于表面反射光谱色的选择性

![image-20220215171117556](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215171117556.png)

#### 颜色三属性的相互关系

**色调**：色刺激的光谱组成及光谱功率分布峰值的位置；

**亮度**：色刺激的光强；

**饱和度**：最强波长的功率对其它波长占优势的程度；

三者相互独立的但并不单独存在，其变化是相互联系、影响的

**两者**只有在适当**亮度**下才能充分表现出来。

#### 颜色纺锤体

颜色三特性的空间表示：

> 垂直轴线表示白黑亮度变化；
>
> 水平圆周上的不同角度点代表了不同色调的颜色；
>
> 从圆心向圆周过渡表示同一色调下饱和度的提高

![image-20220215171251934](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215171251934.png)

平面圆形上的色调和饱和度不同，而亮度相同

#### 光的物理知识

光是人的视觉系统能够感知到的电磁波

> 波长在400nm到700nm之间 (1nm=10^-9m)。

光可以由它的光谱能量分布$P(\lambda)$来表示

> 白：各种波长的能量大致相等；
>
> 彩色：各波长的能量分布不均匀；
>
> 单色：包含一种波长的能量，其他波长都为零。

能否用光谱能量的分布定义颜色? **不能**

**异谱同色**：**两种光的光谱分布不同而颜色相同的现象**

> <mark>光谱与颜色的对应关系是多对一；</mark>
>
> 须采用其他的定义颜色的方法，使光本身与颜色一一对应。

### 颜色视觉理论

颜色视觉是真实感图形学的生理基础，**颜色**科学中最基本、最重要的理论。

> **恒常性**：根据物体固有的颜色来感知它们，不受外界条件变化的影响。
>
> > 煤是黑的，雪是白的
>
> **混合性**：太阳光通过棱镜后分散成光谱上的颜色光带，证明白光由很多颜色光混合而成。

颜色视觉理论：**三色学说**；**四色学说（对立颜色学说）**；**现代阶段学说**。

#### 三色学说

三色学说的形成：

> Yaung提出某种波长的**光可以通过三种不同波长的光混合而复现出来**的假说:
>
> > 把三种原色按照不同的比例混合就能准确的复现其他任何波长的光；三原色等量混合产生白光。
>
> Maxwell用旋转圆盘证实了Yaung假设。
>
> 1862年，Helmhotz提出三色学说。

**三色原理**：用三种原色能够产生各种颜色

> 当今颜色科学中最重要的原理和学说；
>
> **RGB颜色模型提出的理论基础。**

**(近代)三色学说**

视网膜上含有三种不同类型的锥体细胞，分别含有感**红、绿和蓝**三种视色素，具有各自的光谱吸收率；

![image-20220215171804245](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215171804245.png)

三种色素按各自的吸收特性吸收外界光辐射后，产生光化学反应，刺激视神经，通过神经中枢传递给大脑产生综合颜色感觉。

三色学说解析：

> **现代解剖学**证实了视锥细胞分为红视锥细胞、绿视锥细胞与蓝视锥细胞。
>
> **彩色感觉**：感红色素兴奋时产生红色感觉，感红感绿色素同时兴奋时，大脑产生黄色感觉，两者按比例变化产生橙色或黄绿感觉。
>
> **白色和灰色**：三种锥体细胞受到等量刺激时产生自灰到白的感觉。
>
> **杆状细胞**：只含一种紫红色素，只有明暗感觉，不能分辨颜色。

**三色学说**

> **能解释负后像现象**：当眼睛长时间注视某个颜色样品后，撤去该颜色样品的瞬间，在原来样品的位置上会出现于样品颜色互补的颜色感觉，再过一段时间后这个互补的颜色感觉逐渐消失。（红-白）
>
> **不能解释色盲**
>
> > 应有三种色盲：红色盲、绿色盲和蓝色盲，且单独存在。但几乎所有的红色盲也是绿色盲也即红绿色盲；
> >
> > 只有三种感色神经同时兴奋时，才能产生白色与灰色的感觉，色盲者不应该看到白色或灰色；
> >
> > 红绿色盲不应该看到红与绿的混合色即黄色。

#### 四色学说

1864年由赫林提出，颜色对立学说**。**

**四种心理原色**：红、绿、黄、蓝。其它色由这四色混合而成，这四色中的任何一个都不能**由其它色混合得到**。

**三对独立视色素**：红-绿、黄-蓝、黑-白。它们的代谢作用包括建设（同化）和破坏（异化）两种对立的过程。红和绿视色素组合只能得到灰色或白色感觉，即绿刺激抵消红刺激的作用。

![image-20220215172326251](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215172326251.png)

**解释颜色混合现象**：当两种颜色为对立色时，混合时得到白色，这是因为它们对某一对视素的两种对立过程形成平衡的结果。

**能解释负后像现象**：当某一色彩刺激停止时，与该色彩相关的视素的对立过程开始活动，因而产生该颜色对立色，即补色。

**解释色盲现象**：色盲是缺乏一对或两对视色素的结果。即使缺乏两对视色素，导致全色盲，仍然有黑白视色素，有黑白感觉。

**不能解释近代色度学基础**：即不能说明三原色能混合一切色的现象。

#### 现代阶段学说

将颜色视觉的形成分为**两个阶段**

> **视网膜阶段**：在视网膜中存在三种感色的锥体细胞，每种具有不同的光谱敏感特性和单独产生黑白反应。
>
> **视神经传输阶段**：在视觉信息由锥体细胞向大脑的传导过程中，红、绿、蓝反应变成三对独立的神经反应：黑-白、红-绿、黄-蓝，即四色机制。
>
> ![image-20220215172628404](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215172628404.png)

**优点**：统一了三色和四色学说。视网膜阶段解释三色学说，视神经传输阶段解释四色学说。

#### 色光混合定律

1854年H.Grassman总结出颜色混合的基本规律，**格拉斯曼**定律。

人的视觉只能分辨颜色的三种变化：明度、色调、饱和度；

在由两个成份组成的混合色中，如果一个成份连续变化，混合色的外貌也连续变化。导出补色律和中间色律。

> **补色律**：只要一种色光与另一种色光混合能产生白光，这两种色光就是互补色。
>
> **中间色律**：任何两个非互补色混合，便产生中间色，其色调靠近比例较大的色光。
>
> ![image-20220215172916848](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215172916848.png)

**等效率**：外貌相同的色光，无论它们的光谱组成是否一样，在颜色混合中具有相同的效果。导出

**亮度相加定律**：混合色光的总亮度等于组成混合色的各颜色光亮度的总和。

**代替律**

> 两个相同的颜色与另外两个相同的颜色相加混合后，颜色仍然相同：
>
> *A* ≡ *B*， *C* ≡ *D*
>
> *A* ＋*C* ≡ *B* ＋ *D*
>
> 两个相同的颜色每个减去相同的颜色，余下的颜色仍然相同：
>
> *A* －*C* ≡ *B* － *D*
>
> 两个相同的颜色，同时扩大或缩小相同倍数后，两颜色仍相同
>
> n*A* ≡ n*B*

颜色混合三定律：**补色律、中间色律、代替律**统称为颜色混合三定律。

**加色法混合**：混合色的光谱能量分布是每个组成色的光谱能量分布的简单相加，故称为色光相加混合。

> 三原色光：红光、绿光、蓝光。

**减色法混合**：

> 色料：涂染后能够使无色的物体呈色、有色物体改变颜色的物质；
>
> 色料三原色：青、品红、黄；
>
> 混合色为光源光谱成份减去被色料吸收的光谱成份后所剩余的光谱成份引起的颜色视觉。

#### 几种颜色视觉现象

**恒常性**：外界条件发生一定范围的变化后，视觉对物体的颜色感觉仍保持相对稳定的特性；

**适应性**：由于环境光对眼睛的持续作用，致使眼睛对环境光产生一定的抵消作用，而使颜色视觉发生变化的现象；（负后像）

**对比性**：眼睛同时接受相邻不同颜色的刺激，造成颜色视觉发生变化的现象。

### CIE色度图(了解)

CIE：国际照明委员会

三色学说解释了颜色混合现象：任何颜色可用红、绿、蓝按照不同比例混合来得到。

颜色匹配-如何由三原色混合复现给定颜色？

CIE选取标准红、绿和蓝(700, 546, 435.8)。

光的颜色匹配式子：
$$
c=rR+gG+bB
$$
权值*r**、**g**、**b*为颜色匹配中所需要的三色光的相对量（三刺激的值）

#### RGB系统

1931年CIE给出等能标准三原色匹配任意颜色的光谱三刺激值曲线。(CIE-RGB系统)

![image-20220215173747105](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215173747105.png)

CIE-RGB曲线**一部分三刺激值是负数**：

> 在给定的光上叠加曲线中负值对应的原色，来匹配另外两种原色的混合；
>
> 不能单靠混合RGB来匹配对应的光。

#### XYZ系统

1931年CIE规定了三种假想的标准原色(X, Y, Z)，构造了CIE-XYZ系统

颜色匹配函数的三刺激值为正值。

![image-20220215173826168](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215173826168.png)

CIE-XYZ系统的光颜色匹配函数的定义如下：
$$
c=rX+gY+bZ
$$
任何颜色都能由标准三原色混合匹配；

解决了颜色匹配问题。

#### 色度图

三维颜色空间：由三原色的单位向量所定义

> 三刺激空间：一个颜色刺激可表示为三维空间中的一个以原点为起点的**向量**
>
> 为了在二维空间中表示颜色，在三维坐标轴上对称的取一个截面，该截面通过三个坐标轴上的单位向量
>
> (X)+(Y)+(Z)=1

**CIE-XYZ系统**

色度图：截面与三个坐标平面的交线构成一个等边三角形。

颜色（刺激向量）与色度图有唯一交点，空间坐标(x,y,z)表示为该颜色在标准原色下的三刺激值，称为色度值：

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215174048564.png" alt="image-20220215174048564" style="zoom:80%;" />

![image-20220215174058075](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215174058075.png)

两个独立变量，可进行投影。

翼形轮廓线代表所有可见光波长的轨迹，即可见光谱曲线。

沿线的数字表示该位置的可见光的主波长。

中央的C对应于近似太阳光的标准白光，C点接近于但不等于x=y=z=1/3的点。

红色区域位于图的右下角，…,连接光谱轨迹两端点的直线称为紫色线。

![image-20220215174115338](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215174115338.png)

**CIE色度图用途**

> **获得互补色**：从该颜色点过C点作一条直线，可得到补色的波长。
>
> **确定所选颜色的主波长和纯度**：
>
> > A点：过点C作直线与光谱曲线相交于B，颜色A可表示为纯色光B和白光C的混合，B就定义了颜色A的主波长；
> >
> > F点：如交点在紫色线上，用其补色(B)的波长加后缀c表示。
>
> **定义一个颜色域**：通过调整混合比例，任意两种颜色。
>
> I和J加在一起能够产生它们连线上的颜色。
>
> 加入第三种颜色K，就产生三者构成的三角形区域的颜色。
>
> ![image-20220215174227168](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215174227168.png)

应用较复杂，需要引入其它颜色系统-颜色模型

### 常用颜色模型

颜色模型：某个三维颜色空间中的一个可见光子集，包含某个颜色域的所有颜色：

> 用途：在某个颜色域内方便地指定颜色；
>
> 在某种特定环境中对颜色的特性和行为的解释方法；
>
> <mark>**没有一种颜色模型能解释所有的颜色问题**</mark>，可使用不同模型帮助说明所看到各种颜色特征。

<mark>**常用的颜色模型**</mark>

> 彩色CRT显示器：**RGB模型**。
>
> 印刷行业：**CMY模型**。
>
> 面向用户的模型：以易用性为目的，为用户提供更直觉的颜色参数，例如**HSV模型。**
>
> 用于彩色广播电视系统的模型：
>
> > YUV模型用于PAL制式的电视系统；
> >
> > YIQ模型用于NTSC制式的电视系统；
> >
> > YCbCr模型由YUV颜色模型派生而来，主要用于数字电视系统中。

#### 两种原色混合系统

基于Red、Green和Blue三原色定义**RGB加色系统**；

基于青（Cyan）、品红（Magenta）和黄（Yellow）**CMY减色系统**；

**两种系统的颜色互为补色**：青-红、品红-绿、黄-蓝，习惯上把红绿蓝作为原色

![image-20220215174702033](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215174702033.png)

#### RGB颜色模型

基于红绿蓝三原色定义加色系统；

采用三维直角坐标系，RGB立方体；

每个彩色点采用(R,G,B)表示，[0,1]或[0，255]。

所覆盖的颜色域取决于显示设备荧光点的颜色特性，与其它硬件无关。

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215175155963.png" alt="image-20220215175155963" style="zoom:67%;" />

#### CMY颜色模型

基于**青、品红、黄**的减色系统；

常用于从白光中滤去某种颜色；

对RGB模型的直角坐标系的子空间作下述变换即可获得CMY颜色模型直角坐标系的子空间：

C=1-R、M=1-G、Y=1-B

![image-20220215175355951](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215175355951.png)

印刷硬拷贝设备的颜色处理：在白纸面上涂黄色和品红色，纸面上将呈现红色, 因为白光被吸收了蓝光和绿光，只能反射红光

RGB颜色模型与CMY颜色模型都是面向硬件模型。

#### HSV颜色模型

HSV**（**Hue Saturation Value）颜色模型是面向用户模型，该模型对应于圆锥形：

圆锥的顶面对应于V=1（亮度）

色度H由绕V轴的旋转角给定

饱和度S取值从0到1，由圆心向圆周过渡。

> 顶面包含RGB模型中三个面；
>
> 纯色：最大顶面圆；
>
> 圆锥顶点，H，S无定义；
>
> 圆锥顶面中心H无定义；
>
> 一种颜色与补色差180度。

![image-20220215175734314](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215175734314.png)

HSV模型对应画家的配色的方法：用改变色浓和色深的方法从某种纯色获得不同色调的颜色

## 第四章——简单光照明模型

**光源**

> 发射光源：反射表面
>
> > 通常在一个不透明且不发光的物体表面所观察到的光线是其反射光，由光源与其他物体表面的反射光所共同产生。
>
> 光源向四周所辐射光的光谱分布
>
> > **漫反射**：投射在粗糙表面上的光向各个方向反射的现象。物体颜色实际上是入射光线被漫反射后所表现出来的颜色；
> >
> > **镜面反射**：一束平行光射到平面镜上,反射光是平行的 。
>
> 空间的光亮度分布
>
> > 图形学：光源通常朝空间各个方向发射的光强是相同的。

**材质**

> 材质的颜色是由它所反射的光的波长决定；
>
> 如果光线被投射到一个不透明的物体表面，则部分光线被反射，部分被吸收：
>
> > 物体表面的材质类型决定了反射光的强弱；
> >
> > 表面光滑较亮的材质将反射较多的入射光，比较暗的表面则吸收较多的入射光。
>
> 对于一个半透明的物体表面，部分入射光会被反射，部分则被折射。

光照射到物体表面，可能被吸收、反射和透射

> 被吸收的部分转化为热；
>
> 反射、透射光进入人的视觉系统。

**光照明模型**：模拟物体表面的光照明物理现象的数学模型。

**简单光照明模型**

> 只考虑光源对物体的直接光照；
>
> 景物表面常被假定为不透明，且具有均匀反射率；
>
> 能表现由光源直接照射在漫射表面上形成的连续明暗色调，镜面上的高光以及由于景物互相遮挡而形成的阴影等。
>
> <mark>只考虑反射，不考虑折射</mark>

**发展历程**

> 1967年，Wylie等人第一次在显示物体时加进光照效果，并假设光强与距离成反比；
>
> 1970年，Bouknight提出第一个光反射模型：Lambert漫反射＋环境光；
>
> 1971年，Gouraud提出漫反射模型加插值的思想；
>
> 1975年，Phong提出图形学中第一个有影响的光照明模型。

### 相关物理知识

#### 光的传播

**反射定律**：入射角等于反射角，而且反射光线、入射光线与法向量在同一平面上。

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215202450357.png" alt="image-20220215202450357" style="zoom:67%;" />

**折射定律**：折射线在入射线与法线构成的平面上，折射角与入射角满足
$$
\frac{\eta_1}{\eta_2}=\frac{sin \varphi}{sin \theta}
$$
<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215202701818.png" alt="image-20220215202701818" style="zoom:50%;" />

**能量关系**：在光的反射和折射现象中，能量是守恒的，能量的分布情况满足这样的一个式子：     
$$
I_i =I_d+I_s+I_t+I_v
$$
$I_i$为入射光强，由直接光源或间接光源引起；

$I_d$为漫反射光强，由表面不光滑引起；

$I_s$为镜面反射光强，由表面光滑性引起；

$I_t$为透射光，由物体的透明性引起；

$I_v$为被物体所吸收的光，由能量损耗引起

#### 光的度量

**立体角**：面元*ds*向点光源*P*所张的立体角为：
$$
d \omega =\frac{ds}{r^2}
$$
*r*为点光源到面元中心的垂直距离

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215202945998.png" alt="image-20220215202945998" style="zoom:50%;" />

**点发光强度**

> **光通量**：单位时间内通过面元*ds*的光能量，记为*dF* 。
>
> **发光强度**：点光源的发光强度为某个方向上单位立体角的内的光通量，即
>
> ![image-20220215203113404](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215203113404.png)
>
> 各向同性的点光源，在各个方向上单位立体角内通过的光通量相等，即在各个方向上发光强度相等；
>
> 设发光强度为*I，*则点光源向外辐射的整个光通量为整个球立体角内的光通量，即
>
> ![image-20220215203128929](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215203128929.png)

### Phong光照明模型

光照到物体表面时，物体对光会发生反射、透射、吸收、衍射、折射和干涉。

<mark> 简单光照明模型模拟物体表面对光的反射作用</mark>

> 光源为点光源；
>
> 反射作用分为：**镜面反射和漫反射**；
>
> 物体间作用用**环境光**(Ambient Light)表示；
>
> 典型：Phong光照明模型。

Phong模型中的几何量示意图

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215203255357.png" alt="image-20220215203255357" style="zoom:50%;" />

#### 理想漫反射

**理想漫反射**：当光源来自一个方向时，由于物体表面粗糙不平，导致反射光均匀向各方向传播，而与视点无关。

假设入射光强$I_p $，物体表面上点P 的法向为N,从点P 指向光源的向量为L，两者夹角为$\theta$ ，由Lambert余弦定律，漫反射光强为：

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215203515670.png" alt="image-20220215203515670" style="zoom:67%;" />

 $K_d$是与物体有关的**漫反射系数**  $0<K_d<1$  

当L，N为单位向量时，漫反射光强可表示为：

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215203535714.png" alt="image-20220215203535714" style="zoom: 67%;" />

有多个光源时，上式可进一步表示为

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215203557971.png" alt="image-20220215203557971" style="zoom:77%;" />

反射光颜色：由入射光颜色和物体表面颜色共同决定；

在RGB颜色模型下， 有三个分量，分别代表三原色的漫反射系数，通过调整它们来设定物体的颜色；

可以把入射光强*I*设为三个分量$I_r,I_g,I_b$，通过这些分量的值来调整光源的颜色

#### 镜面反射光

**理想镜面**：反射光集中在一个方向并遵循反射定律。

**光滑表面**：反射光集中在一个范围内，且由反射定律决定的反射方向光强最大。对于同一点，**不同位置观察到的镜面反射光强不同。**

镜面反射光强：

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215203715755.png" alt="image-20220215203715755" style="zoom:80%;" />

> $K_s$是与物体有关的镜面反射系数；
>
> $\alpha$为视线方向*V*与反射方向*R*的夹角；
>
> *n*为反射指数，反映物体表面的光泽程度，一般为1至2000，数目越大物体表面越光滑；

若规范所有向量，则镜面反射光强为：

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215203900045.png" alt="image-20220215203900045" style="zoom:80%;" />

 其中<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215203909918.png" alt="image-20220215203909918" style="zoom:80%;" />

多个光源时，镜面反射光强为：

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215203924720.png" alt="image-20220215203924720" style="zoom:80%;" />

镜面反射光将会在反射方向附近形成很亮的光斑，称为**高光现象**；

镜面反射光产生的高光区域**只反映光源的颜色**； 

镜面反射系数  是一个与物体的颜色无关的参数； 

只能通过改变物体的漫反射系数来控制物体的颜色。 

#### 环境光

**环境光**：光源间接对物体施加的明暗影响，是在物体和环境之间多次反射，最终达到平衡时的一种光

同一环境下的环境光光强均匀分布，即在任一方向上的分布相同；

在简单光照明模型中，近似表示为：
$$
I_e=I_a.K_a
$$


> $I_a$  ：为环境光的光强；
>
> $K_a$：为物体对环境光的反射系数。

**Phong光照明模型**：由物体表面上一点*P*反射到视点的光强$I$为环境光的反射光强$I_e$、理想漫反射光强$I_s$和镜面反射光$I_d$的总和
$$
I=I_aK_a+I_pK_d(L.N)+I_pK_s(R.V)^n
$$

> $K_d$是与物体有关的**漫反射系数**  $0<K_d<1$  
>
> 入射光强$I_p $
>
> $I_a$ 为环境光的光强；
>
> 物体表面上点P 的法向为$N$,从点P 指向光源的向量为$L$，两者夹角为$\theta$ 

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215204641045.png" alt="image-20220215204641045" style="zoom:67%;" />

Phong模型：对物体表面上的每个点*P*，均需计算光线的反射方向*R*，再由*R*计算(*R*•*V*)。假设：

光源在无穷远处，即*L*为**常向量**；

视点在无穷远处，即*V*为**常向量**；

(*H*•*N*)近似(*R*•*V*) ，*H*为*L*与*V*的平分向量：$H=\frac{L+V}{|L+V|}$。

对所有的点总共只需计算一次*H*的值

结合RGB颜色模型，Phong光照明模型

![image-20220215210529076](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215210529076.png)

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215210544111.png" alt="image-20220215210544111" style="zoom:67%;" />

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215210556136.png" alt="image-20220215210556136" style="zoom:67%;" />

**Phong光照明模型**：真实感图形学中提出的第一个有影响的光照明模型,生成图像的真实度已达到可以接受的程度。

由于是经验模型，Phong模型存在不足：

> 显示出的物体像塑料，无质感变化；
>
> 环境光是常量，没有考虑物体间相互反射光；
>
> 镜面反射颜色是光源颜色，与材质无关；
>
> 镜面反射的计算在入射角很大时会产生失真现象。

### 增量式光照明模型

由于光源和视点均被假定为无穷远，Phong模型光强计算公式是物体表面法向量的函数。

用多边形表示的物体

> 每个多边形由于法向一致，多边形内部颜色相同；
>
> 不同法向的多边形邻接处光强突变且有**马赫带效应**
>
> > 1868年由奥地利物理学家 E.马赫发现的一种明度对比现象：人们在明暗交界处感到亮处更亮，暗处更暗的现象；
> >
> > **生理学的解释**：人类的视觉系统有增强边缘对比度的机制

增量式光照明模型：

> 在每个多边形顶点处计算光照明强度或参数，然后在各个多边形内部进行双线性插值，得到多边形光滑均匀颜色分布；
>
> 保证多边形之间的颜色光滑过渡。

<mark>**两个主要算法**</mark>(要会实质和步骤)

> 双线性法向插值：Phong明暗处理
>
> 双线性光强插值：Gouraud明暗处理

#### Gouraud双线性光强插值

Gouraud于1971年提出，又被称为Gouraud明暗处理；

**思想**：<mark>计算多边形各顶点的光强，再用双线性插值，求出多边形内部各点的光强</mark>

<mark>实质是：双线性光强插值</mark>

<mark>**算法步骤的基本描述**</mark>

> :one: 计算多边形顶点的平均法向；
>
> :two: 用简单光照明模型计算顶点的平均光强；
>
> :three: 插值计算离散多边形边上的各点光强；
>
> :four: 插值计算多边形内域中各点的光强。

##### 顶点的计算

与某个顶点相邻的所有多边形的法向平均值近似作为该顶点的近似法向量；

顶点A相邻的多边形有k个，它的法向量计算为：

![image-20220215211330115](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215211330115.png)

计算出的平均法向一般与该多边形物体**近似曲面的切平面**比较接近。

##### 顶点平均光强计算

用Phong光照明模型及平均法向量计算在顶点A处的光强；

Gouraud提出明暗处理方法时，还未出现Phong模型，采用：

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215211359606.png" alt="image-20220215211359606" style="zoom:67%;" />

> r是光源到顶点的距离；
>
> *l*是防止分母趋于0的变量

**双线性光强插值**：线性插值与扫描线算法相互结合，用增量算法实现各点光强的计算

由顶点的光强插值计算各边的光强，然后由各边的光强插值计算出多边形内部点的光强：

![image-20220215211632353](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215211632353.png)

##### 增量算法

![image-20220215213252705](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215213252705.png)

**双线性光强插值**

> 计算速度比以往的简单光照明模型有了很大的提高，**解决了相邻多边形之间的颜色突变问题**，产生的真实感图象颜色过渡均匀，图形显得非常光滑；
>
> 由于采用**光强插值，镜面反射效果不太理想**，而且相邻多边形的边界处的马赫带效应不能完全消除。

#### Phong双线性法向插值

<mark>实质是双线性法向插值,计算量比Gouraud大</mark>

以时间为代价，可以部分解决上述的弊病； 

将镜面反射引进到明暗处理中，解决了高光问题

<mark>**Phong双线性法向插值特点**</mark>

> 保留双线性插值，对多边形边上的点和内域各点，采用**增量法**；
>
> 对顶点的法向量进行插值，而原顶点的法向量，仍用相邻多边形的法向作平均；
>
> 由插值得到法向，来计算多边形每个象素的光强度；
>
> 假定光源与视点均在无穷远处，**光强只是法向量的函数**。

方法与光强插值类似，其中的光强项用法向量项来代替。基本公式：

![image-20220215212355071](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215212355071.png)

增量插值计算也类似，用法向代替光强。

#### 两种模型的评价

两类模型的特点：

> 光强插值能有效的显示漫反射曲面，计算量小；
>
> 法向插值可产生正确的高光区域，但计算量大。

增量式光照明模型的不足：

> 此模型得到的物体边缘轮廓是折线段而非光滑曲线；
>
> 由于透视原因，等间距扫描线会产生不均匀效果；
>
> 插值结果决定于插值方向。

### 阴影

阴影

> 阴影是现实生活中一个很常见的光照现象；
>
> 在真实感图形学中，通过阴影可以反映出景物之间的相对位置，增加图形的立体效果和场景的层次感；
>
> 在建筑、航天飞行器设计的供热、太阳能计算等领域均有重要的应用

#### 相关术语

**接受物**：可能接受光源照射的物体 。<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215213927904.png" alt="image-20220215213927904" style="zoom:67%;float:right" />

**本影**：任意一点均无法观察到光源任何部分。

**半影**：任意一点可观察到部分光源。

**阴影**：即任意一点不能完全地观察到整个光源。

**遮挡物**：可遮挡光源中任意一点的物体。

#### Hard 阴影 vs Soft阴影

Hard阴影：点光源照射下，阴影问题是个二值状态

> 在计算机图形学中，很容易生成点光源，并且有一些生成Hard阴影的实时算法；
>
> Hard阴影真实感较差。

Soft阴影：几乎不存在真正意义上的点光源

> 如太阳，其实也不是真正意义上的点光源，其所对应的阴影也不属于Hard阴影；
>
> 对于非点光源，计算本影和半影区域是非常复杂的过程。

![image-20220215214132261](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215214132261.png)

#### 阴影分类

**自身阴影**：光源被景物遮挡而在该景物本身；

**投影阴影**：在其后面产生的较暗的区域。

![image-20220215214207930](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215214207930.png)

##### 自身阴影

点光源下，生成产生具有自身阴影的步骤：

:one: 将视点移到光源位置，将景物的面分成向光面和背光面；

:two: 将视点移到原来的观察位置，对景物的向光面和背光面进行消隐，选用一种光照模型计算景物各面的亮度

:three: 如果面在阴影区域，那么该面的光强就只有环境光那一项，其他的那几项光强都为零，否则就用正常的模型计算光强。

阴影算法与消隐算法相似：

> 消隐算法是根据视点看过去确定哪些面是可见的（前向面）或是不可见的（后向面）
>
> 而阴影算法则要确定哪些面从光源位置看过去是亮的（向光面）或暗的（背光面）。

从原理上，自身阴影面的求取只要简单地对消隐算法作出一点改造：

> 消隐算法中根据视向确定的那些后向面就是阴影算法中根据光源方向确定的那些背光面（自身阴影面）。

##### 投影阴影

投射阴影的区域和形态与光源及景物的形状有很大的关系；

在光源的照射下，景物A在屏幕上产生了3个区域：**本影区**、**半影区**和**无影区**。

![image-20220215214416528](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215214416528.png)

投射阴影区域：实际上是将光源作为观察方向时景物在与光源反向的某一平面上的落影区；

投射平面可以是场景中另一**景物的表面**或是一个**非场景范畴的基面**，如建筑物所在的地平面或屏幕等。

##### 经典的三种本影阴影方法

:one: 投影阴影；

:two: 阴影图(Shadow Map)的方法；

:three: 阴影体(Shadow Volume)的方法。

## 第四章——纹理和纹理映射

<font color="red">**本节了解即可**</font>

简单光照明模型的缺陷

只能模拟光滑景物表面：

> 只考虑表面法向的变化；
>
> 假设表面反射系数为常数。

如何解决计算机生成真实感图象缺乏现实物体表面细节的问题

> 引入纹理，增强各种光照明模型生成图像的真实感。

**纹理**：物体表面的细小结构。

纹理：

> 最早的工作：Catmull 74年的博士论文，是曲面分割方法中的副产品[Cat74]；
>
> 可以较好地表达模型表面的细节,而无需考虑其它（几何和材质）细节，使景物更真实。

常见的纹理：

> 木材表面的木纹；
>
> 建筑物墙壁上的装饰图案；
>
> 桔子皮表面的皱纹

### 纹理概述

使用纹理需要考虑的三个问题：

> 怎样才能产生纹理效果；
>
> 如何定义纹理；
>
> 如何进行映射。

:one: 怎样才能产生纹理效果？

![image-20220215220218538](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215220218538.png)

> 改变反射系数来改变物体的颜色；
>
> 改变物体表面的法向量。

:two: 纹理定义：

> **图像纹理**：将纹理图案映射到三维物体表面，绘制物体表面上一点时，采用相应纹理图案中相应的颜色。
>
> **函数纹理**：用数学函数定义简单的纹理图案；
>
> 用数学函数定义随机高度场，生成表面粗糙纹理。

:three: 映射：把纹理图象值映射到三维物体表面的技术

> 图像纹理：建立二维纹理坐标与三维物体坐标之间的对应关系；
>
> 几何纹理：如何扰动法向量。

三个空间

> **纹理空间**:纹理通常定义在二维空间(u,v)中的一个矩形区域；
>
> **景物空间**:物体表面是在三维空间(x,y,z)中的一个曲面，或参数空间 (s∈[0,1],t∈[0,1]），为二维空间的一个矩形区域；
>
> **图象空间**，图象空间依赖于显示器的分辨率，例如，Nx∈[0,1024]，Ny∈[0,768]，也是二维空间的一个矩形区域。

### 二维纹理映射

颜色纹理：实际上是二维数组，元素是一些颜色值（纹理元素或纹理像素）<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215220605696.png" alt="image-20220215220605696" style="zoom:67%;float:right" />

> 每个纹理像素在纹理空间中都有一个唯一的地址；
>
> 该地址可被认为是一个列和行的值，分别由u和v来表示。

#### 定义方法 

:one: 连续法——函数纹理

> 用数学函数解析地表达，函数的定义域就是纹理空间。

:two: 离散法——图像纹理

> 用各种数字化图像来离散定义；
>
> 纹理空间坐标系中表示光亮度值的矩形数组:
>
> > 程序生成；
> >
> > 扫描输入；
> >
> > 通过交互式系统绘制得到。

#### 合成纹理

根据给定一个图像示例，合成一种新的纹理；

由于计算机视觉和图形学领域的许多学者均关注于合成纹理方法的研究，因此出现了许多实用的算法。

在计算机图形学中，纹理合成方法可分为两类：

> 基于像素点的纹理合成方法；
>
> > **主体思想**:逐像素点合成新的纹理图像,其中每个像素点由其周围的像素决定（例如3*3,5*5），根据这些周围像素点从原始图像中以最相似的原则从给定的图像示例搜索获得的像素点作为所需的像素点
> >
> > ![image-20220215220829824](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215220829824.png)
>
> 基于图像块的纹理合成方法。
>
> > 基于像素点的纹理合成方法计算代价大，通过图像块代替单个像素点的方式，改进纹理合成方法；
> >
> > Graph-Cut[Kwatra03]是其中一种最重要的方法,它具有非常优越的性能；
> >
> > 选择图像块的原则类似与选择像素点的原则,即仍然基于最相似原则。
> >
> > <img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215220856736.png" alt="image-20220215220856736" style="zoom:67%;" />![image-20220215220914228](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215220914228.png)

#### 映射

纹理映射的实质是建立两个映射关系

> 从纹理空间到景物空间的映射；
>
> 再到屏幕空间的映射。
>
> ![image-20220215221021049](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215221021049.png)

**映射方法**

> 建立物体空间坐标(x,y,z)和纹理空间坐标(u,v)之间的对应关系；
>
> 对物体表面进行参数化，反求出物体表面的参数后，根据(u,v)得到该处的纹理值，并用此值取代光照明模型中的相应项，实现纹理映射；
>
> **圆柱面映射**和**球面映射**是两个经常使用的映射方法。

##### 圆柱面映射

圆柱面的参数方程

![image-20220215221059231](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215221059231.png)

圆柱面上一点(x,y,z)的参数即纹理坐标：

![image-20220215221107022](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215221107022.png)

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215221120296.png" alt="image-20220215221120296" style="zoom:67%;" />

##### 球面映射

球面参数方程

![image-20220215221134999](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215221134999.png)

球面上一点(x,y,z)的参数即纹理坐标

![image-20220215221141089](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215221141089.png)

![image-20220215221150306](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215221150306.png)

#### 滤波

多个纹理元素只覆盖一个像素单元

最简单的解决方法是点取样，使用最邻近纹理元素：把当前象素单元的最中心所对应的纹理空间的点的值，作为象素的纹理值；这种方式会**导致严重的走样**。

![image-20220215221253171](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215221253171.png)

对纹理进行放大，由于采样区域的局限性，所获取的纹理样本通常为小块纹理，将导致映射后表面纹理模糊不清；

若采用重复映射技术，则可能出现表面纹理接缝走样等问题。

![image-20220215221317992](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215221317992.png)

为了得到比较合理的像素颜色值

> 线性滤波器；
>
> Mipmapping（各向同性滤波）；
>
> Ripmapping（各向异性滤波）

### 几何纹理

桔子的模型：

> 借用图像纹理的思路，将真实桔子的照片贴到球面上模拟桔子；
>
> 如果移动了光源或旋转了对象，看到的是桔子的模型的图像，而不是真实桔子的图像；
>
> 真实桔子的特征是在表面上有很多小形状变化。
>
> 图像纹理不能模拟**形状的变化**。

**几何纹理**

1978年，Blinn提出产生几何纹理，模拟凸凹不平的物体表面的方法（凹凸映射，Bump mapping）

**基本思想**：生成图像时，对曲面的法向量进行扰动。

> 对景物表面各采样点位置作微小的扰动，改变表面的微观几何形状，引起景物表面法向量的扰动。
>
> 景物表面光亮度是法向量的函数：法向量的扰动导致表面光亮度的突变，产生表面凹凸不平的真实效果。

设物体表面上任意一点P(u,v)沿该点处的法向量方向位移F(u,v)个单位长度(N附加一微小增量)，从而生成一张新的表面

![image-20220215221515065](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215221515065.png)

新法向量的计算：

通过对两个偏导数求叉积得到：

![image-20220215221542900](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215221542900.png)

*F*相对很小， *FuFv*忽略不计，有：

![image-20220215221547725](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220215221547725.png)

**几何纹理的实现**

扰动后的法向量单位化，用于计算曲面的明暗度，产生凹凸不平的几何纹理；

**几何纹理函数**：用二维数组记录各象素的值，图案中较暗颜色对应较小F值，较亮颜色对应较大F值；

F的偏导数的计算，可以用中心差分实现。 
