# $\textbf{1. }$绪论

> ## $\textbf{1.1. }$计算机的语言处理
>
> > :one:计算机语言与编译
> >
> > 1. 计算机语言三层次：
> >    | 语言层级 | 特点                                         | 示例             |
> >    | :------- | :------------------------------------------- | :--------------- |
> >    | 机器语言 | 可以被计算机直接理解，与人类表达习惯相去甚远 | `C706 0000 0002` |
> >    | 汇编语言 | 引入助记符，依赖于特定机器                   | `MOV X, 2`       |
> >    | 高级语言 | 接近人类表达习惯，不依赖于特定机器           | `x = 2`          |
> > 2. 编译与汇编： 编译${\xLeftrightarrow{}}$将高级(源)语言翻译成汇编$/$机器(目标)语言，汇编${\xLeftrightarrow{}}$将汇编语言翻译成机器语言
> >    <img src="https://i-blog.csdnimg.cn/direct/f793c00c5cf74c858d26de566bf262f5.png" alt="image-20250530202006184" width=390 /> 
> >
> > :two:计算机的语言处理系统
> >
> > 1. 总体结构：从源程序到机器码
> >    <img src="https://i-blog.csdnimg.cn/direct/d2412ed6468a4a2084b34011ab1964c6.png" alt="image-20250531103834454" width=710 />  
> >    - 预处理器：合并存储在不同文件的源程序，替换代码中的宏为原始语句
> >    - 可重定位：即机器码在内存中的起始位置不固定，起始位置$+$相对地址$=$绝对地址
> >    - 加载器： 修改可重定位地址，将修改后的内存$/$数据放入内存
> > 2. 编译器的逻辑结构：分析部分(词法分析${\to}$语法分析${\to}$语义分析​)$+$综合部分
> >    <img src="https://i-blog.csdnimg.cn/direct/b61968ecf407492da0db97de5c9699d8.png" alt="image-20250531105015906" width=600 /> 
> >    - 语法制导翻译：在实际的实现层面上，语法分析$/$语义分析$/$中间代码生成三者放在一起实现
> >    - 中间表示形式：独立于源$/$目标语言，如语法结构树($\text{Syntax Tree}$)和三地址指令的四元式(如下)
> >        ```C++
> >        x = y op z      ( op , y , z , x )
> >        x = op y        ( op , y , _ , x )
> >        x = y[i]        ( =[], y , i , x )
> >        x = *y          ( =* , y , _ , x )
> >        ```
> >    - 目标代码生成：将中间表示形式映射到目标语言，同时为每个变量分配寄存器
> >    - 代码的优化：对待改进代码进行等价替换，优化运行速度和占用空间
>
> ## $\textbf{1.2. }$编译器的前端
>
> > :one:词法分析：从左到右逐行扫描源程序${\to}$识别各单词及其类型${\to}$将单词转化统一机内表示(词法$\text{Token}$)
> >
> > 1. $\text{Token}$：按照`<种别码, 属性值>`形式来表征一个单词，单词的种类如下
> >    |  单词  | 种别                       | 词法$\textbf{Token}$                                         |
> >    | :----: | :------------------------- | ------------------------------------------------------------ |
> >    | 关键字 | `if`$/$`else`$/$`then`...  | 为每个关键字分配一个种别码                                   |
> >    | 标识符 | 变量名$/$数组名...         | 为所有标识符分配一个种别码$+$用属性值区分不同标识符          |
> >    |  常量  | 整型$/$浮点常量...         | 为每类型常量分配一个种别码$+$用属性值区分同类型不同常量      |
> >    | 运算符 | 算术$/$关系$/$逻辑         | 为每个运算符分配一个种别码；<br>为每类运算符分配一个种别码$+$用属性值区分同类型不同算符 |
> >    | 界限符 | `;`$/$`()`$/$`=`$/$`{}`... | 为每个界限符分配一个种别码                                   |
> > 2. 示例：对`while(value!=100){num++;}`词法分析的输出$\text{Token}$序列
> >    ```C++
> >    1    while    < WHILE , - >
> >    2    (        < SLP   , - >
> >    3    value    < IDN   , value >
> >    4    !=       < NE    , - >
> >    5    100      < CONST , 100 >
> >    6    )        < SRP   , - >
> >    7    {        < LP    , - >
> >    8    num      < IDN   , num >
> >    9    ++       < INC   , - >
> >    10   ;        < SEMI  , - >
> >    11   }        < RP    , - >
> >    ```
> >
> > :two:语法分析：基于词法分析输出的$\text{Token}$序列，识别处各类短语，并构造语法分析树($\text{parse tree}$)
> >
> > 1. 赋值的分析树：以`position = initial + rate * 60;`为例
> >    <img src="https://i-blog.csdnimg.cn/direct/b603f3ea806e453f9b5fdf1a8dd80009.png" alt="image-20250531131535386" width=400 />  
> > 2. 变量声明的分析树：文法为`<D,变量声明> -> <T,类型> <IDS,标识符序列>`，以`int a,b,c;`为例
> >    <img src="https://i-blog.csdnimg.cn/direct/de27095c21114e6097edc3b94162fb13.png" alt="image-20250531133205406" width=200 /> 
> >
> > :three:语义分析：收集标识符的属性信息，以及语义检查  
> >
> > 1. 标识符的属性：大致分为变量，过程(函数)两类
> >      - 变量：标识内存中存储数据位置的名称
> >        |    标识符的属性     | 解释                                                     |
> >        | :-----------------: | :------------------------------------------------------- |
> >        | 种属($\text{Kind}$) | 简单变量，复合变量(数组$/$记录$/$结构体）                |
> >        | 类型($\text{Type}$) | 整型，实型，字符型等                                     |
> >        |      存储信息       | 存放在内存中的位置，占据内存的长度                       |
> >        |         值          | 变量在特定时刻存储在内存中的具体数据                     |
> >        |       作用域        | 变量在程序中有效的区域或代码段，比如全局变量作用域为全局 |
> >      - 过程：执行特定任务的一段命名的代码块
> >        |    标识符的属性     | 解释                                                         |
> >        | :-----------------: | :----------------------------------------------------------- |
> >        | 种属($\text{Kind}$) | 过程$/$函数，其中函数通常返回一个值$/$过程不返回值           |
> >        |      存储信息       | 函数代码在内存中开始执行的指令的地址，代码块编译后的机器码所占空间 |
> >        |       作用域        | 函数名在程序中有效的区域或代码段                             |
> >        |        参数         | 参数个数，参数类型，参数传递方式                             |
> >        |       返回值        | 返回值类型，具体值                                           |
> > 2. 符号表：存放语义分析阶段所有标识符的信息
> >      <img src="https://i-blog.csdnimg.cn/direct/05d955ed1cf448649949180e55162a83.png" alt="image-20250531140904532" width=500 /> 
> >      - 符号表结构：每行对应一个标识符，每列对应一个标识符的属性
> >      - 字符串表结构：按顺序存放标识符的名称，通过符号表的`NAME`属性指定起始位置$+$长度来分割
> > 3. 语义检查：变量$/$过程未声明，变量$/$过程重复声明，运算分量类型不匹配，操作数操作符类型不匹配
> >

# $\textbf{2. }$计算机语言及其文法

> ## $\textbf{2.1. }$一些基本概念
>
> > :one:字母表及其运算
> >
> > 1. 字母表概念：一个有穷符号的集合，用${\sum}$表示；例如$\text{ASCII}$字符集
> > 2. 字母表运算：乘积($\text{Product}$)，幂($\text{Power}$)，正闭包($\text{Positive closure}$)，林闭包($\text{Kleene closure}$)   
> >    |   运算   | 定义                                                         | 示例                                              |
> >    | :------: | ------------------------------------------------------------ | ------------------------------------------------- |
> >    |   乘积   | ${\sum_1}{\sum_2}=\{ab{\mid}a{\in}{\sum_1},b{\in}{\sum_2}\}$ | $\{0,1\}\{a,b\}{=}\{0a,0b,1a,1b\}$                |
> >    |    幂    | ${\sum^n}={\sum^{n{-}1}}{\sum}$ 且 ${\sum^0}{=}\{\varepsilon\}$(空串) | $\{0,1\}^2{=}\{0,1\}\{0,1\}{=}\{00,01,10,11\}$    |
> >    |  正闭包  | ${\sum^+}={\sum{\cup}\sum^2{\cup}\sum^3...}$                 | $\{a,b,c,d\}^+=\{a,b,c,d,aa,ab,ac,...\}$          |
> >    | 克林闭包 | ${\sum^*}={\sum^0{\cup}\sum{\cup}\sum^2...}$                 | $\{a,b,c,d\}^*=\{\varepsilon,a,b,c,d,aa,ab,...\}$ |
> >
> > :two: 串及其运算
> >
> > 1. 串的概念：串是字母表中符号的一个有穷序列，严格来说$x{\in}{\sum^*}$则$x$是${\sum}$上的串
> > 2. 串的运算：取模，连接，幂
> >    |   运算   | 定义                                     | 备注                                                         |
> >    | :------: | ---------------------------------------- | ------------------------------------------------------------ |
> >    |   取模   | 计算一个串的长度，即串中符号个数         | 例如${\mid}aab{\mid}{=}3$，空串${\mid}\varepsilon{\mid}{=}0$ |
> >    | 连接(乘) | $z{=}xy$表示把$y$附加到$x$后面而形成的串 | $x$为$z$前缀$\&y$为$z$后缀，空串$εs{=}sε{=}s  $              |
> >    |    幂    | 串$s$的$n$次幂就是将$n$个$s$依次连接     | 例如$s{=}ba$则$s^3{=}bababa$                                 |
>
> ## $\textbf{2.2. }$文法及其分类
>
> > :one:文法的形式化定义：四元组$G{=}(V_T,V_N,P,S)$
> >
> > 1. 文法符号：
> >    - 文法符号集：包含终结符集合$V_T{\cap}$非终结符集合$V_N$两部分共同构成，且二者互不相交
> >      |       成分        | 解释                                     | 示例                              |
> >      | :---------------: | ---------------------------------------- | :-------------------------------- |
> >      |  终结符集合$V_T$  | 终结符是语言的基本符号，即$\text{Token}$ | 单词集                            |
> >      | 非终结符集合$V_N$ | 非终结符用来表示语法成分，即语法变量     | $\{$`<名词>`, `<动词>`, ${...}\}$ |
> >    - 开始符号$S$：是一个特殊非终结符，表示文法中最大的语法成分，比如$S{=}$`<句子>`
> > 2. 产生式集合$P$：
> >    - 定义：产生式描述了将$V_T$和$V_N$组合成串的规则，定义为$\alpha{\to}\beta$(读作$\alpha$定义为$\beta$) 
> >      |           成分            | 解释                                                         |
> >      | :-----------------------: | ------------------------------------------------------------ |
> >      | 产生式的头$/$左部$\alpha$ | 满足$\alpha{\in}(V_T{\cup}V_N)^+$，且其中$\alpha$必须包含至少一个非终结符 |
> >      | 产生式的体$/$右部$\beta$  | 满足$\beta{\in}(V_T{\cup}V_N)^*$                             |
> >    - 示例：$P{=}\{$`<句子> -> <名词短语> <动词短语>`, `<名词短语> -> <形容词> <名词短语>`$...\}$ 
> >    - 简写：对相同左部的产生式$\alpha{\to}\beta_1/\alpha{\to}\beta_2/...\alpha{\to}\beta_n$记作$\alpha{\to}\beta_1{\mid}\beta_2{\mid}...{\mid}\beta_n$，$\beta_i$成为候选式
> >
> > :two:符号约定：默认什么类型的字符对应什么类型的符号
> >
> > 1. 文法符号：用`U,V,X,Y,Z`表示终结符或非终结符，具体到二者之一则如下表
> >    |  符号  | 默认字符                                                     |
> >    | :----: | ------------------------------------------------------------ |
> >    |  终结  | 小写`a,b,c,d,e`$/$运算符`+-*`$/$标点符号`;,(){}`$/$数字`012`$/$粗字符串`id,if` |
> >    | 非终结 | 大写`A,B,C,D,E`$/$斜字符串`expr,stmt`$/$特定大写`E(表达式),T(项),F(因子),S(开始符)` |
> > 2. 符号串：分为两类符号串，如下表
> >    |   符号串   | 含义                                 | 默认字符                      |
> >    | :--------: | ------------------------------------ | ----------------------------- |
> >    | 终结符号串 | 终结符组成的有限序列                 | 小写字母`u,v,x,y,z`，包括空串 |
> >    | 文法符号串 | 终结符和非终结符的任意组合的有限序列 | 希腊字母`α,β,γ`，包括空串     |
> > 3. 开始符号：默认第一个产生式的左部就是开始符号
> >
> > :three:$\text{Chomsky}$文法分类体系：基于对产生式的限制
> >
> > <img src="https://i-blog.csdnimg.cn/direct/81b47969cd7347ce951f8f0fef7b472a.png" alt="image-20250601114233423" width=330 /> 
> > | 文法  | 对产生式$\boldsymbol{{\forall}\alpha{\to}\beta{\in}{P}}$的限制 | 别称                                   |
> > | :---: | ------------------------------------------------------------ | -------------------------------------- |
> > | $0$型 | $\alpha$至少包含一个非终结符                                 | 无限制文法，短语结构文法($\text{PSG}$) |
> > | $1$型 | $\alpha$至少包含一个非终结符<br>符号长度${\mid}\alpha{\mid}{\leq}{\mid}\beta{\mid}$，一般写作$\alpha_1A\alpha_2{\to}\alpha_1\beta\alpha_2$ | 上下文有关文法($\text{CSG}$)           |
> > | $2$型 | $\alpha$至少包含一个非终结符<br>$\alpha$必须是非终结符，亦可写作$A{\to}\beta$ | 上下文无关文法($\text{CFG}$)，使用最多 |
> > | $3$型 | $\alpha$至少包含一个非终结符<br/>$\alpha$必须是非终结符，具体情况分为两种<br/>右线性文法：$A{\to}wB$或$A{\to}w$<br/>左线性文法：$A{\to}Bw$或$A{\to}w$ | 正则文法($\text{RG}$)                  |
>
> ## $\textbf{2.3. }$语言的定义
>
> > :one:推导和规约：给定文法$G{=}(V_T,V_N,P,S)$
> >
> > 1. 推导：将产生式左部替换为右部的过程
> >    - 直接推导：对产生式$\alpha{\to}\beta{\in}{P}$，则符号串$\gamma\alpha\delta$可重写为$\gamma\beta\delta$，即$\gamma\alpha\delta{\Rightarrow}\gamma\beta\delta$(读作直接推到出)
> >    - 间接推导：如果$\alpha_0{\Rightarrow}\alpha_1{\Rightarrow}{\cdots}{\Rightarrow}\alpha_n$，则称符号串$\alpha_0$经过$n$步推导出$\alpha_n$，简记为$\alpha_0{\Rightarrow^n}\alpha_n$ 
> >    - 一些符号：${\Rightarrow^0}$表示不推导即恒有$\alpha{\Rightarrow^0}\alpha$，${\Rightarrow^+}$为经过正数步推导，${\Rightarrow^*}$为经过大于等于$0$步推导
> > 2. 规约：将产生式右部替换为左部的过程，如下示例
> >    <img src="https://i-blog.csdnimg.cn/direct/dff9769a316e40019bf60255cb71c972.png" alt="image-20250601095822098" width=380 /> 
> >    - 某词串可规约到开始符，或者开始符可推导到该词串，都说明某词串是该语言的句子
> >
> > :two:句型$/$句子$/$语言：给定文法$G{=}(V_T,V_N,P,S)$
> >
> > <img src="https://i-blog.csdnimg.cn/direct/0a618d0c2f1944518398519b43ad2091.png" alt="image-20250601100550671" width=430 /> 
> > 1. 句型：由开始符$S$推导而来的可包含非终结符的符号串，即$S{\Rightarrow^*}\alpha$且$\alpha{\in}(V_T{\cup}V_N)^*$时$\alpha$为句型
> > 2. 句子：由开始符$S$推导而来的必须只包含终结符的符号串，即$S{\Rightarrow^*}w$且$w{\in}(V_T)^*$时$\alpha$为句子
> > 3. 语言：由开始符$S$推导而来的所有句子的集合，即$L(G){=}\{w{\mid}S{\Rightarrow^*}w,w{\in}(V_T^*)\}$
> >    - 语言是一种**集合**，因而有集合的一切特性
> >
> > :three:语言的运算：以$L{=}\{a,b,c\}$和$M{=}\{1,2,3\}$为例
> >
> > |           运算           | 定义和表示                                                   | 示例                                    |
> > | :----------------------: | ------------------------------------------------------------ | :-------------------------------------- |
> > |       $L$和$M$的并       | $L{\cup}M{=}\{s{\mid}s\text{属于}L\text{或者}s\text{属于}M\}$ | $L{\cup}M{=}\{a,b,c,1,2,3\}$            |
> > |      $L$和$M$的连接      | $LM{=}\{st{\mid}s\text{属于}L\text{且}t\text{属于}M\}$       | $LM{=}\{a1,a2,a3,b1,b2,b3,c1,c2,c3\}$   |
> > |         $L$的幂          | $L^0{=}\{\varepsilon\}\text{及}L^n{=}L^{n-1}(n{\ge}1)$       | $L^2{=}\{aa,ab,ac,ba,bb,bc,ca,cb, cc\}$ |
> > | $L$的$\text{Kleene}$闭包 | $L^*{=}\bigcup_{i=0}^{\infty}L^i$                            | 所有由${a,b,c}$组成的字符串(包括空串)   |
> > |       $L$的正闭包        | $L^+{=}\bigcup_{i=1}^{\infty}L^i$                            | 所有由${a,b,c}$组成的字符串(不包括空串) |
>
> ## $\textbf{2.4. }$上下文无关文法的分析树
>
> > :one:分析树的结构
> >
> > <img src="https://i-blog.csdnimg.cn/direct/6cdc0b65a1bb44cbad0725371014eb1c.png" alt="image-20250601120952593" width=290 /> 
> > 1. 根节点：文法的开始符号
> > 2. 内节点：表示对一个产生式$A{\to}\beta$的应用，节点本身表示$A$，节点的所有子节点从左到右表示$\beta$
> > 3. 叶节点：表示终结符或非终结符，所有叶节点从左到右排列得到的符号串称为**树的产出**或**边缘**
> >
> > :two:分析树的表征
> >
> > 1. 与推导：分析树是推导的图形化，对推导$S{\Rightarrow}\alpha_1{\Rightarrow}{\cdots}{\Rightarrow}\alpha_n$中每个句型$\alpha_i$都可构造边缘为$\alpha_i$的分析树
> >    <img src="https://i-blog.csdnimg.cn/direct/a32a3f5d823749e5bb5ffbb7a6ea3abe.png" alt="image-20250601123606200" width=430 /> 
> > 2. 与短语：句型的分析树中，每棵子树的边缘为该句型的短语，只有两层的子树的边缘是为直接短语
> >    <img src="https://i-blog.csdnimg.cn/direct/ac10fe45a0ea4bf0bc81d47edd9baadf.png" alt="image-20250601124920512" width=350 /> 
> >    - 直接短语一定是某产生式的右部，但反之不一定成立
> >
> > :two:文法的二义性
> >
> > 1. 含义：如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的  
> > 2. 示例：文法`S -> if E then S | if E then S else S`，如下句型及其两种分析树
> >    <img src="https://i-blog.csdnimg.cn/direct/eacf4d0f050945d2aca3468bdcacc466.png" alt="image-20250601131302993" width=560 />  
> > 3. 判定：对任意上下文无关文法，不存在算法判断其是否无二义性，但可给出无二义性的充分条件

# $\textbf{3. }$词法分析

> ## $\textbf{3.1. }$正则表达式$\textbf{(RE)}$
>
> > :one:正则表达式的定义
> >
> > 1. 概念定义：正则表达式$r$由更小的正则表达式递归构建，$L(r)$为符合$r$匹配模式的所有串(正则语言)
> > 2. 形式定义：空串$\varepsilon$是正则表达式$L(\varepsilon){=}\varepsilon$，任意符号$a{\in}\sum$都是正则表达式$L(a){=}a$，则按如下方式递归
> >    | 递归运算 |  运算优先级  | 含义: 当$\boldsymbol{r,s}$都是正则表达式                   |
> >    | :------: | :----------: | ---------------------------------------------------------- |
> >    |   重复   |      高      | $r^*$也是正则表达式，且$L(r^*){=}(L(r))^*$                 |
> >    |   拼接   |      中      | $rs$也是正则表达式，且$L(rs){=}L(r)L(s)$                   |
> >    |    或    |      低      | $r{\mid}s$也是正则表达式，且$L(r{\mid}s){=}L(r){\cup}L(s)$ |
> >    |   括号   | $\text{N/A}$ | $(r)$也是正则表达式，且$L((r)){=}L(r)$                     |
> > 3. 示例：十六进制的正则表达式，`0x(0|1|…|9|a|…|f|A|…|F)(0|…|9|a|…|f|A|…|F )*`
> >
> > :two:正则表达式的运算
> >
> > 1. 连接与或：连接类比为乘，或类比为加
> >    |         描述         |                  表示                   |
> >    | :------------------: | :-------------------------------------: |
> >    |     $\mid$可交换     |        $r{\mid}{s}{=}s{\mid}{r}$        |
> >    |     $\mid$可集合     | $r{\mid}(s{\mid}t){=}(r{\mid}s){\mid}t$ |
> >    |      连接可结合      |             $r(st){=}(rs)t$             |
> >    | 连接对${\mid}$可分配 |       $r(s{\mid}t){=}rs{\mid}rt$        |
> > 2. 其它运算：$\varepsilon$类似于$1$，闭包类似于求和所有从$0$开始的次幂
> >    |           描述            |                表示                 |
> >    | :-----------------------: | :---------------------------------: |
> >    | $\varepsilon$是连接单位元 | $r\varepsilon{=}\varepsilon{r}{=}r$ |
> >    |   闭包包含$\varepsilon$   |   $r^*{=}(r{\mid}\varepsilon)^*$    |
> >    |       闭包的幂等性        |          ${r}^{**}{=}r^*$           |
> >
> > :three:正则定义：
> >
> > 1. 含义：将所有正则表达式$r_i$起名为$d_i$，即$d_i{\to}r_i$($r{=}1,{\dots},n$)
> >    - 关于$d_i$：为新符号即不存在于原有字母表$\sum$上，并且不同$d_i$间各不相同
> >    - 关于$r_i$：每个$r_i$都是$\sum{\cup}\{d_1,d_2,{\ldots},d_{i{-}1}\}$上的正则表达式，即只能用字母表$/$已定义符号表示$r_i$
> > 2. 意义：为某些正则表达式命名，并在之后的正则表达式中像使用字母表中符号一样使用这些新的命名
> > 3. 示例：$\text{C}^{++}$中变量名(标识符)的正则定义
> >    ```txt
> >    正则定义:  digit   ->  0|1|2|…|9
> >    正则定义:  letter_ ->  A|B|…|Z|a|b|…|z|_
> >    变量名称:  id      ->  letter_(letter_|digit)*
> >    ```
> >
>
> ## $\textbf{3.2. }$有穷自动机$\textbf{(FA)}$
>
> > :one:$\text{FA}$的基本概念
> >
> > 1. 基本特征：
> >    - 要素：具有一系列离散的输入输出信息，具有又穷数目的内部状态
> >    - 机制：当前所处状态${+}$当前的输入$\xrightarrow{完全决定}$确定的后继行为
> >    - 示例：电梯，将用户输入的楼层当作输入，将所处楼层$\&$运动方向当作状态
> > 2. $\text{FA}$模型：
> >    <img src="https://i-blog.csdnimg.cn/direct/9c1187942cd54cbaa6056ef3bb471b29.png" alt="image-20250614144652981" width=320 /> 
> >    |    组件    | 功能                                                   |
> >    | :--------: | ------------------------------------------------------ |
> >    |   输入带   | 存放输入的符号串                                       |
> >    |    读头    | 从左到右依次以只读的方式读取输入符号                   |
> >    | 又穷控制器 | 具有又穷的状态数，依据当前状态$\&$当前输入转入下一状态 |
> > 3. $\text{FA}$的转换图：
> >    <img src="https://i-blog.csdnimg.cn/direct/cce2ab0499134149a31a52d0eb4a2ad3.png" alt="image-20250614145247731" width=400 /> 
> >    - 结点：$\text{FA}$的状态，其中初始状态用$\xrightarrow{\text{start}}$标识，终止状态(可有多个)用双圈表示
> >    - 有向边：状态$p$如果输入$a$就变成状态$q$，则记为$p{\xrightarrow{a}}q$ 
> >
> > :two:$\text{FA}$定义的语言
> >
> > 1. 概念：$\text{FA}$接收(定义)的语言
> >    - $\text{FA}$接收：将串$x$中每个字符依次输入$\text{FA}$，能使得$\text{FA}$从起始状态达到终止状态，则$x$被此$\text{FA}$接收
> >    - $\text{FA}$语言：又穷自动机$M$接收的所有串的集合，就是该$\text{FA}$定义的语言，记作$L(M)$
> > 2. 示例：如下图`aabbaabb`串会被接收，所定义语言的$\text{RE}$是`(a|b)*abb`
> >    <img src="https://i-blog.csdnimg.cn/direct/c0ea2b0671c544faaabc27d646dde1a0.png" alt="image-20250614145247731" width=400 /> 
> >    - $\text{Ps. }$正则表达式和$\text{FA}$是完全互相等价的
> > 3. 补充：最长字串匹配原则，如下图输入串为`<=`时要一路匹配到状态$2$
> >    <img src="https://i-blog.csdnimg.cn/direct/023bdd192f294828a798833695377b4d.png" alt="image-20250614155149421" width=350 /> 
> >    - 第一种表述：当输入串的多个前缀与多个模式匹配时，总选择最长的前缀进行匹配
> >    - 第二种表述：到达某个终态之后，只要输入带上还有符号，$\text{FA}$就继续前进以寻求尽可能长的匹配 
> >
> > :three:两种$\text{FA}$：确定与非确定
> >
> > 1. 确定有穷自动机$\text{DFA}$
> >    - 结构：五元组$M{=}\{S,\Sigma,\delta,s_0,F\}$
> >      |   结构   | 含义                                                         |    示例中     |
> >      | :------: | ------------------------------------------------------------ | :-----------: |
> >      |   $S$    | 有穷状态集                                                   | $\{0,1,2,3\}$ |
> >      | $\Sigma$ | 输入字母表(输入符号的集合)，默认约定空串$\varepsilon$不是$\Sigma$中的元素 |   $\{a,b\}$   |
> >      | $\delta$ | $S{\cross}\Sigma{\xrightarrow{映射到}}S$的转换，从状态$s{\in}S$出发输入$a{\in}\Sigma$能达到$\delta{(s,a)}{\in}S$状态 |   见转换表    |
> >      |  $s_0$   | 初始状态$s_0{\in}S$                                          |      $0$      |
> >      |   $F$    | 终止(接收状态)的集合，即$F{\subseteq}S$                      |    $\{3\}$    |
> >    - 示例：$\text{DFA}$可用状态表或者转化图表示
> >      <img src="https://i-blog.csdnimg.cn/direct/f7faba9a81b046fa9be97753b9c93ee7.png" alt="image-20250614161144798" width=600 /> 
> > 2. 非确定有穷自动机$\text{NFA}$
> >    - 与$\text{DFA}$区别：从$s$出发沿标记为$a$的边所达到的新状态不唯一，$\delta(s,a)$表示这种不唯一状态的集合
> >    - 示例：转换表与转化图
> >      <img src="https://i-blog.csdnimg.cn/direct/e8f2b4ce50004f3eb5a703604523eb9b.png" alt="image-20250615120039879" width=600 /> 
> > 3. $\text{NFA}$与$\text{DFA}$的等价性
> >    - 表述：若一<font color=red>$\text{NFA-N}$</font>$/$<font color=green>$\text{DFA-D}$</font>定义了某种语言，定有一<font color=red>$\text{DFA-D}$</font>$/$<font color=green>$\text{NFA-N}$</font>也定义了这种语言
> >    - 示例：以下接收串都可以表述为`(a|b)*abb`
> >      <img src="https://i-blog.csdnimg.cn/direct/cb445a44f5b2404ca2e1b5f3fc67f3a5.png" alt="image-20250615121335782" width=450 /> 
> >    - 特点：逻辑上$\text{NFA}$更加直观，计算机实现上$\text{DFA}$更容易实现
> >
> > :four:带空边的$\text{NFA}$
> >
> > 1. 含义：将空边$\varepsilon$也加入到字母表$\Sigma$中，即空串(不输入任何字符)也可以导致$\text{NFA}$状态的转换
> > 2. 等价性：所有带$\varepsilon$的$\text{NFA}$都可以转换为不带$\varepsilon$的$\text{NFA}$(反之亦然)，例如下面都定义了$\text{RE}{=}$`0*1*2*`   
> >    <img src="https://i-blog.csdnimg.cn/direct/64272145d4da4b94a58476d5e52eec12.png" alt="image-20250615123816053" width=450 /> 
>
> ## $\textbf{3.3. }$从$\textbf{RE}$到$\textbf{FA}$
>
> > :thinking:一般模式：先从$\text{RE}$转化为$\text{NFA}$，再从$\text{NFA}$转化为$\text{DFA}$
> >
> > <img src="https://i-blog.csdnimg.cn/direct/ccff7bb2cda4492fa600982fb9a40698.png" alt="image-20250615153138794" width=350 /> 
> >
> > :one:从$\text{RE}$到$\text{NFA}$
> >
> > 1. 单字符的$\text{RE}{\to}\text{NFA}$
> >    |      字符      | $\textbf{NFA}$                                               |
> >    | :------------: | :----------------------------------------------------------- |
> >    | $\varepsilon$  | <img src="https://i-blog.csdnimg.cn/direct/3addeac8fb8a4bad80ab04c846af90c7.png" alt="image-20250615150200658" width=200 /> |
> >    | $a{\in}\Sigma$ | <img src="https://i-blog.csdnimg.cn/direct/80452bf900534d96a20e19d5768adc3f.png" alt="image-20250615150224838" width=200 /> |
> > 2. 表达式的$\text{RE}{\to}\text{NFA}$
> >    | $\textbf{RE}$  | $\textbf{NFA}$                                               |
> >    | :------------: | ------------------------------------------------------------ |
> >    |    $r_1r_2$    | <img src="https://i-blog.csdnimg.cn/direct/48b884a006f440388d1d0e8b278dfa35.png" alt="image-20250615150923004" width=300 /> |
> >    | $r_1{\mid}r_2$ | <img src="https://i-blog.csdnimg.cn/direct/bd3a4bcba9bd4ff5b79d8b2e594b83d6.png" alt="image-20250615151106250" width=255 /> |
> >    |   $(r_1)^*$    | <img src="https://i-blog.csdnimg.cn/direct/677cef808b484a99a4068c79f888d8dd.png" alt="image-20250615151552123" width=165 /> |
> > 3. 转换示例：`r=(a|b)*abb`
> >    |    步骤    | $\textbf{DFA}$                                               |
> >    | :--------: | ------------------------------------------------------------ |
> >    |  原始状态  | <img src="https://i-blog.csdnimg.cn/direct/090b46c61a0b4dfead491d0f29493b56.png" alt="image-20250615152038141" width=240 /> |
> >    | 拼接的展开 | <img src="https://i-blog.csdnimg.cn/direct/96947365c7c141c4a29fcff8d9e1ee06.png" alt="image-20250615152235496" width=240 /> |
> >    |  或的展开  | <img src="https://i-blog.csdnimg.cn/direct/a7d0ae139cfb40c589852c6731c5101a.png" width=218 /> |
> >    | 闭包的展开 | <img src="https://i-blog.csdnimg.cn/direct/0855892b05264785ba9f5572d8110fcc.png" width=218 /> |
> >
> > :two:从$\text{NFA}$到$\text{DFA}$：子集构造法
> >
> > 1. 第一步：给定一个$\text{NFA}$，写出它的状态转化表
> >    <img src="https://i-blog.csdnimg.cn/direct/7579a3db54e442eeb1145e04a684a2fb.png" alt="image-20250615160138130" width=350 /> 
> >    $\begin{array}{|c|c|c|c|}
> >    \hline \text { 状态$\backslash$输入 } & {a} & {b} & {c} \\
> >    \hline {A} & \{{A}, {B}\} & {\varnothing} & {\varnothing} \\
> >    \hline {B} & {\varnothing} & \{{B}, {C}\} & {\varnothing} \\
> >    \hline {C} & {\varnothing} & {\varnothing} & \{{C}, {D}\} \\
> >    \hline {D} & {\varnothing} & {\varnothing} & {\varnothing} \\
> >    \hline 
> >    \end{array}$  
> > 2. 第二步：由状态转化表直接确定$\text{DFA}$中的状态，初始$/$终止状态，转换关系
> >    <img src="https://i-blog.csdnimg.cn/direct/16063c291ce349ad9bb4437c37a805ce.png" alt="image-20250615160355116"  width=350 />  
> >    - $\text{DFA}$状态：出现在$\text{NFA}$转换表中的子集必是$\text{DFA}$状态
> >    - 起始$/$终止：某子集中有状态是$\text{NFA}$的起始$/$终止态，则该子集对应的$\text{DFA}$状态就是起始$/$终止态
> >    - 转换关系： 基于$\text{DFA}$状态对着$\text{NFA}$转化表照葫芦画瓢
> >
> > :three:例题：(子集转换法)将以下$\text{NFA}$转化为$\text{DFA}$(写出迁移表)，其中$\text{DFA}$状态用$\text{NFA}$状态集合表示
> >
> >   $\begin{array}{|r|c|c|c|c|}\hline
> >   \text {} & \mathrm{a} & \mathrm{~b} & \varepsilon & \varepsilon \text {－闭包 } \\
> >   \hline \rightarrow 1 & \{2,3\} & & \{3\} & \{1,3\} \\
> >   \hline 2 & & \{3\} & \{3,4\} & \{2,3,4\} \\
> >   \hline 3 & \{4\} & & & \{3\} \\
> >   \hline 4 & & \{5\} & & \{4\} \\
> >   \hline{ }^* 5 & & & \{1\} & \{1,3,5\} \\
> >   \hline
> >   \end{array}$
> > 1. $\text{DFA}$的开始状态，是$\text{NFA}$开始状态的`ε-`闭包，即`{1,3}`
> > 2. 从`{1,3}`出发接收输入，试图得到其它状态`δ_DFA(S,a) = ε-CLOSURE(move(S,a))`
> >    ```txt
> >    {1,3} --a-> {2,3,4}     求出ε-CLOSURE({2,3,4})={2,3,4}✅新状态
> >    {1,3} --b-> {}
> >    {1,3} --ε-> {3}         //记住这里不应该出现ε的状态转移
> >    
> >    {2,3,4} --a-> {4}       求出ε-CLOSURE({4})={4}✅新状态
> >    {2,3,4} --b-> {3,5}     求出ε-CLOSURE({3,5})={1,3,5}✅新状态
> >    
> >    {4} --a-> {}
> >    {4} --b-> {5}           求出ε-CLOSURE({5})={1,3,5}
> >    
> >    {1,3,5} --a-> {2,3,4}   求出ε-CLOSURE({2,3,4})={2,3,4}
> >    {1,3,5} --b-> {}
> >    ```
> >    - 注意`ε-CLOSURE({a,b}) = ε-CLOSURE({a}) + ε-CLOSURE({b})`
> > 3. 一共有状态`{1,3} {2,3,4} {4} {1,3,5}`，画出状态转化表，`ε`列直接无
> >    $\begin{array}{|r|c|c|c|c|}\hline
> >    \text {} & \mathrm{a} & \mathrm{~b}  \\
> >    \hline \rightarrow \{1,3\} &  \{2,3,4\} &     \\
> >    \hline \{2,3,4\} & \{4\} &  \{1,3,5\}   \\
> >    \hline \{4\} &  &  \{1,3,5\}  \\
> >    \hline ^*\{1,3,5\} &\{2,3,4\} &    \\
> >    \hline
> >    \end{array}$
>
> ## $\textbf{3.4. }$词法阶段的错误处理
>
> > :one:错误检测
> >
> > 1. 对象：能检测出单词拼写错误，以及非法字符
> > 2. 机制：假设当前状态非终止，当前状态$\xrightarrow{当前输入}$非法状态(即转换表中对应信息为空)，则当前词法错误
> >
> > :two:错误处理
> >
> > 1. 寻找终态字符：查找已扫描字符串中最后一个对应于某终态的字符，将该终态字符后视做新单词
> > 2. 错误恢复(恐慌模式)：若没找到终态字符，则不断删除剩余输入字符，直到剩余输入开头有一正确字符



