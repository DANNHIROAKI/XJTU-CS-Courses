# $\textbf{1. }$自顶向下分析

> ## $\textbf{1.0. }$概述
>
> > :one:最左$\&$最右推导
> >
> > 1. 最左推导：总选句型中最左边的非终结符进行替换，开始符$S$最左推导得到的$S{\xRightarrow{}^*_{lm}\alpha}$称为最左句型$\alpha$
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250615224756672.png" alt="image-20250615224756672" width=355 /> 
> >
> > 2. 最右推导：总选句型中最右边的非终结符进行替换($\text{aka}$规范推导)，同样得到的句型称为最右句型
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250615225107258.png" alt="image-20250615225107258" width=355 /> 
> >
> > 3. 唯一性：给定一个分析树其对应的推导不一定唯一，但是对应的最左$/$最右推导一定唯一
> >
> > :three:递归下降分析：计算机处理自顶向下分析的通用形式
> >
> > 1. 要素：由一组过程组成，每个非终结符对应一个过程
> >
> > 2. 过程：以非终结符$A{\to}X_1X_2,{\ldots},X_k$为例，便利$X_1$到$X_k$分为三种情况处理
> >    - $X_i$是非终结符：递归地调用非终结符$X_i$对应的过程
> >    
> >    - $X_i$是终结符：分为两种情况
> >    
> >      - $X_i$等于当前的输入符号串：读取下一个输入符号
> >    
> >      - $X_i$不是当前的输入符号串：发生错误，需要回溯到$A$尝试$A$的另一个候选式
> >    
> > 3. 判定：从开始符$S$不断递归调用文法中非终结符对应的过程，如果能成功扫描完某串则语法分析成功
> >
> > :four:预测分析：递归下降分析的一个特例
> >
> > 1. 第一步：构造文法$\text{+}$文法转换，后者是为了消除二义性$/$左递归$/$回溯
> > 1. 第二步：得到每个产生式的$\text{SELECT}$集，这一过程涉及对每个变量$\text{FIRST/FOLLOW}$集的计算
> > 1. 第三步：检查是不是$\text{LL(1)}$文法，若是则构造预测分析表  
> > 1. 第四步：递归或者非递归的预测分析
>
> ## $\textbf{1.1. }$第一步: 文法转换
>
> > :one:自顶向下分析中遇到的问题
> >
> > 1. 公共前缀：同一非终结符的多个候选式存在共同前缀，将导致回溯  
> >
> >    ```txt
> >    示例文法: S->aAd|aBe, A->c, B->b
> >    示例输入: abe
> >    回溯过程: S->aAd->acd❌开始回溯, S->aBe->abe✅匹配成功
> >    ```
> >
> > 2. 无限循环：左递归文法会使递归下降分析器陷入无限循环
> >
> >    ```txt
> >    示例文法: E->E+T|E-T|T, T->T*F|T/F|F, F->(E)|id
> >    示例输入: id+id*id
> >    递推示例: E⇒E+T⇒E+T+T⇒E+T+T+T....
> >    ```
> >
> >    - 直接左递归：文法含有`A->Aα`形式产生式，即经过一步推导能产生左递归
> >    - 间接左递归：文法通过两步及以上推导能产生左递归，例如$S{\xRightarrow{S{\to}Aa}}Aa{\xRightarrow{A{\to}Bb}}Bba{\xRightarrow{B{\to}Sc}}Scba$ 
> >    - 左递归文法：文法中$A$(直接或间接)导出以$A$为前缀的串，即$A{\xRightarrow{+}}Aa$(其中${\xRightarrow{+}}$表示一或多步推导)
> >
> > :two:左递归的消除
> >
> > 1. 消除直接左递归：将左递归变右递归
> >
> >    - 简单形式：$A{\to}A\alpha{\mid}\beta$等价于$A{\xRightarrow{}}\beta\alpha\alpha{...}\alpha$等价于$\begin{cases}A{\to}\beta{}A'\\\\ A'{\to}\alpha{A'}{\mid}\varepsilon\end{cases}$，示例如下
> >
> >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250616202420707.png" alt="image-20250616202420707" width=300 /> 
> >
> >    - 一般形式$A{\to}A\alpha_1{\mid}A\alpha_2{\mid}...{\mid}A\alpha_n{\mid}\beta_1{\mid}\beta_2{\mid}...{\mid}\beta_m$等价于$\begin{cases}A{\to}\beta_1{}A'{\mid}\beta_2{}A'{\mid}...{\mid}\beta_m{}A'\\\\A'{\to}\alpha_1{A'}{\mid}\alpha_2{A'}{\mid}...{\mid}\alpha_n{A'}{\mid}\varepsilon\end{cases}$
> >
> > 2. 消除间接左递归：用代入法转化为直接左递归，示例如下
> >
> >    - 代入：对产生式$S{\to}Aa{\mid}b,A{\to}Ac{\mid}Sd{\mid}\varepsilon$，将$S$的定义带入$A$产生式得$A{\to}Ac{\mid}Aad{\mid}bd{\mid}\varepsilon$
> >    - 消除：遵循对直接左递归的处理方式，得到$\begin{cases}A{\to}bdA'{\mid}A'\\\\ A'{\to}c{A'}{\mid}ad{A'}{\mid}\varepsilon\end{cases}$
> >
> > :three:公共前缀的消除：提取左公因子  
> >
> > 1. 一般形式：$A{\to}\alpha\beta_1{\mid}\alpha\beta_2{\mid}...{\mid}\alpha\beta_n{\mid}\gamma_1{\mid}\gamma_2{\mid}...{\mid}\gamma_m$等价于$\begin{cases}A{\to}\alpha{A'}{\mid}\gamma_1{\mid}\gamma_2{\mid}...{\mid}\gamma_m\\\\A'{\to}\beta_1{\mid}\beta_2{\mid}...{\mid}\beta_n\end{cases}$
> > 2. 核心思想：改写产生式来推迟决定，等读入了足够多的输入再做出正确的选择
>
> ## $\textbf{1.2. }$第二步: `FOLLOW/SELECT/FIRST`集
>
> > :one:文法符号串$\alpha$(即终结符$/$非终结符序列)的串首终结符集$\text{FIRST}(\alpha)$
> >
> > 1. $\text{FIRST}(\alpha)$意义：考虑从$\alpha$出发导出的所有字符串，$\text{FIRST}(\alpha)$即这些串的第一个终结符的集
> >
> >    - 特殊情况：如果$\alpha{\xRightarrow{}^*}\varepsilon$则将$\varepsilon$加入$\text{FIRST}(\alpha)$
> >
> > 2. $\text{FIRST}(\alpha)$规则：取串首终结符，若可推导出空则顺延看下一个
> >
> >    | 规则    | 触发条件                             | 计算规则                                                     |
> >    | ------- | :----------------------------------- | :----------------------------------------------------------- |
> >    | 规则$1$ | $\alpha$为单终结符$a$或$\varepsilon$ | $\text{FIRST}(\alpha) {= }\{a\}$或$\{\varepsilon\}$          |
> >    | 规则$2$ | $\alpha$为单非终结符$A$              | 遍历$A$产生式$A{\to}β_1{\mid}β_2{\mid}...$，$\text{FIRST}(A) {=} \bigcup_i \text{FIRST}(β_i)$ |
> >    | 规则$3$ | $\alpha$为符号串$X_1X_2...$          | 1. $\text{FIRST}(\alpha){\xleftarrow[无条件]{加入}}\text{FIRST}(X_1){\setminus}\{\varepsilon\}$<br/>2. $\text{FIRST}(\alpha){\xleftarrow[若\varepsilon{\in}\text{FIRST}(X_1)]{加入}}\text{FIRST}(X_2){\setminus}\{\varepsilon\}$<br>3. $\text{FIRST}(\alpha){\xleftarrow[\substack{若\varepsilon{\in}\text{FIRST}(X_1)\\且\varepsilon{\in}\text{FIRST}(X_2)}]{加入}}\text{FIRST}(X_3){\setminus}\{\varepsilon\}$<br/>4. $\text{FIRST}(\alpha){\xleftarrow[到\varepsilon{\notin}\text{FIRST}(X_i)]{停止加入}}\text{FIRST}(X_i){\setminus}\{\varepsilon\}$<br/>5. $\text{FIRST}(\alpha){\xleftarrow[所有\text{FIRST}(X_i)都包含\varepsilon]{加入}}\{\varepsilon\}$ |
> >
> > :two:非终结符$A$的后继符号集$\text{FOLLOW}(A)$
> >
> > 1. $\text{FOLLOW}(A)$意义：文法推导中，紧跟在非终结符$A$后面的终结符集合
> >
> > 2. $\text{FOLLOW}(A)$规则：起始加`$`, 向右看`FIRST`, 到头继承父`FOLLOW` 
> >
> >    |  规则   | 触发条件                                                     | 加入$\textbf{FOLLOW}\boldsymbol{(A)}$          |
> >    | :-----: | :----------------------------------------------------------- | :--------------------------------------------- |
> >    | 规则$1$ | $A$是开始符$/$某个句型的最右符号                             | $\texttt{\$}$                                  |
> >    | 规则$2$ | $B{\to}\alpha{A}\beta$                                       | $\text{FIRST}(\beta)\backslash\{\varepsilon\}$ |
> >    | 规则$3$ | $B{\to}\alpha{A}\beta$且$\text{FIRST}(\beta)$包含$\varepsilon$ | $\text{FOLLOW}(B)$                             |
> >    | 规则$4$ | $B{\to}\alpha{A}$                                            | $\text{FOLLOW}(B)$                             |
> >
> > 3. 示例：文法的$\text{FIRST}/\text{FOLLOW}$综合示例
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250616235649908.png" alt="image-20250616235649908" width=500 /> 
> >
> > :three:产生式$A{\to}\beta$的可选集$\text{SELECT}(A{\to}\beta)$
> >
> > 1. $\text{SELECT}(A{\to}\beta)$意义：一个终结符集合，当输入流读到集合中的终结符时，必须用$A{\to}\beta$推导
> >
> > 2. $\text{SELECT}(A{\to}\beta)$规则：右部不含空取$\text{FIRST}$，若含空则并上$\text{FOLLOW}$
> >
> >    |  规则   |                 触发条件                 | $\textbf{SELECT}\boldsymbol{(A{\to}\beta)}$                  |
> >    | :-----: | :--------------------------------------: | :----------------------------------------------------------- |
> >    | 规则$1$ | $\varepsilon{\notin}\text{FIRST}(\beta)$ | $\text{FIRST}(\beta)$                                        |
> >    | 规则$2$ |  $\varepsilon{\in}\text{FIRST}(\beta)$   | $(\text{FIRST}(\beta)\backslash\{\varepsilon\}){\cup}\text{FOLLOW}(A)$ |
> >
> > 3. 示例：同样文法每个产生式的$\text{SELECT}$示例
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250617000245249.png" alt="image-20250617000245249"  width=300 /> 
>
> ## $\textbf{1.3. }$第三步: 判定$\textbf{LL(1)}$文法
>
> > ```txt
> > S-文法 ⊂ q-文法 ⊂ LL(1)文法 ⊂ 无二义性文法 ⊂ 上下文无关文法 ⊂ 所有文法
> > ```
> >
> > :one:$S\text{-}$文法：
> >
> > 1. 限制：产生式右部以终结符开始，同一非终结符$A$的各候选式的首个终结符相异
> > 2. 意义：文法无二义性(分析过程无需回溯)，无法包含空产生式(严重限制了处理能力)
> >
> > :two:$q\text{-}$文法：
> >
> > 1. 限制：每个产生式的右部或为$\varepsilon$或以不同终结符开始，最多只能有一个产生式右部为$\varepsilon$
> > 2. 意义：保留无二义性且表达能力更强(允许空产生式)，但仍无法处理左递归文法
> >
> > :three:$\text{LL(1)}$文法：
> >
> > 1. 限制：具有相同左部的产生式的$\text{SELECT}$集互不相交
> >
> > 2. 意义：实现高效$/$确定$/$无回溯的自顶向下预测分析，名称具体意义见下表
> >
> >    |   名称    | 含义                                                         |
> >    | :-------: | ------------------------------------------------------------ |
> >    | 第一个$L$ | 从左到右扫描分析输入的字符串                                 |
> >    | 第二个$L$ | 优先替换当前句型中最左边的那个非终结符，即最左推导           |
> >    |   $(1)$   | 解析的每一步，解析器只需要向前看$1$个输入符号，即确定所选产生式 |
> >
> > 3. 补充：$\text{LL(1)}$的预测分析表，即非终结符${+}$输入符号$\xrightarrow[预测]{\text{SELECT}集}$所采用的产生式
> >
> >    - 文法的$\text{SELECT}$集
> >
> >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250617000245249.png" alt="image-20250617000245249"  width=300 /> 
> >
> >    - 预测分析表  
> >
> >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250617000741767.png" alt="image-20250617000741767"   width=600 />  
> >
> ## $\textbf{1.4. }$第四步: $\textbf{LL(1)}$文法的预测分析
>
> >
> > :one:递归的预测分析法
> >
> > 1. 示例：考虑如下的文法
> >
> >    ```txt
> >    (1) <PROGRAM>  ->  program<DECLIST>:<TYPE>;<STLIST>end
> >    (2) <DECLIST>  ->  id<DECLISTN>
> >    (3) <DECLISTN> ->  ,id<DECLISTN>
> >    (4) <DECLISTN> ->  ε
> >    (5) <STLIST>   ->  s<STLISTN>
> >    (6) <STLISTN>  ->  ;s<STLISTN>
> >    (7) <STLISTN>  ->  ε
> >    (8) <TYPE>     ->  real
> >    (9) <TYPE>     ->  int
> >    ```
> >
> > 2. 核心：如果符号是终结符则与当前输入符号对比(不匹配则报错)，如果是非终结符则调用其对应过程
> >
> >    - 处理整个输入$\text{TOKEN}$
> >
> >      ```C
> >      program DESCENT;
> >      	GETNEXT(TOKEN);
> >      	PROGRAM(TOKEN);
> >      	GETNEXT(TOKEN);
> >      	if TOKEN≠’$’ then ERROR;
> >         if TOKEN=’$’ then SUCCESS;
> >      ```
> >
> >    - 处理`<PROGRAM>`产生式
> >
> >      ```C
> >      procedure PROGRAM(TOKEN);
> >      	if TOKEN≠’program’ then ERROR;
> >      	GETNEXT(TOKEN);
> >
> >      	DECLIST(TOKEN);
> >      	GETNEXT(TOKEN);
> >
> >      	if TOKEN≠’:’ then ERROR;
> >      	GETNEXT(TOKEN);
> >
> >      	TYPE(TOKEN);
> >      	GETNEXT(TOKEN);
> >
> >      	if TOKEN≠’;’ then ERROR;
> >      	GETNEXT(TOKEN);
> >
> >      	STLIST(TOKEN);
> >      	GETNEXT(TOKEN);
> >
> >      	if TOKEN≠’end’ then ERROR;
> >      ```
> >
> >    - 处理`<DECLISTN>`产生式
> >
> >      ```C
> >      procedure DECLISTN(TOKEN);
> >      	if TOKEN =‘,’ then
> >      		GETNEXT(TOKEN);
> >      		if TOKEN≠’id’ then ERROR;
> >      		if TOKEN=’id’ then CONTINUE;
> >      		GETNEXT(TOKEN);
> >      		DECLISTN(TOKEN);
> >      	else if TOKEN≠’:’ then ERROR; //<DECLISTN>->ε的SELECT集为{:}
> >      ```
> >
> >    - 处理`<TYPE>`产生式
> >
> >      ```C
> >      procedure TYPE(TOKEN);
> >      	if TOKEN≠’real’ or TOKEN≠’int’
> >      	then ERROR;
> >      ```
> >
> > :two:非递归的预测分析法
> >
> > 1. $\text{PDA}$：即下推自动机，就是有穷自动机${+}$一个栈(用于记忆输入内容)，用于非递归的预测
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250617115008915.png" alt="image-20250617115008915" width=300 /> 
> >
> > 2. 示例：参考如下文法及其预测分析表
> >
> >    - 文法的$\text{SELECT}$集
> >
> >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250617000245249.png" alt="image-20250617000245249"  width=280 /> 
> >
> >    - 预测分析表  
> >
> >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250617000741767.png" alt="image-20250617000741767"   width=500 />    
> >
> >    - 基于$\text{PDA}$的过程：输出的产生式序列就是一个最左推导
> >
> >      $\begin{array}{rrll} \hline\text{栈} & \text{剩余输入} & \text{行为} & \text{输出} \\ \hline E\texttt{\$} & \texttt{id+id*id} \texttt{\$} &开始符入栈& 栈顶E{+}指针\texttt{id}{\xrightarrow{预测分析表}}输出产生式E{\to}TE'\\ TE'\texttt{\$} & \texttt{id+id*id} \texttt{\$} &E出栈TE'入栈&栈顶T{+}指针\texttt{id}{\xrightarrow{预测分析表}}输出产生式T{\to}FT'  \\ FT'E'\texttt{\$} & \texttt{id+id*id} \texttt{\$} & T出栈FT'入栈 &栈顶F{+}指针\texttt{id}{\xrightarrow{预测分析表}}输出产生式F{\to}\texttt{id}\\ \texttt{id}T'E'\texttt{\$} & \texttt{id+id*id} \texttt{\$} & F出栈\texttt{id}入栈  &\\ T'E'\texttt{\$} & \texttt{+id*id} \texttt{\$} & \texttt{id}匹配故\texttt{id}出栈 & 栈顶T'{+}指针\texttt{+}{\xrightarrow{预测分析表}}输出产生式T'{\to}\varepsilon \\ E'\texttt{\$} & \texttt{+id*id} \texttt{\$} & T'出栈无进栈 & 栈顶E'{+}指针\texttt{+}{\xrightarrow{预测分析表}}输出产生式E'{\to}\texttt{+}TE'  \\ \texttt{+}TE'\texttt{\$} & \texttt{+id*id} \texttt{\$} &T'出栈\texttt{+}TE'进栈 \\ TE'\texttt{\$} & \texttt{id*id} \texttt{\$} & \texttt{+}匹配故\texttt{+}出栈& 栈顶T{+}指针\texttt{id}{\xrightarrow{预测分析表}}输出产生式T{\to}FT' \\ FT'E'\texttt{\$} & \texttt{id*id} \texttt{\$} &T出栈FT'进栈&栈顶F{+}指针\texttt{id}{\xrightarrow{预测分析表}}输出产生式F{\to}\texttt{id} \\ \texttt{id}T'E'\texttt{\$} & \texttt{id*id} \texttt{\$} &F出栈\texttt{id}入栈 \\ T'E'\texttt{\$} & \texttt{*id} \texttt{\$} &\texttt{id}匹配故\texttt{id}出栈& 栈顶T'{+}指针\texttt{*}{\xrightarrow{预测分析表}}输出产生式T'{\to}\texttt{*}FT' \\ \texttt{*}FT'E'\texttt{\$} & \texttt{*id} \texttt{\$} &T'出栈\texttt{*}FT'进栈&  \\ FT'E'\texttt{\$} & \texttt{id} \texttt{\$} &\texttt{*}匹配故\texttt{*}出栈&  栈顶F{+}指针\texttt{id}{\xrightarrow{预测分析表}}输出产生式F{\to}\texttt{id}\\ \texttt{id}T'E'\texttt{\$} & \texttt{id} \texttt{\$} & F出栈\texttt{id}入栈\\ T'E'\texttt{\$} & \texttt{\$} &\texttt{id}匹配故\texttt{id}出栈& 栈顶T'{+}指针\texttt{\$}{\xrightarrow{预测分析表}}输出产生式T'{\to}\varepsilon \\ E'\texttt{\$} & \texttt{\$} & T'出栈无入栈&栈顶E'{+}指针\texttt{\$}{\xrightarrow{预测分析表}}输出产生式E'{\to}\varepsilon \\ \texttt{\$} & \texttt{\$} & E'出栈无入栈 & 分析结束\\ \hline\end{array}$
> >
> > 3. 补充：非递归的预测分析的错误检测与恢复(恐慌模式)
> >
> >    - 同步词法单元：可将非终结符的$\text{FOLLOW}$集作为同步词法单元集，放入预测分析表
> >
> >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250617144115842.png" alt="image-20250617144115842" width=560 /> 
> >
> >    - 分析表的使用：如何处理三种情况的错误
> >
> >      |  错误   | 描述                                  | 操作               |
> >      | :-----: | ------------------------------------- | ------------------ |
> >      | 类型$1$ | 栈顶的终结符和输入符号不匹配          | 弹出栈顶的终结符   |
> >      | 类型$2$ | 栈顶非终结符和输入定位到分析表空单元  | 忽略输入符号       |
> >      | 类型$3$ | 栈顶非终结符和输入定位到分析表`synch` | 弹出栈顶的非终结符 |
> >
> >    - 分析示例：
> >      
> >      $\begin{array}{rrll} \hline\text{栈} & \text{剩余输入} & \text{行为} & \text{输出} \\ \hline 
> >      E\texttt{\$} & \texttt{+id*+id} \texttt{\$} &开始符入栈& \textcolor{red}{栈顶E{+}指针\texttt{+}{\xrightarrow{预测分析表}}\{\}}\\
> >      E\texttt{\$} & \texttt{id*+id} \texttt{\$} &忽略\texttt{+}指针右移& 栈顶E{+}指针\texttt{id}{\xrightarrow{预测分析表}}产生式E{\to}TE'\\
> >      TE'\texttt{\$} & \texttt{id*+id} \texttt{\$} &E出栈TE'入栈& 栈顶T{+}指针\texttt{id}{\xrightarrow{预测分析表}}产生式T{\to}FT'\\
> >      FT'E'\texttt{\$} & \texttt{id*+id} \texttt{\$} &T出栈FT'入栈& 栈顶F{+}指针\texttt{id}{\xrightarrow{预测分析表}}产生式F{\to}\texttt{id}\\
> >      \texttt{id}T'E'\texttt{\$} & \texttt{id*+id} \texttt{\$} &F出栈\texttt{id}入栈& \\
> >                T'E'\texttt{\$} & \texttt{*+id} \texttt{\$} &\texttt{id}匹配故出栈&栈顶T’{+}指针\texttt{*}{\xrightarrow{预测分析表}}产生式T'{\to}\texttt{*}FT' \\
> >      \texttt{*}FT'E'\texttt{\$} & \texttt{*+id} \texttt{\$} &T'出栈\texttt{*}FT'入栈&\\
> >      FT'E'\texttt{\$} & \texttt{+id} \texttt{\$} &\texttt{*}匹配故出栈&\textcolor{red}{栈顶F{+}指针\texttt{+}{\xrightarrow{预测分析表}}\texttt{synch}}\\
> >      T'E'\texttt{\$} & \texttt{+id} \texttt{\$} &弹出栈顶F&栈顶T'{+}指针\texttt{+}{\xrightarrow{预测分析表}}产生式T'{\to}\varepsilon\\
> >      E'\texttt{\$} & \texttt{+id} \texttt{\$} &T'出栈无入栈&栈顶E'{+}指针\texttt{+}{\xrightarrow{预测分析表}}产生式E'{\to}\texttt{+}TE'\\
> >      \texttt{+}TE'\texttt{\$} & \texttt{+id} \texttt{\$} &E'出栈\texttt{+}TE'入栈&\\
> >      TE'\texttt{\$} & \texttt{id} \texttt{\$} &\texttt{+}匹配故出栈&栈顶T{+}指针\texttt{id}{\xrightarrow{预测分析表}}产生式T{\to}FT'\\
> >      FT'E'\texttt{\$} & \texttt{id} \texttt{\$} &T出栈FT'入栈&栈顶F{+}指针\texttt{id}{\xrightarrow{预测分析表}}产生式F{\to}\texttt{id}\\
> >      \texttt{id}T'E'\texttt{\$} & \texttt{id} \texttt{\$} &F出栈\texttt{id}入栈&\\
> >      T'E'\texttt{\$} &\texttt{\$} &\texttt{id}匹配故出栈&栈顶T'{+}指针\texttt{\$}{\xrightarrow{预测分析表}}产生式T'{\to}\varepsilon
> >                \\ E'\texttt{\$} & \texttt{\$} & T'出栈无入栈&栈顶E'{+}指针\texttt{\$}{\xrightarrow{预测分析表}}产生式E'{\to}\varepsilon \\ \texttt{\$} & \texttt{\$} & E'出栈无入栈 & 分析结束\\\hline
> >       \end{array}$ 
> >           

# $\textbf{2. }$自底向上分析

> ## $\textbf{2.1. }$总论
>
> > ### $\textbf{2.1.1. }$移入规约分析
> >
> > > :one:整体流程：
> > >
> > > 1. 操作：将输入符号逐个加入栈中，直到栈顶可以并进行规约(本质上是在最左规约$/$最右推导逆过程)
> > > 2. 输出：不断重复以上过程，直至输出接收(栈只剩开始符)或错误(其他情况)
> > >
> > > :two:流程示例：
> > >
> > > 1. 文法：$E{\to}E\texttt{+}E/E{\to}E\texttt{*}/E{\to}\texttt{(}E\texttt{)}/E{\to}\texttt{id}$
> > >
> > > 2. 过程：见下表
> > >
> > >    $\begin{array}{lrll}\hline \text{栈} & \text{剩余输入} & \text{行为} & \text{规约的产生式}& \text{规约的句柄} & \text{规范句型}\\ \hline 
> > >    \texttt{\$} & \texttt{id+(id+id)} \texttt{\$} &移入& &&\texttt{\$id+(id+id)\$} \\ 
> > >    \texttt{\$id} & \texttt{+(id+id)} \texttt{\$} &规约& E{\to}\texttt{id}&\texttt{id} &\texttt{\$id+(id+id)\$}\\ 
> > >    \texttt{\$}E & \texttt{+(id+id)} \texttt{\$} &移入& & &\texttt{\$}E\texttt{+(id+id)\$}\\ 
> > >    \texttt{\$}E\texttt{+} & \texttt{(id+id)} \texttt{\$} &移入& &&\texttt{\$}E\texttt{+(id+id)\$} \\ 
> > >    \texttt{\$}E\texttt{+(} & \texttt{id+id)} \texttt{\$} &移入& &&\texttt{\$}E\texttt{+(id+id)\$} \\ 
> > >    \texttt{\$}E\texttt{+(id} & \texttt{+id)} \texttt{\$} &规约& E{\to}\texttt{id}&\texttt{id} &\texttt{\$}E\texttt{+(id+id)\$}\\ 
> > >    \texttt{\$}E\texttt{+(}E & \texttt{+id)} \texttt{\$} &移入& &&\texttt{\$}E\texttt{+(}E\texttt{+id)\$} \\ 
> > >    \texttt{\$}E\texttt{+(}E\texttt{+} & \texttt{id)} \texttt{\$} &移入&&&\texttt{\$}E\texttt{+(}E\texttt{+id)\$}  \\ 
> > >    \texttt{\$}E\texttt{+(}E\texttt{+id} & \texttt{)} \texttt{\$} &规约& E{\to}\texttt{id}&\texttt{id} &\texttt{\$}E\texttt{+(}E\texttt{+id)\$}  \\ 
> > >    \texttt{\$}E\texttt{+(}E\texttt{+}E & \texttt{)} \texttt{\$} &规约& E{\to}E\texttt{+}E&E\texttt{+}E&\texttt{\$}E\texttt{+(}E\texttt{+}E\texttt{)\$} \\ 
> > >    \texttt{\$}E\texttt{+(}E\texttt{}&  \texttt{)\$} &移入&&&\texttt{\$}E\texttt{+(}E\texttt{)\$}  \\ 
> > >    \texttt{\$}E\texttt{+(}E\texttt{)}&  \texttt{\$} &规约& E{\to}\texttt{(}E\texttt{)}&\texttt{(}E\texttt{)} &\texttt{\$}E\texttt{+(}E\texttt{)\$}\\ 
> > >    \texttt{\$}E\texttt{+}E&  \texttt{\$} &规约& E{\to}E\texttt{+}E&E\texttt{+}E &\texttt{\$}E\texttt{+}E\texttt{\$}\\ 
> > >    \texttt{\$}E&  \texttt{\$} &结束&&&\texttt{\$}E\texttt{\$}
> > >    \\\hline\end{array}$ 
> > >
> > > :three:潜在问题：
> > >
> > > 1. 描述：存在一些情况可以识别出多个句柄(句柄识别冲突)，无法识别出正确的句柄会导致分析失败
> > >
> > >    - 文法：`<S> -> var<IDS>:<T>`$/$`<IDS> -> i`$/$`<IDS> -> <IDS>,i`$/$`<T> -> real|int`
> > >
> > >    - 分析：左边为错误的句柄识别，右边为正确的
> > >
> > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250617170524822.png" alt="image-20250617170524822" width=250 />   <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250617170620427.png" alt="image-20250617170620427" width=250 /> 
> > >
> > > 2. 解决：选择句型的最左直接短语，作为句柄
> > >
> > >    - 句型：栈中的内容$+$剩余的输入串，此处为`$var<IDS>,i_B:real$`
> > >    - 短语：直接短语的集合$\subseteq$产生式右部集合，此直接短语从左到右`<IDS>,i_B`$/$`i_B`$/$`real`
> > >    - 最左：句型中存在多个直接短语时，只取最左边的那个，此处为`<IDS>,i_B`即为所选定的句柄
> >
> > ### $\textbf{2.1.2. LR}$分析法概述
> >
> > > :one:$\text{LR}$文法的基本概念
> > >
> > > 1. $\text{LR}$文法的意义：最大的，可以构造出相应移入归约语法分析器的文法类  
> > >
> > > 2. $\text{LR}(k)$的含义：
> > >
> > >    | 成分  | 含义                                 |
> > >    | :---: | ------------------------------------ |
> > >    |  $L$  | 对输入进行从左到右的扫描             |
> > >    |  $R$  | 反向构造出一个最右推导序列           |
> > >    | $(k)$ | 需要向前看$k$个输入符号，默认$k{=}1$ |
> > >
> > > :two:$\text{LR}$分析器(自动机)：即$\text{itemDFA}$
> > >
> > > 1. 总体结构：栈分为了状态栈$+$符号栈，分析表分为了动作表$+$转移表
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250617190804409.png" alt="image-20250617190804409" width=400 />  
> > >
> > >    - 分析表的构建：$\text{LR(0)/LR(1)/SLR/LALR}$分析
> > >
> > > 2. 工作过程：根据栈顶$s$与当前指针$a$查阅$\text{ACTION}$和$\text{GOTO}$表中的内容
> > >
> > >    - $\text{ACTION}[s_m,a_i]{=}sx$时$a_i$移入符号串，$x$压入状态栈
> > >
> > >      $\begin{array}{cllr}\hline\text{状态}& \text{状态栈} & \text{符号栈} & \text{剩余的输入序列}\\ \hline 
> > >      初始状态&s_0&\texttt{\$}&a_1a_2...a_ia_{i+1}...a_n\texttt{\$}\\
> > >      一般状态&s_0s_1...s_m&\texttt{\$}X_1X_2...X_m&a_ia_{i+1}...a_n\texttt{\$}\\
> > >      \text{ACTION}[s_m,a_i]{=}sx&s_0s_1...s_mx&\texttt{\$}X_1X_2...X_ma_i&a_{i+1}...a_n\texttt{\$}
> > >      \\\hline\end{array}$
> > >
> > >    - $\text{ACTION}[s_m,a_i]{=}rx$时用第$x$产生式$A{\to}X_{m-(k-1)}...X_m$规约，加状态$\text{GOTO}[s_{m-k},A]{=}y$
> > >
> > >      $\begin{array}{cllr}\hline\text{状态}& \text{状态栈} & \text{符号栈} & \text{剩余的输入序列}\\ \hline 
> > >      初始状态&s_0&\texttt{\$}&a_1...a_ia_{i+1}...a_n\texttt{\$}\\
> > >      一般状态&s_0s_1...s_{m-k}...s_m&\texttt{\$}X_1X_2...X_{m-k}...X_m&a_ia_{i+1}...a_n\texttt{\$}\\
> > >      \text{ACTION}[s_m,a_i]{=}rx&s_0s_1...s_{m-k}&\texttt{\$}X_1X_2...X_{m-k}A&a_ia_{i+1}...a_n\texttt{\$}\\
> > >      \text{GOTO}[s_{m-k},A]{=}y&s_0s_1...s_{m-k}y&\texttt{\$}X_1X_2...X_{m-k}A&a_ia_{i+1}...a_n\texttt{\$}
> > >      \\\hline\end{array}$
> > >
> > >    - $\text{ACTION}[s_m,a_i]{=}\text{acc/err}$，表示分析成功或者出现语法错误
> > >
> > > 3. 工作示例：文法$S{\to}BB/B{\to}aB/B{\to}b$，输入$bab$
> > >
> > >    - 分析表内容
> > >
> > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250617193609951.png" alt="image-20250617193609951" width=270 /> 
> > >
> > >    - 分析全过程
> > >
> > >      $\begin{array}{llrll}
> > >      \hline
> > >      \text{状态栈} & \text{符号栈} & \text{输入} & \text{ACTION} & \text{GOTO} & \text{操作} \\
> > >      \hline
> > >      0 & \texttt{\$} & bab\texttt{\$} & \text{ACTION[0,b]=s4} & & \text{传输b/状态4进} \\
> > >      04 & \texttt{\$}b & ab\texttt{\$} & \text{ACTION[4,a]=r3} & & B{\to}b \text{约/出一状态} \\
> > >      0 & \texttt{\$}B & ab\texttt{\$} & & \text{GOTO[0,B]=2} & \text{状态2进} \\
> > >      02 & \texttt{\$}B & ab\texttt{\$} & \text{ACTION[2,a]=s3} & & \text{传输a/状态3进} \\
> > >      023 & \texttt{\$}Ba & b\texttt{\$} & \text{ACTION[3,b]=s4} & & \text{传输b/状态4进} \\
> > >      0234 & \texttt{\$}Bab & \texttt{\$} & \text{ACTION[4,\texttt{\$}]=r3} & & B{\to}b \text{约/状态4出} \\
> > >      023 & \texttt{\$}BaB & \texttt{\$} & & \text{GOTO[3,B]=6} & \text{状态6进} \\
> > >      0236 & \texttt{\$}BaB & \texttt{\$} & \text{ACTION[6,\texttt{\$}]=r2} & & B{\to}aB \text{约/出两状态} \\
> > >      02 & \texttt{\$}BB & \texttt{\$} & & \text{GOTO[2,B]=5} & \text{状态5进} \\
> > >      025 & \texttt{\$}BB & \texttt{\$} & \text{ACTION[5,\texttt{\$}]=r1} & & S{\to}BB \text{约/出两状态} \\
> > >      0 & \texttt{\$}S & \texttt{\$} & & \text{GOTO[0,S]=1} & \text{状态1进} \\
> > >      01 & \texttt{\$}S & \texttt{\$} & \text{ACTION[1,\texttt{\$}]=acc} & & \text{接收} \\
> > >      \hline
> > >      \end{array}$
>
> ## $\textbf{2.2. }$分析法
>
> > ### $\textbf{2.2.1. LR(0)}$分析
> >
> > > :one:产生式的$\text{LR(0)}$项目：
> > >
> > > 1. 含义：产生式的右部某位置加上一圆圈如$A{\to}\alpha_1{\cdot}\alpha_2$，产生式右部长度为$n$时其会有$n{+}1$个项目
> > >
> > > 2. 意义：描述了句柄识别的状态，如下三种
> > >
> > >    | 类型 |      移进项目      |      待约项目      |      待约项目      |      归约项目      |
> > >    | :--: | :----------------: | :----------------: | :----------------: | :----------------: |
> > >    | 示例 | $S{\to}{\cdot}bBB$ | $S{\to}b{\cdot}BB$ | $S{\to}bB{\cdot}B$ | $S{\to}bBB{\cdot}$ |
> > >
> > >    - 后继项目：同一个产生式中将圆点右移一个，例如$A{\to}\alpha{\cdot}{X}\beta$的后继是$A{\to}\alpha{X}{\cdot}\beta$
> > >
> > > :two:文法中的$\text{LR(0)}$项目
> > >
> > > 1. 增广文法：添加一个新的开始符$S'$并且令$S'{\to}S$，从而使得分析器只有一个接收状态，示例如下
> > >
> > >    |   产生式   | 项目                                              |
> > >    | :--------: | ------------------------------------------------- |
> > >    | $S'{\to}S$ | $S'{\to}{\cdot}S/S'{\to}S{\cdot}$                 |
> > >    | $S{\to}BB$ | $S{\to}{\cdot}BB/S{\to}B{\cdot}B/S{\to}BB{\cdot}$ |
> > >    | $B{\to}aB$ | $B{\to}{\cdot}aB/B{\to}a{\cdot}B/B{\to}aB{\cdot}$ |
> > >    | $B{\to}b$  | $B{\to}{\cdot}b/B{\to}b{\cdot}$                   |
> > >
> > > 2. 初始$/$接收项目：增广文法中唯一的$S'{\to}{\cdot}S$以及$S'{\to}S{\cdot}$
> > >
> > > :three:$\text{LR(0)}$的自动机
> > >
> > > 1. 自动机的状态：文法中所有等价的项目是为一个项目集闭包，一个项目集闭包对应一个状态
> > >
> > >    - 方法：对项目$A{\to}\alpha{\cdot}{X}\beta$与产生式$X{\to}\gamma$，则$A{\to}\alpha{\cdot}{X}\beta$与$X{\to}{\cdot}\gamma$等价
> > >
> > >    - 示例：对项目$S{\to}{\cdot}BB$，考虑产生式$B{\to}aB$与$B{\to}b$，则$B{\to}{\cdot}aB$与$B{\to}{\cdot}b$等价(同理得下表)
> > >
> > >      | 状态  | 内核项目          | 项目集闭包                                                   |
> > >      | :---: | ----------------- | ------------------------------------------------------------ |
> > >      | $I_0$ | $S'{\to}{\cdot}S$ | $\text{CLOSURE}{(I_0)}{=}\{S'{\to}{\cdot}S/S{\to}{\cdot}BB/B{\to}{\cdot}aB/B{\to}{\cdot}b\}$ |
> > >      | $I_1$ | $S'{\to}S{\cdot}$ | $\text{CLOSURE}{(I_1)}{=}\{S'{\to}S{\cdot}\}$                |
> > >      | $I_2$ | $S{\to}B{\cdot}B$ | $\text{CLOSURE}{(I_2)}{=}\{S{\to}B{\cdot}B/B{\to}{\cdot}aB/B{\to}{\cdot}b\}$ |
> > >      | $I_3$ | $B{\to}a{\cdot}B$ | $\text{CLOSURE}{(I_3)}{=}\{B{\to}a{\cdot}B/B{\to}{\cdot}aB/B{\to}{\cdot}b\}$ |
> > >      | $I_4$ | $B{\to}b{\cdot}$  | $\text{CLOSURE}{(I_4)}{=}\{B{\to}b{\cdot}\}$                 |
> > >      | $I_5$ | $S{\to}BB{\cdot}$ | $\text{CLOSURE}{(I_5)}{=}\{S{\to}BB{\cdot}\}$                |
> > >      | $I_6$ | $B{\to}aB{\cdot}$ | $\text{CLOSURE}{(I_6)}{=}\{B{\to}aB{\cdot}\}$                |
> > >
> > >    - 补充：自动机的状态的集合就是**项集族**，此处为$C{=}\{I_1,I_2,...,I_6\}$
> > >
> > > 2. 状态的转换：$\text{GOTO}(I,X)$表示从状态$I$接收符号$X$后所到达的新状态
> > >
> > >    - 方法：找出$\text{CLOSURE}(I)$中所有形如$A{\to}\alpha{\cdot}X\beta$的项目，把每个的圆点右移一位，进入新状态
> > >
> > >    - 示例：示例文法所有的状态$\text{+}$转换，构成的自动机
> > >
> > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250617235954248.png" alt="image-20250617235954248"  height=270 /> 
> > >
> > > :four:$\text{LR(0)}$的分析表构 
> > >
> > > 1. 构建规则
> > >
> > >    |      类型       | 第一个条件                              | 第二个条件                            | 对表的操作                  |
> > >    | :-------------: | --------------------------------------- | ------------------------------------- | --------------------------- |
> > >    | 移进$/$待约项目 | $A{\to}\alpha{\cdot}a\beta{\in}I_i$     | $\text{GOTO}(I_i,a){=}I_j$            | $\text{ACTION}[i,a]{=}sj$   |
> > >    |  移进/待约项目  | $A{\to}\alpha{\cdot}B\beta{\in}I_i$     | $\text{GOTO}(I_i,B){=}I_j$            | $\text{GOTO}[i,B]{=}j$      |
> > >    |    归约项目     | $A{\to}\alpha{\cdot}{\in}I_i(A{\ne}S')$ | $A{\to}\alpha{\in}I_i$产生式编号为$k$ | $\text{ACTION}[i,]{=}rk$    |
> > >    |    接收项目     | $S'{\to}S{\cdot}{\in}I_i$               | $\text{N/A}$                          | $\text{ACTION}[i,\$]{=}acc$ |
> > >
> > >    - $\text{ACTION}[i,]{=}rk$表示，将状态$i$在$\text{ACTION}$表中所对应的所有终结符都设为$rk$
> > >
> > > 2. 构建示例：
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250618003121601.png" alt="image-20250618003121601" height=270 /> 
> > >
> > > :five:$\text{LR(0)}$文法的含义
> > >
> > > 1. $\text{LR(0)}$分析过程中的冲突
> > >
> > >    - 移进$/$归约冲突：自动机的某个状态，可以进行规约也可以进行移进，如图红色部分
> > >
> > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250618004027930.png" height=330 /> 
> > >
> > >    - 归约$/$归约冲突：自动机的某一个状态，可以进行多种方式的规约，如图中左下角
> > >
> > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250618004202386.png" alt="image-20250618004202386" height=210 /> 
> > >
> > > 2. $\text{LR(0)}$文法：$\text{LR(0)}$分析过程中不会产生冲突的文法，可见$\text{LR(0)}$文法${\subseteq}$上下文无关文法
> >
> > ### $\textbf{2.2.2. SLR}$分析
> >
> > > :one:核心思想：利用$\text{FOLLOW}$集消解冲突
> > >
> > > 1. 情形：在状$I$中，有$m$个($i{\in}[1,m]$)移进项目$A_i{\to}\alpha_i{\cdot}a_i\beta_i$，以及$n$个($i{\in}[1,n]$)规约项目$B_i{\to}\gamma_{i}{\cdot}$
> > > 2. 操作：如果$\{a_1,a_2,...,a_m\}$和$\text{FOLLOW}(B_1),\text{FOLLOW}(B_2),...,\text{FOLLOW}(B_n)$互不相交
> > >    - 对当前输入符号$a$，若$a{\in}\{a_1,a_2,...,a_m\}$则移进$a$
> > >    - 对当前输入符号$a$，若$a{\in}\text{FOLLOW}(B_i)$则用产生式$B_i{\to}\gamma_i$规约
> > >
> > > :two:$\text{SLR}$分析表：构造算法与示例
> > >
> > > 1. 构造算法：对规约项目，区别于将行中每个元素都规约，只将$\text{FOLLOW}(A)$对应元素规约
> > >
> > >    |      类型       | 第一个条件                              | 第二个条件                                                   | 对表的操作                  |
> > >    | :-------------: | --------------------------------------- | ------------------------------------------------------------ | --------------------------- |
> > >    | 移进$/$待约项目 | $A{\to}\alpha{\cdot}a\beta{\in}I_i$     | $\text{GOTO}(I_i,a){=}I_j$                                   | $\text{ACTION}[i,a]{=}sj$   |
> > >    |  移进/待约项目  | $A{\to}\alpha{\cdot}B\beta{\in}I_i$     | $\text{GOTO}(I_i,B){=}I_j$                                   | $\text{GOTO}[i,B]{=}j$      |
> > >    |    归约项目     | $A{\to}\alpha{\cdot}{\in}I_i(A{\ne}S')$ | $A{\to}\alpha{\in}I_i$产生式编号为$k$<br>$a{\in}\text{FOLLOW}(A)$ | $\text{ACTION}[i,a]{=}rk$   |
> > >    |    接收项目     | $S'{\to}S{\cdot}{\in}I_i$               | $\text{N/A}$                                                 | $\text{ACTION}[i,\$]{=}acc$ |
> > >
> > > 2. 构造示例：其中$\text{FOLLOW}(S'){=}\{\$\}/\text{FOLLOW}(T){=}\{\$,b\}/\text{FOLLOW}(B){=}\{d\}$
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250618110113802.png" alt="image-20250618110113802"  height=210 /> 
> > >
> > >    - 在状态$I_2$中，三个$\text{FOLLOW}$集以及$\{B,T,a\}$互不相交
> > >    - 假设$B{\to}\varepsilon$是第四条产生式，由于$\text{FOLLOW}(B){=}\{d\}$，所以$\text{ACTION}[2,d]{=}r4$
> > >    - 假设$T{\to}\varepsilon$是第二条产生式，由于$\text{FOLLOW}(T){=}\{\$,b\}$，所以$\text{ACTION}[2,\$/b]{=}r2$ 
> > >
> > > :three:$\text{SLR}$文法：无冲突
> > >
> > > 1. $\text{SLR}$冲突：$\text{FOLLOW}$集与$\{a_1,a_2,...,a_m\}$间有交集，或者$\text{FOLLOW}$集互相间有交集
> > > 2. $\text{SLR}$文法：$\text{SLR}$分析过程中不会产生冲突的文法，可见$\text{LR(0)}$文法${\subseteq}\text{SLR}$文法
> >
> > ### $\textbf{2.2.3. LR(1)}$分析
> >
> > > :zero:对$\text{SLR}$的重新思考
> > >
> > > 1. 潜在问题：$\text{SLR}$中当下一输入符$a{\in}\text{FOLLOW}(A)$就用$A{\to}\alpha$规约，但这只是规约的必要条件
> > > 2. 潜在方案：特定位置$A$后继可能是$\text{FOLLOW}(A)$子集，故规约条件变为$a{\in}\text{FOLLOW}(A)$子集
> > >
> > > :one:规范$\text{LR(1)}$项目
> > >
> > > 1. 形式：$[A{\to}\alpha{\cdot}\beta,a]$其中$A{\to}\alpha\beta$是产生式，$a$是终结符(包括$\$$)$\text{aka}$展望符，$a$长为$1$即$\text{LR(1)}$中$1$来源
> > > 2. 含义：$a$总是$\text{FOLLOW}(A)$的真子集，在规约时起作用
> > >    - 对移入项：$[A{\to}\alpha{\cdot}\beta,a]$且$\beta{\neq}\varepsilon$中，展望符$a$没有任何作用
> > >    - 对规约符：$[A{\to}\alpha{\cdot},a]$，只有在下一个输入符号为$a$时，才按照$A{\to}a$进行规约
> > >
> > > :two:$\text{LR(1)}$的自动机
> > >
> > > 1. 自动机的状态：文法中所有等价的项目是为一个项目集闭包，一个项目集闭包对应一个状态
> > >
> > >    - 方法：对项目$[A{\to}\alpha{\cdot}{B}\beta,a]$与产生式$B{\to}\gamma$，则$[A{\to}\alpha{\cdot}{B}\beta,a]$与$[B{\to}\gamma,b]$等价，$b$值如下表
> > >
> > >      |                 条件                 | 值                             | 备注         |
> > >      | :----------------------------------: | ------------------------------ | ------------ |
> > >      | $\beta{\xRightarrow{}^+}\varepsilon$ | $b{=}a$直接继承                | 继承的后继符 |
> > >      |               其他情况               | $b{\in}\text{FIRST}(\beta{a})$ | 自生的后继符 |
> > >
> > >    - 示例：考虑文法$S'{\to}S/S{\to}L{=}R/S{\to}R/L{\to}{*}R/L{\to}\text{id}/R{\to}L$，状态$I_0$构造如下
> > >
> > >      |  步  | 加入操作                                               | 说明                                                         |
> > >      | :--: | ------------------------------------------------------ | ------------------------------------------------------------ |
> > >      | $1$  | $[S'{\to}{\cdot}S,\$]$                                 | 初始项目，其后必跟$\$$                                       |
> > >      | $2$  | $[S{\to}{\cdot}L{=}R,\$]/[S{\to}{\cdot}R,\$]$          | 基于$[S'{\to}{\cdot}S,\$]$考虑$S$俩产生式，${\cdot}S$后为空故继承$\$$ |
> > >      | $3$  | $[L{\to}{\cdot}{*}R,{=}]/[L{\to}{\cdot}\text{id},{=}]$ | 基于$[S{\to}{\cdot}L{=}R,\$]$考虑$L$俩产生式，${\cdot}L$后为$=$故生${=}$ |
> > >      | $4$  | $[R{\to}{\cdot}L,\$]$                                  | 基于$[S{\to}{\cdot}R,\$]$考虑$R$产生式，${\cdot}R$后为空故继承$\$$ |
> > >      | $5$  | $[L{\to}{\cdot}{*}R,\$]/[L{\to}{\cdot}\text{id},\$]$   | 基于$[R{\to}{\cdot}L,\$]$考虑$L$俩产生式，${\cdot}L$后为空故继承$\$$ |
> > >
> > > 2. 状态的转换：与$\text{LR(0)}$完全一样，$\text{GOTO}(I,X)$表示从状态$I$接收符号$X$后所到达的新状态
> > >
> > >    - 方法：找出$\text{CLOSURE}(I)$中所有$A{\to}\alpha{\cdot}X\beta$项目，把圆点右移一位(展望符不变)，进入新状态
> > >
> > >    - 示例：示例文法所有的状态$\text{+}$转换，构成的自动机
> > >
> > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250618124533712.png" alt="image-20250618124533712" height=350 /> 
> > >
> > >    - 补充：除展望符外两个$\text{LR(1)}$项目集相同，则这俩$\text{LR(1)}$的项目集(状态)是同心的
> > >
> > > :three:$\text{LR(0)}$的分析表构 
> > >
> > > 1. 构建规则：
> > >
> > >    |   类型   | 第一个条件                                  | 第二个条件                            | 对表的操作                  |
> > >    | :------: | ------------------------------------------- | ------------------------------------- | --------------------------- |
> > >    | 待约项目 | $[A{\to}\alpha{\cdot}a\beta,b]{\in}I_i$     | $\text{GOTO}(I_i,a){=}I_j$            | $\text{ACTION}[i,a]{=}sj$   |
> > >    | 待约项目 | $[A{\to}\alpha{\cdot}B\beta,b]{\in}I_i$     | $\text{GOTO}(I_i,B){=}I_j$            | $\text{GOTO}[i,B]{=}j$      |
> > >    | 归约项目 | $[A{\to}\alpha{\cdot},a]{\in}I_i(A{\ne}S')$ | $A{\to}\alpha{\in}I_i$产生式编号为$k$ | $\text{ACTION}[i,a]{=}rk$   |
> > >    | 接收项目 | $S'{\to}S{\cdot}{\in}I_i$                   | $\text{N/A}$                          | $\text{ACTION}[i,\$]{=}acc$ |
> > >
> > > 2. 构建示例：上图自动机的分析表(节选)
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250618131418378.png" alt="image-20250618131418378" height=200 /> 
> >
> > ### $\textbf{2.2.4. LALR}$分析
> >
> > > :zero:重新思考$\text{LR(1)}$文法
> > >
> > > 1. 核心：通过引入展望符，将原来在$\text{LR(0)}$中只有一个的状态，分裂出了不同但同心的状态
> > > 2. 问题：状态数量会直接爆炸，如果两个状态的行为不存在冲突，是否可进行合并$?$($\text{LALR}$分析)
> > >
> > > :one:$\text{LALR}$分析的基本思想
> > >
> > > 1. 找$\text{LL(1)}$中相同核心的项集：所谓相同**核心**，即状态中刨除展望符外构成的集合一样
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250618134804470.png" alt="image-20250618134804470" height=340 /> 
> > >
> > >    - 如图中$I_4/I_{11}$及$I_7/I_{13}$及$I_8/I_{10}$及$I_5/I_{12}$
> > >
> > > 2. 合并具有相同核心的项集：如图所示
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250618135248771.png" alt="image-20250618135248771" height=340 /> 
> > >
> > >    |   同心项集   |  待替换  |            原状态转移(消除)             |            替换后状态转移             | 是否要构造 |
> > >    | :----------: | :------: | :-------------------------------------: | :-----------------------------------: | :--------: |
> > >    | $I_4/I_{11}$ | $I_{11}$ |     $I_{11}{\xrightarrow{*}}I_{11}$     |     $I_{4}{\xrightarrow{*}}I_{4}$     |     ❌      |
> > >    | $I_4/I_{11}$ | $I_{11}$ |      $I_6{\xrightarrow{*}}I_{11}$       |      $I_6{\xrightarrow{*}}I_{4}$      |     ✅      |
> > >    | $I_5/I_{12}$ | $I_{12}$ | $I_{11}{\xrightarrow{\text{id}}}I_{12}$ | $I_{4}{\xrightarrow{\text{id}}}I_{5}$ |     ❌      |
> > >    | $I_5/I_{12}$ | $I_{12}$ | $I_{6}{\xrightarrow{\text{id}}}I_{12}$  | $I_{6}{\xrightarrow{\text{id}}}I_{5}$ |     ✅      |
> > >    | $I_8/I_{10}$ | $I_{10}$ |     $I_{6}{\xrightarrow{L}}I_{10}$      |     $I_{6}{\xrightarrow{L}}I_{8}$     |     ✅      |
> > >    | $I_7/I_{13}$ | $I_{13}$ |     $I_{11}{\xrightarrow{R}}I_{13}$     |     $I_{4}{\xrightarrow{R}}I_{7}$     |     ❌      |
> > >
> > >    - 删除第二列所有状态$\&$第三列所有转换，构建第三列所有转换，即完成了$\text{LR(1)}{\to}\text{LARA}$转换
> > >
> > > 3. 构建状态表：和$\text{LR(1)}$别无二致
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250618141840704.png" alt="image-20250618141840704" height=340 /> 
> > >
> > > :two:$\text{LARA}$的特点
> > >
> > > 1. 合并项集的影响
> > >
> > >    - 可能会产生规约$\text{-}$规约冲突，如下图$I_9/I_6$的合并；但不会带来规约$\text{-}$移进的冲突
> > >
> > >      <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250618142848312.png" alt="image-20250618142848312" height=300 /> 
> > >
> > >    - 当输入错误串，较未合并的$\text{LR(1)}$分析，会使得错误的发现更晚更繁琐(合并后决策精度更模糊)
> > >
> > > 2. $\text{LARA}$对比：形式同$\text{LR(1)}$，大小减到和$\text{LR(0)/SLR}$相当，分析力$\text{SLR<LALR(1)<LR(1)}$ 
>
> ## $\textbf{2.3. }$补充
>
> > :one:二义性文法的$\text{LR}$分析
> >
> > 1. 文法：$E{\to}E{+}E/E{\to}E{*}E/E{\to}(E)/E{\to}\text{id}$，其中$\text{FOLLOW}(E){=}\{{+},{*},{)},\$\}$
> >
> > 2. 自动机：以$I_7$为例，出现移入规约冲突
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250618145639435.png" alt="image-20250618145639435" height=300 /> 
> >
> >    - 例如状态$I_7$中当前输入为${+}$：可规约也可移入，但是强行设置只能规约，冲突解决
> >    - 例如状态$I_7$中当前输入为${*}$：可规约也可移入，但是强行设置只能移入，冲突解决
> >
> > :two:$\text{LR}$分析的错误处理(恐慌模式)
> >
> > 0. 情形：状态栈$s_0,s_1,...,s_i,s_{i+1},...,s_m$，符号栈$X_1,...,X_i,A,...,X_m$
> > 1. 第一步：遇到错误后从状态栈自顶向下扫描
> >    - 定位到$s_i$状态，定位的依据是$s_i$对应符号栈的非终结符$A$出发的$\text{GOTO}$的目标
> >    - 认为这个$A$推导出的串包含错误
> > 2. 第二步：丢弃若干输入符号，直到输入可以合法地跟在$A$之后的符号$a$为止，例如$\text{C}$中的`;`
> > 3. 第三步：强行修改状态，将$s_{i+1}{=}\text{GOTO}(s_i,A)$压入栈



















