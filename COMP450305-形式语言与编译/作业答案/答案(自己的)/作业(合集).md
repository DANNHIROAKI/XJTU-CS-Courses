# 第一次作业

> ## ✅练习$\textbf{1.3}$
>
> > :zero:前提：图中是一个滚木雷石玩具，在$A$或$B$垛口处扔下一个木球，机关$x_1、x_2$和$x_3$让木球落向左方或右方，每当一个木球遇到一个机关时，就引起这个机关在木球通过之后改变方向，所以下一个木球会走相反的暗
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250602080531207.png" alt="image-20250602080531207" width=150 />  
> >
> > :one:第一问：用有穷自动机为这个玩具建模。设输入为从垛口$A$或$B$扔进一个木球。设接受对应于木球从$D$或$E$垛口出来，不接受则表示木球从$C$垛口出来
> >
> > 1. 核心逻辑和规则
> >
> >    - 状态表示：用一个三位二进制数$\left(s_1 s_2 s_3\right)$来表示三个机关$x_1, x_2, x_3$的状态；$s_i{=}0$表示机关$x_i$将球导向左边，$s_i{=}1$表示导向右边
> >    - 初始状态：所有机关都向左，即$000$
> >    - 机关翻转：每当一个木球通过一个机关后，该机关的方向会立即改变($0$变$1$或$1$变$0$)
> >    - 接受条件：木球从$D$或$E$口出来则为接受(标记为$a$)，从$C$口出来则为不接受(标记为$r$)
> >
> > 2. 输入$A$的路径分析
> >
> >    - 球进入首先遇到机关$x_2$，球按$x_2$的当前方向通过后$x_2$翻转
> >    - 然后球遇到机关$x_3$，球按$x_3$的当前方向通过(若向左则到$D/$若向右则到$E$)后$x_3$翻转
> >    - 机关$x_1$的状态在此过程中不改变
> >    - 由于球总是从$D$或$E$出来，所以输入$A$的结果总是接受(标记为$a$)
> >
> > 3. 输入$B$的路径分析
> >
> >    - 球进入首先遇到机关$x_1$，球按$x_1$的当前方向通过后$x_1$翻转
> >    - 如果$x_1$当前指向左边(即$s_1{=}0$)：球被导向机关$x_3$，球按$x_3$的当前方向通过(若向左则到$D/$若向右则到$E)$后$x_3$翻转，机关$x_2$的状态不改变，结果为接受$(a)$
> >    - 如果$x_1$当前指向右边(即$s_1{=}1$)：球直接被导向出口$C$，机关$x_2$和$x_3$的状态不改变(因为球末通过它们)，结果为不接受$(r)$
> >
> > 4. 状态转换表
> >
> >    | 当前状态$\boldsymbol{\left(s_1 s_2 s_3\right)}$ | 输入$\boldsymbol{A}$(下一状态: $\boldsymbol{s_1s_2^{\prime}s_3^{\prime}}$,出口,结果) | 输入$\boldsymbol{B}$(下一状态: $\boldsymbol{s_1^{\prime}s_2s_3^{\prime}}$或$\boldsymbol{s_1^{\prime}s_2s_3}$,出口,结果) |
> >    | :---------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> >    |                      $000$                      |                  $(011),D,a$($x_2,x_3$翻转)                  |                  $(101),D,a$($x_1,x_3$翻转)                  |
> >    |                      $001$                      |                  $(010),E,a$($x_2,x_3$翻转)                  |                  $(100),E,a$($x_1,x_3$翻转)                  |
> >    |                      $010$                      |                  $(001),D,a$($x_2,x_3$翻转)                  |                  $(111),D,a$($x_1,x_3$翻转)                  |
> >    |                      $011$                      |                  $(000),E,a$($x_2,x_3$翻转)                  |                  $(110),E,a$($x_1,x_3$翻转)                  |
> >    |                      $100$                      |                  $(111),D,a$($x_2,x_3$翻转)                  |                    $(000),C,r$($x_1$翻转)                    |
> >    |                      $101$                      |                  $(110),E,a$($x_2,x_3$翻转)                  |                    $(001),C,r$($x_1$翻转)                    |
> >    |                      $110$                      |                  $(101),D,a$($x_2,x_3$翻转)                  |                    $(010),C,r$($x_1$翻转)                    |
> >    |                      $111$                      |                  $(100),E,a$($x_2,x_3$翻转)                  |                    $(011),C,r$($x_1$翻转                     |
> >
> > :two:第二问：用自然语言描述这个自动机的语言
> >
> > - 该自动机接受的语言是所有由从$A$口扔球(记为$A$)或从$B$口扔球(记为$B$)组成的序列，且当序列中的最后一个球被扔下后，该球最终从$D$口或$E$口出来
>
> ## ✅练习$\textbf{1.5}$
>
> > :zero:分别写出下列语言的字母表并依次判断符号串`ε/123./+5e6`是不是那个字母表上的符号串
> >
> > |        语言        | 字母表                            | `ε`  | `123.` | `+5e6` |
> > | :----------------: | :-------------------------------- | :--: | :----: | :----: |
> > | 无符号八进制定点数 | `{0,1,2,3,4,5,6,7,.}`             |  ✅   |   ✅    |   ❌    |
> > | 有符号十进制定点数 | `{0,1,2,3,4,5,6,7,8,9,+,-,.}`     |  ✅   |   ✅    |   ❌    |
> > |   非负十进制实数   | `{0,1,2,3,4,5,6,7,8,9,.,e,E,+,-}` |  ✅   |   ✅    |   ✅    |
> >
>
> ## ✅练习$\textbf{1.7}$ 
>
> > :zero:写出字母表$\{+,0,1\}$上同时满足如下条件的语言$B$：
> >
> > - 同时满足串的长度不超过$4$及串除以$5$余数为$0$的串一定属于$B$
> >
> > :one:解答：$\{0,00,000,0000,101,0101,1010,1111,+0,+00,+000,+101\}$  
> >
> > 1. 字母表和条件：语言$B$定义在字母表$\{+,0,1\}$上，字符串$s$属于$B$的条件是：
> >    - 字符串长度$|s|{\leq}4$
> >    - 字符串所代表的数值$v(s)$能被$5$整除$(v(s)(\bmod5){=}0)$
> > 2. 数值范围：对于纯数字组成的串(不含${+}$)，长度不超过$4$，最大二进制数为$1111_2{=}15_{10}$
> >    - 因此，我们关心的能被$5$整除的数值是$0,5,10,15$
> > 3. 分类讨论：不含${+}$的串即纯二进制数，有$\{0,00,000,0000,101,0101,1010,1111\}$
> >    - 数值$0$：$0/00/000/0000$，这些串长度分别为$1/2/3/4$均满足长度条件，其数值都为$0$且$0\%5{=}0$
> >    - 数值$5$：对$101$(长度$3$)和$0101$(长度$4$)，有$101_2{=}5$以及$0101_2{=}5$且$5\%5{=}0$
> >    - 数值$10$：对$1010$(长度$4$)，有$1010_2{=}10$且$10\%5{=}0$
> >    - 数值$15$：对$1111$(长度$4$)，有$1111_2{=}15$且$15\%5{=}0$
> > 4. 分类讨论：含${+}$的串(形式为$+s^{\prime}$其中$s^{\prime}$为二进制数)，有$\{+0,+00,+000,+101\}$
> >    - 约束条件：总长度$1{+}\left|s^{\prime}\right|{\leq}4\Longrightarrow\left|s^{\prime}\right|{\leq}3$ 
> >    - 数值$v\left(s^{\prime}\right)$需满足$v\left(s^{\prime}\right)(\bmod5){=}0$
> >    - 数值$0$($s^{\prime}$代表$0$)：
> >      - $s^{\prime}{=}0$(长度$1$)$\Longrightarrow{+}0$(总长度$2$)
> >      - $s^{\prime}{=}00$(长度$2$)$\Longrightarrow{+}00$(总长度$3$)
> >      - $s^{\prime}{=}000$(长度$3$)$\Longrightarrow{+}000$(总长度$4$)
> >    - 数值$5$($s^{\prime}$代表$5$)：
> >      - $s^{\prime}{=}101$(长度$3$)$\Longrightarrow{+}101$(总长度$4$)
> >    - 对于数值$10$($s^{\prime}{=}1010$长度$4$)或数值$15$($s^{\prime}{=}1111$长度$4$)，有$\left|s^{\prime}\right|{>}3$故不满足条件
> > 5. 合并为：$\{0,00,000,0000,101,0101,1010,1111,+0,+00,+000,+101\}$ 
>
> ## ✅练习$\textbf{2.1}$ 
>
> > :one:写出字母表$\{0,1\}$上下列语言的$\text{DFA}$：无符号二进制定点数，不含后$0$ 
> >
> > 1. 设该语言为$L$，则$L$的字符串定义如下
> >
> >    - 字符串$0$
> >    - 以$1$开头，并以$1$结尾的字符串(例如$1/11/101$)
> >
> > 2. 定义以下五个状态：
> >
> >    |              状态              | 描述                                                         |
> >    | :----------------------------: | ------------------------------------------------------------ |
> >    |         初始状态$Q_S$          | 还没有读取任何输入                                           |
> >    |     接受状态$Q_{z e r o}$      | 当前读取的字符串是$0$                                        |
> >    |  接受状态$Q_{\text {ends} 1}$  | 当前读取的字符串以$1$开头，并且以$1$结尾(例如$1/11/101$)     |
> >    | 非接受状态$Q_{\text {ends0 }}$ | 当前读取的字符串以$1$开头，但以$0$结尾(例如$10/110$)         |
> >    |  降阱状态$Q_{\text {trap }}$   | 已经进入了一个无效的序列(例如读取了$00$或$01$)，不再接受任何后续输入 |
> >
> > 3. $\text{DFA}$的组成部分
> >
> >    - 字母表$\sum$：$\{0,1\}$ 
> >    - 状态集合$K$：$\{Q_S,Q_{z e r o},Q_{\text {ends} 1},Q_{\text {ends0 }},Q_{\text {trap }}\}$其中$Q_S$是初始状态及$\{Q_{z e r o},Q_{\text {ends} 1}\}$是接受状态集
> >
> > 4. $\text{DFA}$转换关系$\delta$
> >
> >    | 当前$\boldsymbol{Q}$  |      输入$\boldsymbol{0}$后$\boldsymbol{\delta(Q, 0)}$       |      输入$\boldsymbol{1}$后$\boldsymbol{\delta(Q, 1)}$       |
> >    | :-------------------- | :----------------------------------------------------------: | :----------------------------------------------------------: |
> >    | $Q_S$                 | $Q_{\text {zero }}$，即$\delta\left(Q_S, 0\right){=}Q_{\text {zero }}$ | $Q_{\text {ends1 }}$，即$\delta\left(Q_S, 1\right){=}Q_{\text {ends1 }}$ |
> >    | $Q_{\text {zero }}$   | $Q_{\text {trap }}$，即$\delta\left(Q_{\text {zero }}, 0\right){=}Q_{\text {trap }}$ | $Q_{\text {trap }}$，即$\delta\left(Q_{\text {zero }}, 1\right){=}Q_{\text {trap }}$ |
> >    | $Q_{\text {ends } 1}$ | $Q_{\text {ends0 }}$，即$\delta\left(Q_\text {ends1 } , 0\right){=}Q_\text {ends0 }$ | $Q_{\text {ends1 }}$，即$\delta\left(Q_\text {ends1 } , 1\right){=}Q_\text {ends1 }$ |
> >    | $Q_{\text {ends0 }}$  | $Q_{\text {ends0 }}$，即$\delta\left(Q_\text {ends0 } , 0\right){=}Q_\text {ends0 }$ | $Q_{\text {ends1 }}$，即$\delta\left(Q_\text {ends0 } , 1\right){=}Q_\text {ends1 }$ |
> >    | $Q_{\text {trap }}$   | $Q_{\text {trap }}$，即$\delta\left(Q_{\text {trap }}, 0\right){=}Q_{\text {trap }}$ | $Q_{\text {trap }}$，即$\delta\left(Q_{\text {trap }}, 1\right){=}Q_{\text {trap }}$ |
> >
>
> ## ✅练习$\textbf{2.3}$ 
>
> > :zero:设$A$是一个$\text{DFA}$，$a$是$A$的一个输入符号，使得对于$A$的所有状态$q$有$v(q,a){=}q$
> >
> > :one:通过对$n$进行归纳证明：对所有$n{\geqslant}0,\tilde{v}\left(q,a^n\right){=}q$，其中$a^n$是由$n$个$a$组成的串
> >
> > 1. 基础情况($n{=}0$)：
> >    - 当$n{=}0$时有$a^n{=}a^0{=}\varepsilon$ 
> >    - 根据扩展状态转移函数 $\tilde{v}$ 的定义，对于任何状态 $q$ ，有$\tilde{v}(q, \epsilon){=}q$
> >    - 因此$\tilde{v}\left(q, a^0\right){=}q$，即当 $n{=}0$ 时命题成立
> > 2. 归纳假设：
> >    - 假设对于某个非负整数$k{ \geq} 0$ 命题成立，即对于自动机$A$的所有状态$q$有$\tilde{v}\left(q, a^k\right){=}q$
> > 3. 归纳步骤：
> >    - 需要证明当$n{=}k{+}1$时命题也成立，即需证明$\tilde{v}\left(q, a^{k{+}1}\right){=}q$
> >    - 字符串$a^{k{+}1}$可看作是字符串$a^k$后面跟着一个符号$a$，即$a^{k{+}1}{=}a^ka$
> >    - 根据函数$\tilde{v}$的递归定义$\tilde{v}\left(q, w a^{\prime}\right){=}v\left(\tilde{v}(q, w), a^{\prime}\right)$，其中$w$是一个字符串，$a^{\prime}$是一个输入符号
> >    - 令$w{=}a^k/a^{\prime}{=}a$则$\tilde{v}\left(q, a^{k{+}1}\right){=}\tilde{v}\left(q, a^k a\right){=}v\left(\tilde{v}\left(q, a^k\right), a\right)$
> >    - 根据我们的归纳假设$\tilde{v}\left(q,a^k\right){=}q$，所以将此代入上式得$\tilde{v}\left(q, a^{k{+}1}\right){=}v(q, a)$
> >    - 根据题目给定的条件，对于自动机$A$的所有状态$q$都有$v(q,a){=}q$，因此$\tilde{v}\left(q, a^{k{+}1}\right){=}q$  
> >    - 所以当$n{=}k{+}1$时命题也成立，证毕
> >
> > :two:证明：要么$\{a\}^*{\subseteq}L(A)$，要么$\{a\}^*{\cap}L(A){=}\emptyset$
> >
> > 1. 利用:one:部分的结论，我们将$q$替换为初始状态$q_0$得到$\tilde{v}\left(q_0, a^n\right){=}q_0$
> > 2. 将此代入上述接受条件，我们得到$a^n {\in} L(A) \Longleftrightarrow q_0 {\in} F$
> > 3. 这个条件($q_0 {\in} F$)不依赖于$n$，因此它对于所有$a^n {\in}\{a\}^*$成立，现在考虑两种情况：
> >    - $q_0$是接受状态：即$q_0{\in}F$ 为真故${\forall}n{\geq}0, a^n{\in}L(A)$为真，即$\{a\}^*$中每一个字符串都被$A$接受$\{a\}^*{\subseteq}L(A)$
> >    - $q_0$非接受状态：即$q_0{\notin}F$ 为真故${\forall}n{\geq}0, a^n{\notin}L(A)$为真，即$\{a\}^*$中无一个字符串都被$A$接受$\{a\}^*{\cap}L(A){=}\emptyset$
> > 4. 结合两种情况，证毕
>
> ## ✅练习$\textbf{2.4}$ 
>
> > :zero:考虑$\text{DFA}$：$(\{A,B\},\{0,1\},\{(A,0,A),(A,1,B),(B,0,B),(B,1,A)\},A,\{B\})$，描述这个$\text{DFA}$语言，通过对输入串的长度进行归纳，证明该描述是正确的
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250602112229974.png" alt="image-20250602112229974" width=250 /> 
> >
> > :one:$01$串里有奇数个$1$
> >
> > :two:证明：设输入串为$w$
> >
> > 1. 当$|w|{=}1$时
> >    - $w{=}\{0\}$则$\hat{\delta}(A,w){=}\hat{\delta}(A,0){=}A$，有$0$个$1$
> >    - $w{=}\{1\}$则$\hat{\delta}(A,w){=}\hat{\delta}(A,1){=}B$，有$1$个$1$
> > 2. 设$|w|{=}k$
> >    - 假设：假设对于长度为$k$的任意字符串$x$
> >      - 如果$x$中有偶数个$1$，则$\hat{\delta}(A, x){=}A$
> >      - 如果$x$中有奇数个$1$，则$\hat{\delta}(A, x){=}B$
> >    - 归纳：现在考虑长度为$k{+}1$的字符串$w^{\prime}$，将$w^{\prime}$写成$x a$的形式(其中$x$长为$k$以及$a{\in}\{0,1\}$)
> >      - 对$\hat{\delta}(A,x){=}A$及$w^{\prime}{=}x 0$，有$\hat{\delta}(A, x 0){=}\delta(A, 0){=}A$，$x0$中有偶数个$1$
> >      - 对$\hat{\delta}(A,x){=}A$及$w^{\prime}{=}x 1$，有$\hat{\delta}(A, x 1){=}\delta(A, 1){=}B$，$x1$中有奇数个$1$
> >      - 对$\hat{\delta}(A,x){=}B$及$w^{\prime}{=}x 0$，有$\hat{\delta}(A, x 0){=}\delta(B, 0){=}B$，$x0$中有奇数个$1$
> >      - 对$\hat{\delta}(A,x){=}B$及$w^{\prime}{=}x 1$，有$\hat{\delta}(A, x 1){=}\delta(B, 1){=}A$，$x1$中有偶数个$1$
> >    - 总结：归纳假设成立，证毕
> >      - 如果$w^{\prime}$中有偶数个$1$则 $\hat{\delta}\left(A, w^{\prime}\right){=}A$，如果$w^{\prime}$中有奇数个$1$则$\hat{\delta}\left(A, w^{\prime}\right){=}B$
> >      - 由于$B$是唯一的接受状态，所以该$\text{DFA}$接受所有包含奇数个$1$的字符串
>
> ## ✅习题$\textbf{2.6}$
>
> > :zero:考虑下列$\varepsilon\text{-}\text{NFA}$
> >
> > |           |   $a$   |   $b$   |   $c$   | $\varepsilon$ |
> > | :-------: | :-----: | :-----: | :-----: | :-----------: |
> > | ${\to} q$ | $\{\}$  | $\{q\}$ | $\{p\}$ |    $\{r\}$    |
> > |    $p$    | $\{q\}$ | $\{p\}$ | $\{r\}$ |    $\{\}$     |
> > |   $^*r$   | $\{p\}$ | $\{r\}$ | $\{\}$  |    $\{q\}$    |
> >
> > :one:计算每个状态的$\varepsilon$闭包
> >
> > 1. $\operatorname{ECLOSE}(q){=}\{q, r\}$ 
> > 2. $\operatorname{ECLOSE}(p){=}\{p\}$
> > 3. $\operatorname{ECLOSE}(r){=}\{q, r\}$
> >
> > :two:给出这个自动机所接受的长度不大于$3$的串
> >
> > 1. **长度$0$**：$\varepsilon$
> >    - 起始状态$q$的$\varepsilon$闭包是$\{q, r\}$，因为包含了接受状态$r$，所以空串$\varepsilon$被接受✅
> > 2. **长度$1$**：$b$ 
> >    - 从初始状态集$\{q, r\}$，输入$a$后$\operatorname{ECLOSE}(\delta(q, a) {\cup} \delta(r, a)){=}\operatorname{ECLOSE}(\emptyset {\cup}\{p\}){=}\{p\}$(不包含$r$)
> >    - 从初始状态集$\{q, r\}$，输入$b$后$\operatorname{ECLOSE}(\delta(q, b) {\cup} \delta(r, b)){=}\operatorname{ECLOSE}(\{q\} {\cup}\{r\}){=}\{q,r\}$(包含$r$)✅
> >    - 从初始状态集$\{q, r\}$，输入$c$后$\operatorname{ECLOSE}(\delta(q, c) {\cup} \delta(r, c)){=}\operatorname{ECLOSE}(\{p\}{\cup}\emptyset ){=}\{p\}$(不包含$r$)
> > 3. **长度$2$**：$aa/ac/bb/ca/cc$
> >    - $aa{:} S_0 {\xrightarrow{a}}\{p\} {\xrightarrow{a}} \operatorname{ECLOSE}(\delta(p, a)){=}\operatorname{ECLOSE}(\{q\}){=}\{q, r\}$(接受)✅
> >    - $ac{:} S_0 {\xrightarrow{a}}\{p\} {\xrightarrow{c}} \operatorname{ECLOSE}(\delta(p, c)){=}\operatorname{ECLOSE}(\{r\}){=}\{q, r\}$(接受)✅
> >    - 等等等
> > 4. **长度$3$**：$aab/aba/abc/acb/baa/bac/bbb/bca/bcc/cab/cba/cbc/ccb$ 
> >    - $a a b: S_0{\xrightarrow{a}}\{p\}{\xrightarrow{a}}\{q, r\}{\xrightarrow{b}}\{q, r\}$(接受)✅
> >    - $a b a: S_0{\xrightarrow{a}}\{p\}{\xrightarrow{b}}\{p\}{\xrightarrow{a}}\{q, r\}$(接受)✅
> >    - 等等等
> >
> > :three:把这个自动机转换为$\text{DFA}$
> >
> > | $\textbf{DFA}$状态 (包含的NFA状态) | 输入$\boldsymbol{a}$ | 输入$\boldsymbol{b}$ | 输入$\boldsymbol{c}$ | 是否接受状态? |
> > | :--------------------------------: | :------------------: | :------------------: | :------------------: | :-----------: |
> > | ${\to}S_{\mathrm{A}}^*{=}\{q, r\}$ |        $S_B$         |        $S_A$         |        $S_B$         |      是       |
> > |           $S_B{=}\{p\}$            |        $S_A$         |        $S_B$         |        $S_A$         |      否       |
> >
> > 1. $S_A$是起始状态，用$\to$标记
> > 2. $S_A$是接受状态，用$*$标记(因为它包含了$\text{NFA}$的接受状态$r$)
> > 3. $S_B$不是接受状态
>
> ## ✅习题$\textbf{2.7}$
>
> > :zero:已知$\text{NFA}$如转移表所示
> >
> > |          | $\textbf{0}$ | $\textbf{1}$ | $\boldsymbol{\varepsilon}$ |
> > | :------: | :----------: | :----------: | :------------------------: |
> > | ${\to}1$ |              |              |         $\{2,6\}$          |
> > |   $2$    |   $\{3\}$    |              |          $\{1\}$           |
> > |   $3$    |              |              |          $\{4\}$           |
> > |   $4$    |              |   $\{5\}$    |                            |
> > |   $5$    |              |              |         $\{2,8\}$          |
> > |   $6$    |   $\{7\}$    |              |                            |
> > |   $7$    |              |              |          $\{8\}$           |
> > |  $^*8$   |              |              |                            |
> >
> > :one:计算状态$5$的$\varepsilon$闭包：闭包是$\{1,2,5,6,8\}$
> >
> > 1. 初始集合为$\{5\}$
> > 2. 从状态$5$出发，通过$\varepsilon$转换可以到达状态$2$和状态$8$，集合更新为$\{5,2,8\}$ 
> > 3. 从状态$2$出发，通过$\varepsilon$转换可以到达状态$1$，集合更新为$\{5,2,8,1\}$ 
> > 4. 从状态$1$出发，通过$\varepsilon$转换可以到达状态$2$(已在集合中)和状态$6$，集合更新为$\{5,2,8,1,6\}$
> > 5. 状态$8$和状态$6$没有$\varepsilon$出转换
> >
> > :two:用自然语言描述这个自动机所识别的语言(尽可能简短明了)
> >
> > 1. 必须以$0$开头
> >    - 从起始状态$1$开始，通过$\varepsilon$-转移可以到达状态$2$或状态$6$
> >    - 如果走路径$1 {\xrightarrow{\varepsilon}} 6 {}{\xrightarrow{0}} 7 {\xrightarrow{\varepsilon}} 8$(接受状态)，则接受了单个字符$0$
> >    - 如果走路径 $1 {\xrightarrow{\varepsilon}} 2 {\xrightarrow{0}} 3 {\xrightarrow{\varepsilon}} 4 \ldots$ ，第一个实际消耗的符号也是$0$
> >    - 任何以$1$开头的字符串都无法使自动机离开初始的$\varepsilon$-闭包 $\{1,2,6\}$去匹配$1$并最终到达接受状态
> > 2. 让$0$和$1$严格交替出现
> >    - 接受$0$：如上所述
> >    - 接受$01$：路径$1{\xrightarrow{\varepsilon}}2{\xrightarrow{0}}3{\xrightarrow{\varepsilon}}4\xrightarrow{1}5{\xrightarrow{\varepsilon}}8$
> >    - 接受$010$：接受$01$到状态$5$后，由于$\varepsilon\text{-closure}(5){=}\{1,2,5,6,8\}$自动机可等效地也处于状态$1/2/6$
> >      - 从状态$5{\xrightarrow{\varepsilon}}1{\xrightarrow{\varepsilon}}6{\xrightarrow{0}}7{\xrightarrow{\varepsilon}}8$，这样在$01$之后再读入一个$0$可以到达接受状态
> >      - 从状态$5{\xrightarrow{\varepsilon}}2{\xrightarrow{0}}3\ldots$(这条路在读入$0$后，若想接受需要再读入$1$才能通过$4\xrightarrow{1}5{\xrightarrow{\varepsilon}}8$)
> >    - 接受$\text{0101}$：在$\text{010}$之后自动机(通过一系列转换)可以到达状态$4$
> >      - 例如从$Q_2=$$\{1,2,5,6,8\}$读入$\text{0}$后到达$Q_3=\{3,4,7,8\}$
> >      - 从状态$4$读入$1$到达状态$5$，再通过$\varepsilon{\rightarrow}8$到达接受状态
> >    - 不接受$\text{00}$：在读入第一个$0$后，自动机状态集为$\{3,4,7,8\}$
> >      - 这些状态都没有到状态$3,4,7,8$或其他能接受状态的$0$转移
> >    - 不接受$\text{011}$：在读入$01$后，自动机状态集为$\{1,2,5,6,8\}$
> >      - 这些状态都没有到状态$1,2,5,6,8$或其他能接受状态的$\text{1}$转移
> > 3. 这个语言可以用正则表达式 $0(10)^*(\varepsilon {\mid} 1)$ 来表示
> >
> > :three:把这个自动机转换为$\text{DFA}$
> >
> > 1. $\text{DFA}$的起始状态$S_0$：$S_0{=}\varepsilon\text{-closure}(\{1\}){=}\{1,2,6\}$
> > 2. $\text{DFA}$状态转移：
> >    - $S_0{=}\{1,2,6\}$(非接受状态)
> >      - 输入$0:\delta\left(S_0,0\right){=}\varepsilon\text{-closure}(\delta(2,0)\cup\delta(6,0)){=}\varepsilon\text{-closure}(\{3\}\cup\{7\}){=}$$\varepsilon\text{-closure}(3)\cup\varepsilon\text{-closure}(7){=}\{3,4\}\cup\{7,8\}{=}\{3,4,7,8\}$我们称此状态为$S_1$
> >      - 输入$1$：$\delta\left(S_0,1\right){=}\varepsilon\text{-closure}(\emptyset){=}\emptyset$我们称此状态为$S_{\text{trap}}$(陷阱状态)
> >    - $S_1{=}\{3,4,7,8\}$(接受状态，因为它包含$\text{DFA}$的接受状态$8$)
> >      - 输入$0:\delta\left(S_1,0\right){=}\varepsilon\text{-closure}(\emptyset){=}\emptyset{=}S_{\text{trap}}$
> >      - 输入$1$：$\delta\left(S_1,1\right){=}\varepsilon\text{-closure}(\delta(4,1)){=}\varepsilon\text{-closure}(\{5\}){=}\{1,2,5,6,8\}$我们称此状态为$S_2$
> >    - $S_2{=}\{1,2,5,6,8\}$(接受状态，因为它包含$\text{DFA}$的接受状态$8$)
> >      - 输入$0:\delta\left(S_2,0\right){=}\varepsilon\text{-closure}(\delta(2,0)\cup\delta(6,0)){=}\varepsilon\text{-closure}(\{3\}\cup\{7\}){=}$$\{3,4,7,8\}{=}S_1$
> >      - 输入$1$：$\delta\left(S_2,1\right){=}\varepsilon\text{-closure}(\emptyset){=}\emptyset{=}S_{\text{trap}}$
> >    - $S_{\text{trap}}{=}\emptyset$(非接受状态)
> >      - 输入$0:\delta\left(S_{\text{trap}},0\right){=}\emptyset{=}S_{\text{trap}}$
> >      - 输入$1:\delta\left(S_{\text{trap}},1\right){=}\emptyset{=}S_{\text{trap}}$
> > 3. $\text{DFA}$状态转移表：
> >    | $\textbf{DFA}$状态 | 输入$\boldsymbol{0}$ | 输入$\boldsymbol{1}$ | 是否接受状态 | $\textbf{DFA}$状态集合 |
> >    | :----------------: | :------------------: | :------------------: | :----------: | ---------------------- |
> >    |     ${\to}S_0$     |        $S_1$         |  $S_{\text{trap}}$   |      否      | $\{1,2,6\}$            |
> >    |      $^*S_1$       |  $S_{\text{trap}}$   |        $S_2$         |      是      | $\{3,4,7,8\}$          |
> >    |      $^*S_2$       |        $S_1$         |  $S_{\text{trap}}$   |      是      | $\{1,2,5,6,8\}$        |
> >    | $S_{\text{trap}}$  |  $S_{\text{trap}}$   |  $S_{\text{trap}}$   |      否      | $\emptyset$            |

---

# 第二次作业

> ## ✅习题$\textbf{3.1}$
>
> > :zero:写出下列语言的一个正则表达式：$\{0,1\}$上任何$00$子串都出现在任何$11$子串前边的串的集合
> >
> > 1. $\left(0^*\left(100^*\right)^*(\varepsilon{|}1)\right)\left(1^*\left(011^*\right)^*(\varepsilon{|}0)\right)$ 
> > 2. $\left((0{|}10)^*(\varepsilon{|}1)\right)\left((1{|}01)^*(\varepsilon{|}0)\right)$✅
> > 3. $\left((0{|}10)^* 0^*\right)\left((1{|}01)^*(\varepsilon{|}0)\right)$
> >
>
> ## ✅习题$\textbf{3.2}$
>
> > :zero:用自然语言描述下列$\text{RE}$语言
> >
> > 2. $0^* 1\left(1{+}0^* 1\right)^*$：所有以$1$结尾的由$0$和$1$组成的字符串
> > 3. $\left(0{+}11^* 0\right)^* 11^*$：字符串以至少一个$1$结尾；并且在字符串中，任何不处于末尾位置的、由一个或多个连续的$1$组成的序列，其后都必须紧跟着一个$0$
>
> ## ✅习题$\textbf{3.4}$
>
> > :zero:用状态消除技术将下列$\text{DFA}$转换为$\text{RE}$，要求也写出中间结果$g\text{-NFA}$
> >
> > |            |  0   |  1   |
> > | :--------: | :--: | :--: |
> > | ${\to}^*s$ | $p$  | $s$  |
> > |    $q$     | $s$  | $p$  |
> > |    $r$     | $r$  | $q$  |
> > |    $p$     | $q$  | $r$  |
> >
> > 1. 转化$\text{DFA}$为$g\text{-NFA}$：
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250602220442099.png" alt="image-20250602220442099" width=380 /> 
> >
> > 2. 删除状态$q$：
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250602220932633.png" alt="image-20250602220932633" width=380 /> 
> >
> > 3. 删除状态$r$：
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250602221208445.png" alt="image-20250602221208445" width=380 /> 
> >
> > 4. 删除状态$P$
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250602221434262.png" alt="image-20250602221434262" width=345 /> 
> >
> > 5. 删除状态$S$
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250602221620926.png" alt="image-20250602221620926" width=345 /> 
> >
>
> ## ✅习题$\textbf{3.7}$
>
> > :one:证明下列语言都不是正则语言：有$0$和$1$构成的$w \hat{w}$形式的串的集合，其中$\hat{w}$是对$w$取反结果，即若$w{=}001$那么$\hat{w}{=}110$ ，因此$001110$是该语言的成员
> >
> > 1. 泵引理：如果语言 $L$ 是正则的，则存在常数$p {\ge} 1$(泵长度)使得任何$L$中长度至少为$p$的字符串$s$都可以被分解为三部分$s{=}xyz$，满足以下条件：
> >
> >    - $|y| {>} 0$
> >    - $|xy| {\le} p$
> >    - 对于所有的整数$i {\ge} 0$有$xy^iz {\in} L$
> > 2. 给定假设：
> >    - 语言$L {=} \{w\hat{w}{|} w {\in} \{0,1\}^* \}$是正则语言，根据泵引理必然存在一个泵长度$p {\ge} 1$
> > 3. 选择特定的字符串$s$：
> >
> >    - 我们选择字符串$s{=}0^p1^p$
> >    - 对于这个字符串我们可以令$w{=}0^p$，那么$\hat{w}$(即$w$中所有$0$替换为$1$，所有$1$替换为$0$)就是$1^p$
> >    - 因此$s{=}w\hat{w}{=}0^p1^p$，根据$L$的定义$s{\in}L$
> >    - 同时字符串$s$长度为$|s|{=}p{+}p{=}2p$，由于$p{\ge}1$所以$|s|{=}2p{\ge}p$，该字符串满足泵引理中$s$长度要求
> > 4. 应用泵引理：
> >    - $s{=}0^p1^p$可以被分解为$s{=}xyz$，满足以下条件
> >      - $|y|{>}0$(即$y$不是空串)
> >      - $|xy|{\le}p$(即$x$和$y$的总长度不超过泵长度$p$)
> >      - 对于所有的$i{\ge}0$，$xy^iz{\in}L$
> >    - 由于$|xy|{\le}p$且字符串$s{=}0^p1^p$的前$p$个字符都是$0$，故子串$x$和$y$必定只由$0$组成，可将$x,y,z$表示为
> >      - $x{=}0^a$，其中$a\ge0$
> >      - $y{=}0^b$，其中$b{\ge}1$(根据$|y|{>}0$)
> >      - $z{=}0^c1^p$，其中$c\ge0$ 
> >    - 并且$a+b+c{=}p$(因为$xyz{=}0^a0^b0^c1^p{=}0^{a+b+c}1^p{=}0^p1^p$)
> > 5. 泵出(或泵入)字符串并检验：
> >    - 现在，我们根据泵引理的条件选择$i{=}2$
> >    - 考虑新的字符串$s'{=}xy^2z{=}xyyz$，因此$s'{=}0^a0^b0^b0^c1^p{=}0^{a+2b+c}1^p$
> >    - 因为$a{+}b{+}c{=}p$，所以$a{+}2b{+}c{=}(a{+}b{+}c){+}b{=}p+b$，因此$s'{=}0^{p+b}1^p$
> > 6. 根据泵引理的条件，如果$L$是正则的那么$s'$必须属于$L$
> >    - 如果$s'{=}0^{p+b}1^p{\in}L$，那么它必须能表示为$w'\hat{w'}$的形式，其中$\hat{w'}$是$w'$的取反
> >    - 由于$s'{=}0^{p+b}1^p$(其中$b{\ge}1$)，要使其成为$w'\hat{w'}$的形式：
> >      - $w'$必须是字符串的前半部分，由$0$组成即$w'{=}0^{p+b}$
> >      - $\hat{w'}$必须是字符串的后半部分，由$1$组成即$\hat{w'}{=}1^p$
> >    - 要使$\hat{w'}{=}1^p$是$w'{=}0^{p+b}$的取反，它们的长度必须相等即$|w'|{=}|\hat{w'}|$
> >    - 所以，我们必须有$p{+}b{=}p$，这推导出$b{=}0$
> > 7. 导出矛盾：
> >    - 我们得到的结论是$b{=}0$
> >    - 然而根据泵引理的条件(a)$|y|{>}0$，并且我们已知$y{=}0^b$所以$b{\ge}1$
> >    - $b{=}0$与$b{\ge}1$产生了矛盾
> > 8. 结论：由于我们的初始假设“$L$是正则语言”导致了一个矛盾，所以这个假设是错误的
> >    - 因此，语言$L{=}\{w\hat{w}{|}w\in\{0,1\}^*\}\boxed{不是正则语言}$
>
> ## ✅习题$\textbf{3.10}$ 
>
> > :zero:对下列$\text{DFA}$画出可区分性表并给出最小化结果
> >
> > |           |      |  0   |  1   |
> > | :-------: | ---- | :--: | :--: |
> > | ${\to}A$  |      | $B$  | $A$  |
> > |    $B$    |      | $A$  | $C$  |
> > |    $C$    |      | $D$  | $B$  |
> > | ${ }^* D$ |      | $D$  | $A$  |
> > |    $E$    |      | $D$  | $F$  |
> > |    $F$    |      | $G$  | $E$  |
> >
> > :one:移除不可达状态：$\text{DFA}$最小化，移除所有从开始状态不可达的状态
> >
> > 1. 开始状态是$A$
> > 2. 从$A$出发，可以到达的状态有：
> >    * $A{\xrightarrow{0}}B$
> >    * $A{\xrightarrow{1}}A$
> >    * $B{\xrightarrow{0}}A$,$B{\xrightarrow{1}}C$
> >    * $C{\xrightarrow{0}}D$,$C{\xrightarrow{1}}B$
> >    * $D{\xrightarrow{0}}D$,$D{\xrightarrow{1}}A$
> > 3. 因此可达状态集为$\{A,B,C,D\}$
> > 4. 状态$\{E,F,G,H\}$都是不可达的，应予以移除
> > 5. 移除不可达状态后，需要被最小化的$\text{DFA}$为：
> >    | 状态     |  0   |  1   |
> >    | -------- | :--: | :--: |
> >    | ${\to}A$ | $B$  | $A$  |
> >    | $B$      | $A$  | $C$  |
> >    | $C$      | $D$  | $B$  |
> >    | ${^*}D$  | $D$  | $A$  |
> >
> > :two:构建可区分性表：对可达状态$\{A,B,C,D\}$应用表填充算法
> >
> > 1.  初始标记(0-可区分)：将一个是终态($D$)而另一个是非终态($A,B,C$)的状态对标记为可区分(`X`)
> >     * 标记$(A,D)$,$(B,D)$,$(C,D)$
> >       |      | $A$  | $B$  | $C$  |
> >       | :--: | :--: | :--: | :--: |
> >       | $B$  |      |      |      |
> >       | $C$  |      |      |      |
> >       | $D$  | $X$  | $X$  | $X$  |
> > 2.  迭代标记(k-可区分):
> >     * 检查$(A,C)$:
> >         * 在输入`0`上，$\delta(A,0){=}B$,$\delta(C,0){=}D$
> >         * 由于状态对$(B,D)$已经被标记为可区分，因此$(A,C)$也是可区分的，标记$(A,C)$
> >     * 检查$(B,C)$:
> >         * 在输入`0`上，$\delta(B,0){=}A$,$\delta(C,0){=}D$
> >         * 由于状态对$(A,D)$已经被标记为可区分，因此$(B,C)$也是可区分的，标记$(B,C)$
> >     * 更新后的表格：
> >         |      | $A$  | $B$  | $C$  |
> >         | :--: | :--: | :--: | :--: |
> >         | $B$  |      |      |      |
> >         | $C$  | $X$  | $X$  |      |
> >         | $D$  | $X$  | $X$  | $X$  |
> > 3.  再次迭代:
> >     * 检查$(A,B)$:
> >         * 在输入`1`上，$\delta(A,1){=}A$,$\delta(B,1){=}C$
> >         * 由于状态对$(A,C)$在上一步中被标记为可区分，因此$(A,B)$也是可区分的，标记$(A,B)$
> > 4.  最终可区分性表:
> >     |      | $A$  | $B$  | $C$  |
> >     | :--: | :--: | :--: | :--: |
> >     | $B$  | $X$  |      |      |
> >     | $C$  | $X$  | $X$  |      |
> >     | $D$  | $X$  | $X$  | $X$  |
> >
> > :three:最小化结果：
> >
> > 1. 从最终的可区分性表可以看出，所有状态对都是可区分的，不存在任何等价的状态
> > 2. 因此，该$\text{DFA}$本身就是最小的(在其可达部分)
> > 3. 最终的最小化$\text{DFA}$为：
> >    | 状态     | 输入0 | 输入1 |
> >    | -------- | ----- | ----- |
> >    | ${\to}A$ | $B$   | $A$   |
> >    | $B$      | $A$   | $C$   |
> >    | $C$      | $D$   | $B$   |
> >    | ${^*}D$  | $D$   | $A$   |
>
>
> ## ✅习题$\textbf{3.11}$
>
> > :one:判断下列$\text{DFA}$是否最小
> >
> > |            |  0   |  1   |
> > | :--------: | :--: | :--: |
> > | ${\to}^*s$ | $p$  | $s$  |
> > |    $q$     | $s$  | $p$  |
> > |    $r$     | $r$  | $q$  |
> > |    $p$     | $q$  | $r$  |
> > 1. 填表如下。四个状态皆可两两区分，所以$\text{DFA}$已最小
> >    | $q$  |  ❌   |      |      |
> >    | :--: | :--: | :--: | :--: |
> >    | $r$  |  ❌   |  ❌   |      |
> >    | $p$  |  ❌   |  ❌   |  ❌   |
> >    |      | $s$  | $q$  | $r$  |

---

# 第三次作业

> ## ✅练习$\textbf{4.2 }$
>
> > :zero:例$\text{4.2}$：语言`UDI=L(<udi>)`和`UDF=L(<udf>)`都是正则语言，存在`σ-DFA` 
> >
> > ```txt
> > <udi>  -> 0|[1-9][0-9]*
> > <tail> -> [1-9]|[0-9]*[1-9]
> > <udf>  -> <udi>\.<tail>|<udi>\.|<udi>\.0|\.<tail>|0\.<tail>
> > ```
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250604202142527.png" alt="image-20250604202142527" width=300 /> 
> >
> > 1. $F^{\mathrm{P}}{=}\{\{b, c\},\{e, f, g\}\}$
> > 2. $\mathrm{UDF}{=}\{w{\in}\Sigma \mid \tilde{v}(a, w){\in}\{e, f, g\}\}$
> > 3. $\mathrm{UDI}{=}\{w{\in}\Sigma \mid \tilde{v}(a, w){\in}\{b, c\}\}$ 
> > 4. $\psi{=}\{(b, \mathrm{UDI}),(e, \mathrm{UDF}),(c, \mathrm{UDI}) (f, \mathrm{UDF}),(g, \mathrm{UDF})\}$
> > 5. $\mathrm{UDI}{\cap}\mathrm{UDF}{=}{\emptyset}$
> >
> > :one:扩展例$\text{4.2}$的$\text{UDI}$为$\text{SDI}{=}\{+,-\}\text{UDI}{\cup}\text{UDI}$，扩展$\text{UDF}$为$\text{SDF}{=}\{+,-\}\text{UDF}{\cup}\text{UDF}$。试构建 $\sigma \text{-DFA(\{ADD, SDI, SDF\})}$并以`12+34.0+.56\#`输入串运行之，写出运行结果
> >
> > 1. 构建$\sigma\text{-DFA(\{ADD,SDI,SDF\})}$ 
> >    - 我们要构建的$\text{DFA}$需要识别三种类型的标记：
> >      - $\text{SDI}$：带可选正负号的无符号十进制整数(UDI)即$\text{SDI}{=}\{+,-\}\text{UDI}{\cup}\text{UDI}$
> >      - $\text{SDF}$：带可选正负号的无符号十进制小数(UDF)即$\text{SDF}{=}\{+,-\}\text{UDF}{\cup}\text{UDF}$
> >      - $\text{ADD}$：加法运算符$\texttt{+}$ 
> >    - 将基于原图中的$\text{DFA}$(识别$\text{UDI}$和$\text{UDF}$)进行扩展原$\text{DFA}$的状态为$\{a,b,c,d,e,f,g,h\}$
> >      - $\text{UDI}$的接受状态:$\{b,c\}$ 
> >      - $\text{UDF}$的接受状态:$\{e,f,g\}$
> >    - 新的$\sigma\text{-DFA}$状态和转换如下
> > 2. 状态集合$Q'$：将引入新的初始状态，及处理符号的状态核心的数字解析状态可以复用原$\text{DFA}$的状态逻辑
> >    - $Q'{=}\{q_{\text{init}},q_{\text{plus\_sign}},q_{\text{minus\_sign}},s_b,s_c,s_d,s_e,s_f,s_g,s_h\}$ 
> >      - $q_{\text{init}}$：新的初始状态
> >      - $q_{\text{plus\_sign}}$：读入前导$\texttt{+}$后的状态，其本身也表示接受$\text{ADD}$标记(若后面无数字接续形成$\text{SDI/SDF}$)
> >      - $q_{\text{minus\_sign}}$：读入前导$\texttt{-}$后的状态
> >      - $s_b,s_c,\dots,s_h$：对应原$\text{DFA}$中的状态$b,c,\dots,h$，用于解析数字的主体部分
> > 3. 母表$\Sigma'$：$\Sigma'{=}\{0,1,\dots,9,.,+,-\}$
> > 4. 状态转换函数$\delta'$及输出类型$\sigma$：词法分析器通常遵循“最长匹配”原则例如
> >    |       当前        |  输入`0`  | 输入`[1-9]` |  输入`.`  |     输入`+`      |      输入`-`      | 输出类型 $\sigma(q)$ |
> >    | :---------------: | :-------: | :---------: | :-------: | :--------------: | :---------------: | :------------------: |
> >    |    $q_{init}$     |   $s_b$   |    $s_c$    |   $s_d$   | $q_{plus\_sign}$ | $q_{minus\_sign}$ |                      |
> >    | $q_{plus\_sign}$  |   $s_b$   |    $s_c$    |   $s_d$   |    错误/陷阱     |     错误/陷阱     |     $\text{ADD}$     |
> >    | $q_{minus\_sign}$ |   $s_b$   |    $s_c$    |   $s_d$   |    错误/陷阱     |     错误/陷阱     |                      |
> >    |       $s_b$       | 错误/陷阱 |  错误/陷阱  |   $s_e$   |    错误/陷阱     |     错误/陷阱     |     $\text{SDI}$     |
> >    |       $s_c$       |   $s_c$   |    $s_c$    |   $s_e$   |    错误/陷阱     |     错误/陷阱     |     $\text{SDI}$     |
> >    |       $s_d$       |   $s_g$   |    $s_g$    | 错误/陷阱 |    错误/陷阱     |     错误/陷阱     |                      |
> >    |       $s_e$       |   $s_e$   |    $s_e$    | 错误/陷阱 |    错误/陷阱     |     错误/陷阱     |     $\text{SDF}$     |
> >    |       $s_f$       |   $s_f$   |    $s_f$    | 错误/陷阱 |    错误/陷阱     |     错误/陷阱     |     $\text{SDF}$     |
> >    |       $s_g$       |   $s_h$   |    $s_f$    | 错误/陷阱 |    错误/陷阱     |     错误/陷阱     |     $\text{SDF}$     |
> >    |       $s_h$       |   $s_h$   |    $s_f$    | 错误/陷阱 |    错误/陷阱     |     错误/陷阱     |                      |
> >    - 输入$\texttt{+1}$可被看作$\texttt{+}$($\text{ADD}$)和$\texttt{1}(\text{SDI})$或$\texttt{+1}(\text{SDI})$，后者是更长的匹配所以优先选择$\texttt{+1}(\text{SDI})$
> >    - 错误/陷阱状态表示当前字符无法延续当前类型的标记
> > 5. 运行输入串$\texttt{12+34.0+.56\#}$：词法分析器从$q_{\text{init}}$状态开始，逐个字符处理输入串$\texttt{\#}$符号通常表示输入结束
> >    - 输入$\texttt{12}$
> >      - m$q_{\text{init}}\xrightarrow{1}s_c$(累积：$1$,$s_c$是$\text{SDI}$接受状态)
> >      - $s_c\xrightarrow{2}s_c$$s_c\xrightarrow{2}s_c$(累积：$12$,$s_c$是$\text{SDI}$接受状态)
> >      - 下一个字符是$\texttt{+}$从$s_c$没有到$\texttt{+}$的数字延续转换
> >      - 输出：($12$,$\text{SDI}$)
> >      - 剩余输入：$\texttt{+34.0+.56\#}$
> >    - 输入$\texttt{+34.0}$
> >      - $q_{\text{init}}\xrightarrow{+}q_{\text{plus\_sign}}$(累积：$\texttt{+}$,$q_{\text{plus\_sign}}$是$\text{ADD}$接受状态)
> >      - $q_{\text{plus\_sign}}\xrightarrow{3}s_c$(累积：$\texttt{+}3$,$s_c$是$\text{SDI}$接受状态；$\texttt{+}3$比$3$长，优先$\text{SDI}$)
> >      - $s_c\xrightarrow{4}s_c$(累积：$\texttt{+34}$,$s_c$是$\text{SDI}$接受状态)
> >      - $s_c\xrightarrow{.}s_e$(累积：$\texttt{+34.}$,$s_e$是$\text{SDF}$接受状态)
> >      - $s_e\xrightarrow{0}s_e$(累积：$\texttt{+34.0}$,$s_e$是$\text{SDF}$接受状态)
> >      - 下一个字符是$\texttt{+}$从$s_e$没有到$\texttt{+}$的数字延续
> >      - 输出：($\texttt{+34.0}$,$\text{SDF}$)
> >      - 剩余输入：$\texttt{+.56\#}$ 
> >    - 输入$\texttt{+.56}$
> >      - $q_{\text{init}}\xrightarrow{+}q_{\text{plus\_sign}}$(累积：$\texttt{+}$,$q_{\text{plus\_sign}}$是$\text{ADD}$接受状态)
> >      - $q_{\text{plus\_sign}}\xrightarrow{.}s_d$(累积：$\texttt{+.}$)
> >      - $s_d\xrightarrow{5}s_g$(累积：$\texttt{+.5}$,$s_g$是$\text{SDF}$接受状态)
> >      - $s_g\xrightarrow{6}s_f$(累积：$\texttt{+.56}$,$s_f$是$\text{SDF}$接受状态;注意原图$g\xrightarrow{\text{[1-9]}}f$)
> >      - 下一个字符是$\texttt{\#}$从$s_f$没有到$\texttt{\#}$的数字延续转换
> >      - 输出：($\texttt{+.56}$,$\text{SDF}$)
> >      - 剩余输入：$\texttt{\#}$
> >    - 输入$\texttt{\#}$：输入结束
> > 6. 最终运行结果(识别的标记序列)：
> >    - ($\texttt{12}$,$\text{SDI}$)
> >    - ($\texttt{+34.0}$,$\text{SDF}$)
> >    - ($\texttt{+.56}$,$\text{SDF}$) 

---

# 第四次作业

> ## ✅习题$\textbf{5.1}$
>
> > :zero:设计$\text{CFG}$识别下列语言
> >
> > :one:$\{a^ib^jc^k{\mid}i{\neq}j\text{or}j{\neq}k\}$
> >
> > 1. 分解语言：原始语言$L$可以看作是两个子语言$L_1$和$L_2$的并集：
> >    - $L_1{=}\left\{a^ib^jc^k{|}i{\neq}j\right\}$
> >    - $L_2{=}\left\{a^ib^jc^k{|}j{\neq}k\right\}$如果$S$是起始符号，那么$S{\to}S_1{|}S_2$，其中$S_1$生成$L_1,S_2$生成$L_2$
> > 2. 设计$L_1$的$\text{CFG}\left(S_1\right)$：$i{\neq}j$意味着$i{>}j$或者$i{<}j$
> >    - 如果$i{>}j$：字符串形式为$a^ma^nb^nc^p(m{\geq}1,n{\geq}0,p{\geq}0)$
> >      - 我们用$A_{plus}$生成至少一个$a\left(a^m\right)$，用$P_{ab}$生成$a^nb^n$，用$C_{any}$生成任意数量的$c\left(c^p\right)$
> >      - 规则：$S_{i{>}j}{\to}A_{plus}P_{ab}C_{any}$
> >    - 如果$i{<}j$：字符串形式为$a^nb^nb^mc^p(m{\geq}1,n{\geq}0,p{\geq}0)$
> >      - 我们用$B_{plus}$生成至少一个$b\left(b^m\right)_{\text{}}$
> >      - 规则：$S_{i{<}j}{\to}P_{ab}B_{plus}C_{any}$所以$S_1{\to}S_{i{>}j}{|}S_{i{<}j}$
> > 3. 设计$L_2$的$\text{CFG}\left(S_2\right)$：$j{\neq}k$意味着$j{>}k$或者$j{<}k_{\circ}$
> >    - 如果$j{>}k$：字符串形式为$a^pb^mb^nc^n(m{\geq}1,n{\geq}0,p{\geq}0)$
> >      - 我们用$A_{any}$生成任意数量的$a\left(a^p\right)$，
> >      - 用$B_{\text{plus}}$生成至少一个$b\left(b^m\right)$，用$P_{bc}$生成$b^nc^n$
> >      - 规则：$S_{j{>}k}{\to}A_{\text{any}}B_{\text{plus}}P_{\text{bc}}$
> >    - 如果$j{<}k$：字符串形式为$a^pb^nc^nc^m(m{\geq}1,n{\geq}0,p{\geq}0)$
> >      - 我们用$C_{plus}$生成至少一个$c\left(c^m\right)_{\text{}}$
> >      - 规则：$S_{j{<}k}{\to}A_{\text{any}}P_{bc}C_{\text{plus}}$所以$S_2{\to}S_{j{>}k}{|}S_{j{<}k}$
> > 4. 组合所有规则并定义基本非终结符：
> >    - 设$G{=}(V,\Sigma,P,S)$是一个上下文无关文法，其中：
> >      - $V{=}\{S,S_1,S_2,S_{i{>}j},S_{i{<}j},S_{j{>}k},S_{j{<}k},P_{ab},P_{bc},A_{plus},B_{plus},C_{plus},A_{any},C_{any}\}$
> >      - $\Sigma{=}\{a,b,c\}$
> >      - $S$是起始符号
> >    - $P$包含以下产生式：
> >      - $S{\to}S_1{|}S_2$
> >      - $S_1{\to}S_{i{>}j}{|}S_{i{<}j}$
> >      - $S_{i{>}j}{\to}A_{plus}P_{ab}C_{any}$
> >      - $S_{i{<}j}{\to}P_{ab}B_{plus}C_{any}$
> >      - $S_2{\to}S_{j{>}k}{|}S_{j{<}k}$
> >      - $S_{j{>}k}{\to}A_{any}B_{plus}P_{bc}$
> >      - $S_{j{<}k}{\to}A_{any}P_{bc}C_{plus}$
> >      - $P_{ab}{\to}aP_{ab}b{|}\varepsilon$
> >      - $P_{bc}{\to}bP_{bc}c{|}\varepsilon$
> >      - $A_{plus}{\to}aA_{plus}{|}a$
> >      - $B_{plus}{\to}bB_{plus}{|}b$
> >      - $C_{plus}{\to}cC_{plus}{|}c$
> >      - $A_{any}{\to}aA_{any}{|}\varepsilon$
> >      - $C_{any}{\to}cC_{any}{|}\varepsilon$
> >
> > :two:字母表$\{a,b\}$上的非$ww$形式的串集合，其中$w$是$\{a,b\}$上的符号串
> >
> > 1. 解题思路
> >    - 目标语言$L{{=}}\{x{\in}\{a,b\}^*{\mid}x{\neq}ww\text{ forany }w{\in}\{a,b\}^*\}$
> >    - 我们可以将这个语言$L$分解为两个不相交的子集：
> >      - 所有长度为奇数的串。任何奇数长度的串都不可能写成$ww$的形式，因为$ww$的长度总是偶数
> >      - 所有长度为偶数的串$x$，使得当$x{=}uv$且$|u|{=}|v|$时，必然有$u{\neq}v$
> >    - 因此，文法的开始符号$S$将有产生式$S{\to}S_O{\mid}S_E$
> > 2. 构造$L_O$的文法($S_O$)
> >    - $L_O$包含所有奇数长度的串，
> >    - 对应的产生式为：$S_O{\to}a{\mid}b{\mid}aaS_O{\mid}abS_O{\mid}baS_O{\mid}bbS_O$
> >      - 这个文法确保了从长度为1的串开始，每次递归添加两个符号，始终保持串的长度为奇数
> > 3. 构造$L_E$的文法($S_E$)
> >    - $L_E$包含所有长度为偶数且形式不为$ww$的串
> >    - 一个标准的构造方法是确保这样的串$x$可以被分解为两部分$m_1m_2$
> >      - 其中$m_1$和$m_2$都是奇数长度的串，且它们的中心字符不同
> >    - 令$M_a$为能生成以$a$为中心字符的奇数长度串的非终结符(不一定是回文串)
> >    - 令$M_b$为能生成以$b$为中心字符的奇数长度串的非终结符(不一定是回文串)
> > 4. 产生式如下：
> >    - $S_E{\to}M_aM_b{\mid}M_bM_a$
> >    - $M_a{\to}aM_aa{\mid}aM_ab{\mid}bM_aa{\mid}bM_ab{\mid}a$
> >    - $M_b{\to}aM_ba{\mid}aM_bb{\mid}bM_ba{\mid}bM_bb{\mid}b$
> > 5. 对生成式的解释：
> >    - $M_a{\to}a$：生成串$a$(长度为1，中心为$a$)
> >    - $M_a{\to}c_1M_ac_2$($c_1,c_2{\in}\{a,b\}$)：如果$M_a$可以生成奇数长度串$s_a$(中心为$a$)，则此规则生成$c_1s_ac_2$
> >      - 这个新串的长度增加了2(仍为奇数)，并且其中心字符与$s_a$的中心字符相同(即$a$)
> >    - $M_b$的产生式同理，只是中心字符为$b$
> > 6. 进一步的解释：
> >    - 当$S_E{\to}M_aM_b$时，生成的串$x{{=}}m_am_b$
> >      - 由于$m_a$的中心是$a$，$m_b$的中心是$b$，可以证明$x$不可能是$ww$形式
> >      - 如果$x{=}ww$，那么$w$的某个对应位置必须既是$a$又是$b$，这是矛盾的
> >    - 例如，串$aabb{\in}L_E$
> >      - 它可以由$S_E{{\Rightarrow}}M_aM_b{{\Rightarrow}}a(aM_bb){{\Rightarrow}}a(a(b)b){{=}}aabb$生成
> >      - 这里$M_a{\Rightarrow}a$，$M_b{\Rightarrow}abb$(其中$M_b{\Rightarrow}aM_bb{\Rightarrow}a(b)b{{=}}abb$，中心是$b$)
> > 7. 最终的$\text{CFG}$：将上述部分组合起来，得到最终的文法$G{{=}}(V,\Sigma,P,S)$，
> >    - 其中$\Sigma{{=}}\{a,b\}$，$V{{=}}\{S,S_O,S_E,M_a,M_b\}$，以及产生式$P$ 
> >      - $S{\to}S_O{\mid}S_E$
> >      - $S_O{\to}a{\mid}b{\mid}aaS_O{\mid}abS_O{\mid}baS_O{\mid}bbS_O$
> >      - $S_E{\to}M_aM_b{\mid}M_bM_a$
> >      - $M_a{\to}aM_aa{\mid}aM_ab{\mid}bM_aa{\mid}bM_ab{\mid}a$
> >      - $M_b{\to}aM_ba{\mid}aM_bb{\mid}bM_ba{\mid}bM_bb{\mid}b$
>
> ## ✅习题$\textbf{5.4}$
>
> > :zero:假设有$\text{CFG-}G$，它的任何候选式都不为$\varepsilon$ ；如果$w{\in}L(G)$，$w$有一个$m$步直接推导，证明$w$有一个包含 $|w|{+}m$个节点的语法树
> >
> > 1. 令$N$为语法树中节点的总数，$N_I$为内部节点的数量，$N_L$为叶节点的数量则$N{=}N_I{+}N_L$
> > 2. 叶节点的数量($N_L$)
> >    - 语法树的叶节点从左到右排列构成了推导出的串$w$
> >      - 由于文法$G$中没有任何候选式为$\varepsilon$(即没有形如$A{\to}\varepsilon$的产生式)
> >      - 因此该语法树的所有叶节点都必须是终结符每个叶节点对应$w$中的一个终结符
> >    - 因此，叶节点的数量等于串$w$的长度为$N_L{=}|w|$
> > 3. 内部节点的数量($N_I$)：我们将通过对推导的步数$m$进行数学归纳来证明内部节点的数量$N_I{=}m$
> > 4. 基本情况：$m{=}1$
> >    - 如果推导只有一步，即$S{\to}w$(这里$S$是开始符号)这意味着$S{\to}w$是文法中的一个产生式
> >    - 在此情况下，语法树的根节点是$S$，它的子节点是构成$w$的各个终结符根节点$S$是一个内部节点
> >      - 因此，内部节点的数量$N_I{=}1$这与$m{=}1$相符
> > 5. 归纳假设：假设对于任何$k$步最左推导(其中$1{\le}k{<}m$)
> >    - 如果一个非终结符$A$经过$k$步推导得到终结符串$u$(即$A\Rightarrow^ku$)
> >    - 那么对应于此推导的以$A$为根、产出为$u$的语法子树包含$k$个内部节点
> > 6. 归纳步骤：
> >    - 考虑一个$m$步的最左推导$S\Rightarrow^mw$
> >    - 这个推导的第一步一定是应用了一个产生式
> >      - 形如$S{\to}X_1X_2{\dots}X_p$这一步是$m$步推导中的第1步在语法树中
> >      - 根节点$S$是一个内部节点，它的子节点是$X_1,X_2,{\dots},X_p$所以，根$S$贡献了$1$个内部节点
> >    - 剩下的$m{-}1$步用于从$X_1X_2{\dots}X_p$推导出串$w$我们可以将串$w$分解为$w{=}w_1w_2{\dots}w_p$
> >      - 其中每个$X_i$推导出$w_i$(即$X_i\Rightarrow^*w_i$)
> >    - 对于$S{\to}X_1X_2{\dots}X_p$中的每个符号$X_i$：
> >      - 如果$X_i$是一个终结符，那么$X_i{=}w_i$它本身是语法树的一个叶节点(作为$S$的子节点)它不贡献于后续的$m{-}1$步推导中的任何一步，也不贡献其子树的任何内部节点(因为它是一个叶节点，没有子树)
> >      - 如果$X_i$是一个非终结符，它将通过一个$m_i$步的推导得到$w_i$(即$X_i\Rightarrow^{m_i}w_i$)由于文法中没有$\varepsilon$产生式，所以$w_i$不会是空串因此，推导$X_i\Rightarrow^{m_i}w_i$至少需要一步，即$m_i{\ge}1$ 
> >    - 所有作为非终结符的子节点$X_i$的推导步数之和等于总推导步数减去第一步，即：$\sum_{X_i\text{是非终结符}}m_i{=}m{-}1$ 
> >    - 由于对于每个这样的非终结符$X_i$都有$m_i{\ge}1$，这意味着$m_i{\le}m{-}1{<}m$根据归纳假设，以$X_i$为根、产出为$w_i$的语法子树包含$m_i$个内部节点
> >    - 整个语法树的内部节点数量$N_I$是根节点$S$(1个)加上所有作为非终结符的子节点$X_i$对应子树中的内部节点数量之和：$N_I{=}1{+}\sum_{X_i\text{是非终结符}}m_i$
> >    - 由于$\sum_{X_i\text{是非终结符}}m_i{=}m{-}1$，所以：$N_I{=}1{+}(m{-}1){=}m$
> > 7. 总结点数量：
> >    - 语法树的总节点数是内部节点数与叶节点数之和：$N{=}N_I{+}N_L$
> >    - 根据上面的证明，我们有$N_I{=}m$和$N_L{=}|w|$
> >    - 因此：$N{=}m{+}|w|$证明完毕 
>
> ## ✅习题$\textbf{5.6}$
>
> > :zero:考虑一个歧义性的文法 $S {\to} a S|a S b S| \varepsilon$ ，试验证串$a a b$有两个：
> >
> > 1. 语法树：
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250605002656486.png" alt="image-20250605002656486" style="zoom:50%;" />  
> > 2. 最左推导：
> >    - `S -> aSbS -> aaSbS -> aaεbS -> aabε -> aab`
> >    - `S -> aS -> aaSbS -> aaεbS -> aabε -> aab`
> > 3. 最右推导：
> >    - `S -> aSbS -> aSbε  -> aSb -> aaSb -> aaεb -> aab`
> >    - `s -> as -> aaSbS -> aaSbε -> aaSb -> aaεb -> aab`
> >
>
> ## ✅习题$\textbf{5.7}$
>
> > :zero:证明习题$\text{5.6}$中的文法识别的语言是串的任何前缀所包含$a$的个数不少于所包含$b$的个数
> >
> > :bulb:设$\text{bal}(s){=}n_a(s){-}n_b(s)$
> >
> > :one:第一部分：证明$L(G){\subseteq}L_P$，通过对串$w{\in}L(G)$的长度进行归纳
> >
> > 1. 基本情况：$w{=}\varepsilon$由$S{\to}\varepsilon$生成，$\varepsilon$的唯一前缀是$\varepsilon$而$\text{bal}(\varepsilon){=}0{\geq}0$，故$\varepsilon{\in}L_P$
> > 2. 归纳假设：对所有长度小于$|w|$的串$x{\in}L(G)$，都有$x{\in}L_P$
> > 3. 归纳步骤：
> >    - 若$w{=}aw_1$(通过$S{\to}aS_1{\Rightarrow^*}aw_1$)：$|w_1|{<}|w|$，故$w_1{\in}L_{P}$
> >      - $w$的前缀为$a$或$ap^{\prime}(p^{\prime}.$为$w_1$的前缀)，$\text{bal}(a){=}1{\geq}0$
> >      - $\text{bal}(ap^{\prime}){=}1{+}\text{bal}(p^{\prime}){\geq}1{+}0{\geq}0$，故$w{\in}L_P$
> >    - 若$w{=}aw_1bw_2$(通过$S{\to}aS_1bS_2{\Rightarrow^*}aw_1bw_2$)：$|w_1|,|w_2|{<}|w|$，故$w_1,w_2{\in}L_P$
> >      - $w$的前缀为$ap^{\prime}$($p^{\prime}$为$w_1$的前缀)或$aw_1bp^{\prime\prime}$($p^{\prime\prime}$为$w_2$的前缀)
> >      - $ap^{\prime}$的情况同上$\text{bal}(aw_1bp^{\prime\prime}){=}1{+}\text{bal}(w_1){-}1{+}$$\text{bal}(p^{\prime\prime}){=}\text{bal}(w_1){+}\text{bal}(p^{\prime\prime})$
> >      - 因$w_1{\in}L_P,\text{bal}(w_1){\geq}0$(作为$w_1$自身的前缀)
> >      - 因$w_2{\in}L_P,\text{bal}(p^{\prime\prime}){\geq}0$，故$\text{bal}(aw_1bp^{\prime\prime}){\geq}0{+}0{\geq}0$故$w{\in}L_{P\text{}}$
> >
> > :two:第二部分：证明$L_P{\subseteq}L(G)$，通过对串$w{\in}L_P$的长度进行归纳
> >
> > 1. 基本情况：$w{=}\varepsilon$且$\varepsilon{\in}L_{P}$，由$S{\to}\varepsilon$可得$\varepsilon{\in}L(G)$
> > 2. 归纳假设：对所有长度小于$|w|$的串$x{\in}L_P$，都有$x{\in}L(G)$
> > 3. 归纳步步聚：设$w{\in}L_P$且$w{\neq}\varepsilon$，则$w$必以$a$开头
> >    - 情况1：对$w$的所有非空前缀$p$且$\text{bal}(p){\geq}1$，则$w{=}ax$
> >      - 对$x$的任意前缀$p_x$而言$ap_x$是$w$的前缀，$\text{bal}(ap_x){=}1{+}\text{bal}(p_x){\geq}1\Longrightarrow\text{bal}(p_x){\geq}0$
> >      - 所以$x{\in}L_{P}$，因$|x|{<}$$|w|$，由归纳假设$x{\in}L(G)$
> >      - 因此$S{\to}aS{\Rightarrow^*}ax{=}w$，故$w{\in}L(G)$
> >    - 情况2：存在$w$的前缀$p$使得$\text{bal}(p){=}0$令$aw_1b$为$w$的最短非空前缀且$\text{bal}(aw_1b){=}0$
> >      - 则$\text{bal}(w_1){=}\text{bal}(aw_1b){-}\text{bal}(a){-}\text{bal}(b){=}0{-}1{-}({-}1){=}0$
> >      - 对$w_1$的任意前缀$p_1$，$ap_1$是$aw_1b$的真前缀
> >      - 故$\text{bal}(ap_1){\geq}1\Longrightarrow1{+}\text{bal}(p_1){\geq}$$1\Longrightarrow\text{bal}(p_1){\geq}0$
> >      - 所以$w_1{\in}L_P$，令$w{=}aw_1bw_2$，对$w_2$的任意前缀$p_2$，$aw_1bp_2$是$w$的前缀
> >      - $\text{bal}(aw_1bp_2){=}\text{bal}(aw_1b){+}\text{bal}(p_2){=}0{+}\text{bal}(p_2){\geq}$$0\Longrightarrow\text{bal}(p_2){\geq}0$
> >      - 所以$w_2{\in}L_P$因$|w_1|,|w_2|{<}|w|$，由归纳假设$w_1,w_2{\in}$$L(G)$
> >      - 因此$S{\to}aSbS{\Rightarrow^*}aw_1bS_2{\Rightarrow^*}aw_1bw_2{=}w$，故$w{\in}L(G)$
> > 4. 两部分结合，得证$L(G){=}L_P$
>
> ## ✅习题$\textbf{5.8}$
>
> > :zero:消除习题$\text{5.6}$中的文法的歧义性(过程略)
> >
> > 1. $S{\to}aSbS|aT|\varepsilon$
> > 2. $T{\to}a T|\varepsilon$
>
> ## ✅习题$\textbf{5.10}$
>
> > :zero:对$\text{CFG-}G$：$S{\to}ASB|\varepsilon$和$A{\to}aAS|a$和$B{\to}SbS|A|bb$，分别完成：
> >
> > :one:写出$\overline{\mathrm{e}}{\cdot}G$
> >
> > 1. 找出所有可空的非终结符：一个非终结符$X$是可空的，如果它可以推导出空串$\varepsilon$(即$X{\Rightarrow^*}\varepsilon$)
> >    - 对于非终结符$S$：因为存在产生式$S{\to}\varepsilon$，所以$S$是可空的
> >    - 对于非终结符$A$：产生式为$A{\to}aAS$和$A{\to}a$
> >      - 由于$a$是终结符，所以$A$不能推导出$\varepsilon$，因此$A$不是可空的
> >    - 对于非终结符$B$：产生式为$B{\to}SbS$,$B{\to}A$,和$B{\to}bb$
> >      - 由于$b$是终结符，且$A$不是可空的，所以$B$不能推导出$\varepsilon$，因此$B$不是可空的
> >    - 综上所述，该文法中唯一的可空非终结符是$S$，我们记可空非终结符集合为$N_{\text{nullable}}{{=}}\{S\}$
> > 2. 构建新的产生式集合$P'$
> >    - 对于原语法$G$中的每一个产生式$X{\to}\alpha$，我们通过以下方式构造新的产生式：
> >      - 如果$\alpha$中包含可空非终结符$Y{\in}N_{\text{nullable}}$，则对于$Y$的每次出现，可以保留或删除它
> >      - 这样，对$\alpha$中所有可空的非终结符进行所有可能的保留$/$删除组合，会得到一组新的产生式体
> >      - 如果某个组合产生了一个空的右部(即$X{\to}\varepsilon$)，我们暂时不直接添加它
> >    - 对于产生式$S{\to}ASB$，由于$S$(在$ASB$的中间)是可空的，我们得到以下新产生式：
> >      - 保留$S$：$S{\to}ASB$
> >      - 删除$S$：$S{\to}AB$
> >    - 对于产生式$A{\to}aAS$，由于$S$(在$aAS$的末尾)是可空的，我们得到以下新产生式
> >      - 保留$S$：$A{\to}aAS$
> >      - 删除$S$：$A{\to}aA$
> >    - 对于产生式$A{\to}a$，其右部没有可空非终结符
> >      - 所以保持不变为$A{\to}a$
> >    - 对于产生式$B{\to}SbS$，其右部的第一个$S$和第二个$S$都是可空的，我们得到以下新产生式：
> >      - 保留两个$S$：$B{\to}SbS$
> >      - 删除第一个$S$，保留第二个$S$即$B{\to}bS$
> >      - 保留第一个$S$，删除第二个$S$即$B{\to}Sb$
> >      - 删除两个$S$即$B{\to}b$
> >    - 于产生式$B{\to}A$，其右部没有可空非终结符($A$不是可空的)
> >      - 所以保持不变：$B{\to}A$
> >    - 对于产生式$B{\to}bb$，其右部没有可空非终结符
> >      - 所以保持不变：$B{\to}bb$
> > 3. 将以上生成的所有非$\varepsilon$-产生式合并，我们得到临时的产生式集合$P'_{temp}$：
> >    - $S{\to}ASB|AB$
> >    - $A{\to}aAS|aA|a$
> >    - $B{\to}SbS|bS|Sb|b|A|bb$
> > 4. 处理开始符号的可空性
> >    - 由于原始文法的开始符号$S$是可空的($S{\in}N_{\text{nullable}}$)
> >    - 我们需要在新的产生式集合中加入产生式$S{\to}\varepsilon$
> >    - 以确保新文法生成的语言与原始文法相同(即$L(\overline{\mathrm{e}}{\cdot}G){{=}}L(G)$)
> > 5. <font color=red>综合以上步骤，消除$\varepsilon$-产生式后的文法$\overline{\mathrm{e}}{\cdot}G$的产生式集合为</font>
> >    - $S{\to}ASB|AB|\varepsilon$
> >    - $A{\to}aAS|aA|a$
> >    - $B{\to}SbS|bS|Sb|b|A|bb$
> >
> > :two:写出$\overline{\mathrm{u}}\overline{\mathrm{e}}{\cdot}G$
> >
> > 1. 找出$\overline{\mathrm{e}}{\cdot}G$中的所有单元产生式：单元产生式是形如$X{\to}Y$的产生式，其中$X$和$Y$都是非终结符
> >
> >    - 对于产生式$S{\to}ASB|AB|\varepsilon$：没有单元产生式
> >    - 对于产生式$A{\to}aAS|aA|a$：没有单元产生式
> >    - 对于产生式$B{\to}SbS|bS|Sb|b|A|bb$：其中$B{\to}A$是一个单元产生式
> >    - 所以，$\overline{\mathrm{e}}{\cdot}G$中唯一的单元产生式是$B{\to}A$
> >
> > 2. 为每个非终结符构建单元推导闭包：对于每个非终结符$X$，我们需要找到所有$X\Rightarrow{}^*Y$
> >
> >    - $U(S){=}\{S\}$，因为没有从$S$开始的单元产生式
> >    - $U(A){=}\{A\}$，因为没有从$A$开始的单元产生式
> >    - $U(B){=}\{B,A\}$，因为$B{\to}B$(平凡的)且$B{\to}A$
> >
> > 3. 构建新的产生式集合$P_{\text{new}}$
> >
> >    - 新的产生式集合$P_{\text{new}}$的构建规则是：
> >      - 对于每个非终结符$X$，以及$U(X)$中的每个非终结符$Y$
> >      - 如果$Y{\to}\alpha$是$\overline{\mathrm{e}}{\cdot}G$中的一个非单元产生式，则将$X{\to}\alpha$加入到$P_{\text{new}}$
> >    - $\overline{\mathrm{e}}{\cdot}G$中的非单元产生式包括：
> >      - $S{\to}ASB$
> >      - $S{\to}AB$
> >      - $S{\to}\varepsilon$
> >      - $A{\to}aAS$
> >      - $A{\to}aA$
> >      - $A{\to}a$
> >      - $B{\to}SbS$
> >      - $B{\to}bS$
> >      - $B{\to}Sb$
> >      - $B{\to}b$
> >      - $B{\to}bb$
> >
> > 4. 现在我们根据规则构建$P_{\text{new}}$：
> >    - 对于非终结符$S:U(S){=}\{S\}$
> >
> >      - $S{\to}ASB$，来自$S{\to}ASB$，因为$S{\in}U(S)$
> >
> >      - $S{\to}AB$，来自$S{\to}AB$，因为$S{\in}U(S)$
> >
> >      - $S{\to}\varepsilon$，来自$S{\to}\varepsilon$，因为$S{\in}U(S)$；所以$S$的产生式为：$S{\to}ASB|AB|\varepsilon$
> >
> >    - 对于非终结符$A:U(A){=}\{A\}$
> >
> >      - $A{\to}aAS$，来自$A{\to}aAS$，因为$A{\in}U(A)$
> >
> >      - $A{\to}aA$，来自$A{\to}aA$，因为$A{\in}U(A)$
> >
> >      - $A{\to}a$，来自$A{\to}a$，因为$A{\in}U(A)$；所以$A$的产生式为：$A{\to}aAS|aA|a$
> >
> >    - 对于非终结符$B:U(B){=}\{B,A\}$，当$Y{=}B$时$(B{\in}U(B))$：
> >      - $B{\to}SbS$，来自$B{\to}SbS$
> >      - $B{\to}bS$，来自$B{\to}bS$
> >      - $B{\to}Sb$，来自$B{\to}Sb$
> >      - $B{\to}b$，来自$B{\to}b$
> >      - $B{\to}bb$，来自$B{\to}bb$
> >
> >    - 对于非终结符$B:U(B){=}\{B,A\}$，当$Y{=}A$时$(A{\in}U(B))$：
> >
> >      - $B{\to}aAS$，来自$A{\to}aAS$
> >      - $B{\to}aA$，来自$A{\to}aA$
> >      - $B{\to}a$，来自$A{\to}a$；所以$B$的产生式为：$B\rightarrow$$SbS|bS|Sb|b|bb|aAS|aA|a$
> >
> >    - <font color=red>综合以上步骤，消除单元产生式后的文法$\overline{\mathrm{ue}}{\cdot}G$的产生式集合为：</font>
> >      - $S{\to}ASB|AB|\varepsilon$
> >      - $A{\to}aAS|aA|a$
> >      - $B{\to}SbS|bS|Sb|b|bb|aAS|aA|a$
> >
> > :three:写出$ag\overline{\mathrm{u}}\overline{\mathrm{e}}{\cdot}G$
> >
> > 1. 消除非产生符号：一个符号是产生符号，如果它能推导出至少一个终结符串
> >    - 所有终结符$(a,b)$都是产生符号，$\varepsilon$也被认为是能产生空串
> >    - 初始化：$N_{\text{gen}}{=}\emptyset$(用于存放产生非终结符的集合)
> >    - 选代$1$：
> >      - 对产生式$A{\to}a$，因为$a$是终结符，所以$A$是产生符号，将$A$加入$N_{\text{gen}}$
> >      - 对产生式$B{\to}b$(者$B{\to}bb/B{\to}a$)，因$b$和$a$是终结符，故$B$是产生符号，将$B$加入$N_{\text{gen}}$
> >      - 对于产生式$S{\to}\varepsilon$，所以$S$是产生符号，将$S$加入$N_{\text{gen}}$
> >      - 此时，$N_{\text{gen}}{=}\{A,B,S\}$
> >    - 选代$2$：检查所有产生式$X{\to}\alpha$，如果$\alpha$中的所有符号都是产生符号，则$X$也是产生符号
> >      - 对于$S{\to}ASB$：$A,S,B$都在$N_{\text{gen}}$中，因此$S$是产生符号
> >      - 对于$S{\to}AB$：$A,B$都在$N_{\text{gen}}$中，因此$S$是产生符号
> >      - 对于$A{\to}aAS$：$a$是终结符，$A,S$都在$N_{\text{gen}}$中，因此$A$是产生符号
> >      - 对于$A{\to}aA$：$a$是终结符，$A$在$N_{\text{gen}}$中，因此$A$是产生符号
> >      - 对于$B{\to}SbS$：$S$在$N_{\text{gen}}$中，$b$是终结符，$S$在$N_{\text{gen}}$中，因此$B$是产生符号
> >      - 对于$B{\to}bS$：$b$是终结符，$S$在$N_{\text{gen}}$中，因此$B$是产生符号
> >      - 对于$B{\to}Sb$：$S$在$N_{\text{gen}}$中，$b$是终结符，因此$B$是产生符号
> >      - 对于$B{\to}aAS$：$a$是终结符，$A,S$都在$N_{\text{gen}}$中，因此$B$是产生符号
> >      - 对于$B{\to}aA$：$a$是终结符，$A$在$N_{\text{gen}}$中，因此$B$是产生符号
> >    - 由于在迭代$2$中没有新的非终结符被加入到$N_{\text{gen}}$，且$N_{\text{gen}}{=}\{S,A,B\}$包含了所有非终结符
> >      - 所以文法$G^{\prime}$中的所有非终结符都是产生符号
> >      - 因此，不需要删除任何非终结符或产生式，此步骤后的文法$G_1$与$G^{\prime}$相同
> >    - $G_1$的产生式为：
> >      - $S{\to}ASB|AB|\varepsilon$
> >      - $A{\to}aAS|aA|a$
> >      - $B{\to}SbS|bS|Sb|b|bb|aAS|aA|a$
> >
> > 2. 步骤$2$：消除不可达符号：一个符号$X$是可达符号，如果从开始符号$S$出发，存在某个$S{\Rightarrow^*}{\alpha}X\beta$
> >
> >    - 初给化：可达非终结符集合$N_{\text{reach}}{=}\{S\}$(开始符号总是可达的)，可达终结符集合$T_{\text{reach}}{=}\emptyset$
> >
> >    - 选代1：检查从$S$(在$N_{\text{reach}}$中)出发的产生式：
> >
> >      - $S{\to}ASB$：$A,S,B$是非终结符，将$A,B$加入$N_{\text{reach}}$，现在$N_{\text{reach}}{=}\{S,A,B\}$
> >      - $S{\to}AB$：$A,B$已在$N_{\text{reach}}$中
> >      - $S{\to}\varepsilon$：没有新的符号
> >
> >    - 选代2：检查从$A$(在$N_{\text{reach}}$中)出发的产生式：
> >
> >      - $A{\to}aAS$：$a$是终结符，将$a$加入$T_{\text{reach}}$，现在$T_{\text{reach}}{=}\{a\}$$A,S$已在$N_{\text{reach}}$中
> >      - $A{\to}aA$：$a$已在$T_{\text{reach}}$中，$A$已在$N_{\text{reach}}$中
> >      - $A{\to}a$：$a$已在$T_{\text{reach}}$中
> >
> >    - 选代3：检查从$B$(在$N_{\text{reach}}$中)出发的产生式：
> >
> >      - $B{\to}SbS:S$已在$N_{\text{reach}}$中$b$是终结符；将$b$加入$T_{\text{reach}}$，现在$T_{\text{reach}}{=}\{a,b\}$，$S$已在$N_{\text{reach}}$中
> >
> >      - $B{\to}bS:b$已在$T_{\text{reach}}$中，$S$已在$N_{\text{reach}}$中
> >      - $B{\to}Sb:S$已在$N_{\text{reach}}$中，$b$已在$T_{\text{reach}}$中
> >      - $B{\to}b:b$已在$T_{\text{reach}}$中
> >      - $B{\to}bb:b$已在$T_{\text{reach}}$中
> >      - $B{\to}aAS$：$a$已在$T_{\text{reach}}$中，$A,S$已在$N_{\text{reach}}$中
> >      - $B{\to}aA$：$a$已在$T_{\text{reach}}$中，$A$已在$N_{\text{reach}}$中
> >      - $B{\to}a$：$a$已在$T_{\text{reach}}$中
> >
> >    - 此时，$N_{\text{reach}}{=}\{S,A,B\}$且$T_{\text{reach}}{=}\{a,b\}$
> >
> >      - 所有原始的非终结符和终结符都已包含在内，后续迭代不会再增加新的可达符号
> >
> >      - 因此，文法$G_1$中的所有符号都是可达符号，不需要删除任何符号或产生式
> >
> > 3. 最终的文法$ag\overline{\mathrm{ue}}{\cdot}G$
> >
> >    - 由于在文法$\overline{ue}{\cdot}G$中，所有非终结符既是产生符号也是可达符号，所以没有无用符号
> >    - 因此，文法$ag\overline{\mathrm{ue}}{\cdot}G$与文法$\overline{\mathrm{ue}}{\cdot}G$是相同的
> >    - <font color=red>$ag\overline{\mathrm{ue}}{\cdot}G$的产生式集合为：</font>
> >      - $S{\to}ASB|AB|\varepsilon$
> >      - $A{\to}aAS|aA|a$
> >      - $B{\to}SbS|bS|Sb|b|bb|aAS|aA|a$ 
>
> ## ✅习题$\textbf{5.13}$
>
> > :zero:对文法$S{\to}aAa|bB|\varepsilon$和$A{\to}C|a$和$B{\to}C|b$和$C{\to}CDE|\varepsilon$和$D{\to}A|B\mid$$ab$
> >
> > - (假设$E$是一个非终结符且其唯一的产生式是$E{\to}e$，且$E$不可空)
> >
> > :one:写出$\overline{\mathrm{e}}{\cdot}G$，过程类似习题$\text{5.10}$略
> >
> > 1. $S^{\prime}{\to}S|\varepsilon$
> > 2. $S{\to}aAa|aa|bB|b$
> > 3. $A{\to}C|a$
> > 4. $B{\to}C|b$
> > 5. $C{\to}CDE|DE|CE|E$
> > 6. $D{\to}A|B|ab$
> > 7. $E{\to}e$
> >
> > :two:写出$\overline{\mathrm{u}}\overline{\mathrm{e}}{\cdot}G$，过程类似习题$\text{5.10}$略
> >
> > 1. $S^{\prime}{\to}aAa|aa|bB|b|\varepsilon$
> > 2. $S{\to}aAa|aa|bB|b$
> > 3. $A{\to}a|CDE|DE|CE|e$
> > 4. $B{\to}b|CDE|DE|CE|e$
> > 5. $C{\to}e|CDE|DE|CE|$
> > 6. $D{\to}ab|a|b|e|CDE|DE|CE$
> > 7. $E{\to}e$
> >
> > :three:写出$ag\overline{\mathrm{u}}\overline{\mathrm{e}}{\cdot}G$，过程类似习题$\text{5.10}$略
> >
> > 1. $S^{\prime}{\to}aAa|aa|bB|b|\varepsilon$
> > 2. $A{\to}CDE|DE|CE|e|a$
> > 3. $B{\to}CDE|DE|CE|e|b$
> > 4. $C{\to}CDE|DE|CE|e$
> > 5. $D{\to}CDE|DE|CE|e|a|b|ab$
> > 6. $E{\to}e$

---

# 第五次作业 

> ## ✅习题$\textbf{6.2}$
>
> > :zero:判断下列文法是不是$\mathrm{LL}(1)$文法，若不是转换之
> >
> > :one:$\check{A}{\to}\varepsilon|\check{A}A;$和$A{\to}Td|Td[\check{I}]$和$T{\to}\text{int|float}$和$\check{I}{\to}i|\check{I},i$ (不是)
> >
> > 1. 为方便后续处理，我们将原始文法 $G_0$ 列出如下：
> >    - $\check{A}{\to}\varepsilon|\check{A}A$
> >    - $A{\to}Td|Td[\check{I}]$
> >    - $T{\to}\mathrm{int}|\mathrm{float}$
> >    - $\check{I}{\to}i|\check{I},i$ 
> > 2. 该文法不是$\text{LL(1)}$文法，主要原因如下：
> >    - 存在左递归，文法不能含有左递归
> >      - 产生式$\check{A}{\to}\varepsilon|\check{A}A$中，选项$\check{A}A$是直接左递归的(即$\check{A}{\to}\check{A}A$)
> >      - 同样，产生式$\check{I}{\to}i|\check{I},i$中，选项$\check{I},i$是直接左递归的(即$\check{I}{\to}\check{I},i$)
> >    - 存在公共左因子：它们的$\text{FIRST}$集相同交集非空，不满足$\text{LL(1)}$条件,需要提取公共左因子
> >      - 产生式$A{\to}Td|Td[\check{I}]$的两个选项$Td$和$Td[\check{I}]$拥有共同的前缀$Td$
> >      - 对于$\text{LL(1)}$文法，同一非终结符的各产生式候选串的FIRST集必须两两不交，此处
> >      - $\mathrm{FIRST}(Td){=}\mathrm{FIRST}(T){=}\{\mathrm{int},\mathrm{float}\}$
> >      - $\mathrm{FIRST}(Td[\check{I}]){=}\mathrm{FIRST}(T){=}\{\mathrm{int},\mathrm{float}\}$ 
> > 3. $\text{LL(1)}$文法转换过程
> >    - 消除$\check{A}$规则中的左递归
> >      - 原始规则(改写成标准形式以便消除左递归)：$\check{A}{\to}\check{A}A|\varepsilon$
> >      - 应用消除左递归的公式$X{\to}X\alpha|\beta{\Rightarrow}X{\to}{\beta}X',$及$X'{\to}{\alpha}X'|\varepsilon$
> >      - 这里，$X{=}\check{A}$，$\alpha{=}A$，$\beta{=}\varepsilon$
> >      - 转换后得到新的产生式：$\check{A}{\to}\check{A}'$和$\check{A}'{\to}A\check{A}'|\varepsilon$
> >    - 消除$\check{I}$规则中的左递归
> >      - 原始规则(改写成标准形式以便消除左递归)：$\check{I}{\to}\check{I},i|i$
> >      - 应用消除左递归的公式$X{\to}X\alpha|\beta{\Rightarrow}X{\to}{\beta}X',$及$X'{\to}{\alpha}X'|\varepsilon$
> >      - 这里，$X{=}\check{I}$，$\alpha{=},i$，$\beta{=}i$
> >      - 转换后得到新的产生式：$\check{I}{\to}i\check{I}'$和$\check{I}'{\to},i\check{I}'|\varepsilon$
> >    - 提取$A$规则中的公共左因子
> >      - 原始规则：$A{\to}Td|Td[\check{I}]$
> >      - 应用提取公共左因子的公式$X{\to}{\gamma}\delta_1|{\gamma}\delta_2{\Rightarrow}X{\to}{\gamma}X'',$及$X''{\to}\delta_1|\delta_2$
> >      - 这里$X{=}A$，公共左因子$\gamma{=}Td$，$\delta_1{=}\varepsilon$(对应$Td$)，$\delta_2{=}[\check{I}]$；我们引入新的非终结符$A'$(原$X''$)
> >      - 转换后得到新的产生式：$A{\to}TdA'$和$A'{\to}\varepsilon|[\check{I}]$ 
> > 4. 转换后的$\text{LL(1)}$文法：得到的$\text{LL(1)}$文法$G_{\text{LL(1)}}$如下：
> >    - $\check{A}{\to}\check{A}'$
> >    - $\check{A}'{\to}A\check{A}'|\varepsilon$
> >    - $A{\to}TdA'$
> >    - $A'{\to}\varepsilon|[\check{I}]$
> >    - $T{\to}\mathrm{int}|\mathrm{float}$
> >    - $\check{I}{\to}i\check{I}'$
> >    - $\check{I}'{\to},i\check{I}'|\varepsilon$
> >
> > :two:$S{\to}Ab$和$A{\to}a|B|\varepsilon$和$B{\to}b|\varepsilon$ (不是)
> >
> > 1. 判断文法非$\text{LL(1)}$及原因
> >    - 首先计算必要的$\mathrm{FIRST}$集和$\mathrm{FOLLOW}$集
> >      - $\mathrm{FIRST}(B){=}\{b,\varepsilon\}$，$\mathrm{FIRST}(A){=}\{a,b,\varepsilon\}$
> >      - $\mathrm{FOLLOW}(S){=}\{\$\}$，$\mathrm{FOLLOW}(A){=}\{b\}$，$\mathrm{FOLLOW}(B){=}\{b\}$
> >    - 对于$B{\to}b|\varepsilon$：
> >      - $\mathrm{Select}(B{\to}b){=}\{b\}$与$\mathrm{Select}(B{\to}\varepsilon){=}\{b\}$(因$\mathrm{FOLLOW}(B){=}\{b\}$)相交，在展望符$b$上冲突
> >    - 对于$A{\to}a|B|\varepsilon$：
> >      - $\mathrm{Select}(A{\to}B){=}\{b\}$(因$\mathrm{FIRST}(B)$可为$b$或$\varepsilon$
> >      - 且$\mathrm{FOLLOW}(A){=}\{b\}$)与$\mathrm{Select}(A{\to}\varepsilon){=}\{b\}$(因$\mathrm{FOLLOW}(A){=}\{b\}$)相交
> >      - 在展望符$b$上冲突
> >    - 该文法不是$\text{LL(1)}$文法，主要冲突如上(使用$\mathrm{Select}$集判断)
> > 2. $\text{LL(1)}$文法转换过程，通过代入和提取左因子进行转换：
> >    - 代入$B$：将$B{\to}b|\varepsilon$代入$A{\to}a|B|\varepsilon$中，得到文法$G_1$：$S{\to}Ab$及$A{\to}a|b|\varepsilon$
> >    - $G_1$仍非$\text{LL(1)}$：$A{\to}b$与$A{\to}\varepsilon$在展望符$b$上冲突(因$\mathrm{FOLLOW}(A){=}\{b\}$)
> >    - 代入$A$：将$A{\to}a|b|\varepsilon$从$G_1$代入$S{\to}Ab$中，得到文法$G_2$：$S{\to}ab|bb|b$
> >    - $G_2$仍非$\text{LL(1)}$：产生式$S{\to}bb$与$S{\to}b$的$\mathrm{FIRST}$集均包含$b$，存在选择冲突
> > 3. 对$G_2$中的$S{\to}ab|bb|b$提取左因子(针对$bb$和$b$)，得到文法$G_3$：$S{\to}ab|bS'$和$S'{\to}b|\varepsilon$
> > 4. 最终得到的$\text{LL(1)}$文法$G_3$(即$G_{\text{$\text{LL(1)}$}}$)如下：$S{\to}ab|bS'$和$S'{\to}b|\varepsilon$ 
> >
> > :three:$S{\to}aSe|B$和$B{\to}bBe|C$和$C{\to}cCe|d$ (是)
> >
> > 1. $\text{FIRST}$集
> >    - $\mathrm{FIRST}(C){=}\{c, d\}$
> >    - $\mathrm{FIRST}(B){=}\{b, c, d\}$
> >    - $\mathrm{FIRST}(S){=}\{a, b, c, d\}$
> > 2. 假设$S$是开始符号，计算各非终结符的$\mathrm{FOLLOW}$集：
> >    - $\mathrm{FOLLOW}(S){=}\{\$,e\}$
> >    - $\mathrm{FOLLOW}(B){=}\{\$,e\}$
> >    - $\mathrm{FOLLOW}(C){=}\{\$,e\}$
> > 3. $\mathrm{LL}(1)$件检查：
> >    - 对于一个文法是$\mathrm{LL}(1)$文法，需满足：
> >      - 对于每个非终结符的任意两个不同产生式$X\to\alpha$和$X\to\beta$，$\mathrm{FIRST}(\alpha)\cap\mathrm{FIRST}(\beta){=}\emptyset$
> >      - 由于此文法中没有产生式能推导出空串$\varepsilon$，故无需检查$\mathrm{FIRST}$集与$\mathrm{FOLLOW}$集的交叉冲突
> >    - 对于$S{\to}aSe|B$：它们的交集为$\emptyset$
> >      - $\mathrm{FIRST}(aSe){=}\{a\}$
> >      - $\mathrm{FIRST}(B){=}\{b,c,d\}$
> >    - 对于$C{\to}cCe|d$：它们的交集为$\emptyset$
> >      - $\mathrm{FIRST}(cCe){=}\{c\}$
> >      - $\mathrm{FIRST}(d){=}\{d\}$
> >    - 所有条件均满足，该文法是$\mathrm{LL}(1)$文法

---

# 第六次作业

> ## ✅习题$\textbf{7.1}$
>
> > :zero:对图所示的$L_{7-7}$语言的$\text{PDA}$，写出从初始化$\text{ID}(q_1,w,Z_0)$开始，当输入串$w$为下面的串时所有移动线索，指出成功线索
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250605164947632.png" alt="image-20250605164947632" style="zoom:50%;" /> 
> >
> > :bulb:写在前面：
> >
> > 1. 追踪输入串$w{=}\text{010010}$在给定$\text{PDA}$上的所有移动线索，起始$\text{ID}$为$(q_1,\text{010010},Z_0)$
> > 2. 该$\text{PDA}$的状态转移可以理解为：
> >    - $q_1\xrightarrow{0,Z_0/Z_0}q_2$：消耗第一个$0$块的第一个$0$，栈不变
> >    - $q_1\xrightarrow{1,\varepsilon/\varepsilon}q_1$：跳过$1$
> >    - $q_2\xrightarrow{0,\varepsilon/0}q_3$：消耗第一个$0$块的第二个及以后的$0$，并将一个$0$压栈
> >    - $q_2\xrightarrow{1,\varepsilon/\varepsilon}q_1$：如果第一个$0$块只有一个$0$后遇到$1$，则返回$q_1$重新开始
> >    - $q_3\xrightarrow{0,\varepsilon/0}q_3$：继续消耗第一个$0$块的$0$，并压栈
> >    - $q_3\xrightarrow{1,\varepsilon/\varepsilon}q_4$：第一个$0$块结束，遇到分隔符$1$
> >    - $q_3\xrightarrow{0,\varepsilon/\varepsilon}q_5$：(非确定性转移)第一个$0$块结束后直接遇到第二个$0$块的第一个$0$
> >    - $q_4\xrightarrow{1,\varepsilon/\varepsilon}q_4$：跳过更多分隔符$1$
> >    - $q_4\xrightarrow{0,\varepsilon/\varepsilon}q_5$：消耗第二个$0$块的第一个$0$，栈不变
> >    - $q_5\xrightarrow{0,0/\varepsilon}q_5$：消耗第二个$0$块的后续$0$，并从栈顶弹出一个$0$
> >    - $q_5\xrightarrow{\varepsilon,Z_0/\varepsilon}q_6$：如果栈顶为$Z_0$(表示$0$块长度匹配)，则弹出$Z_0$进入接受状态$q_6$
> > 3. 符号约定：
> >    - $(q,w,S)$表示当前状态$q$，剩余输入串$w$，栈内容$S$(栈顶在左)
> >    - $\vdash$表示一步移动
> >    - $\varepsilon$在输入部分表示空串，在栈操作部分$X/\varepsilon$表示不压入任何符号，$\varepsilon/Y$表示不弹出任何符号
> >
> > :one:$010010$
> >
> > 0. 起始$\text{ID}$：$(q_1,\text{010010},Z_0)$
> > 1. $(q_1,\underline{0}\text{10010},Z_0){\vdash}(q_2,\text{10010},Z_0)$
> >    - 解释：读入$0$，根据$q_1{\to}{0,Z_0/Z_0}q_2$，栈顶$Z_0$被$Z_0$替换
> >    - 第一个$0$块的第一个$0$($0_a$)被处理
> > 2. $(q_2,\underline{1}\text{0010},Z_0){\vdash}(q_1,\text{0010},Z_0)$
> >    - 解释：读入$1$，根据$q_2{\to}{1,\varepsilon/\varepsilon}q_1$，栈无变化
> >    - 由于第一个$0$块长度为1后遇到$1$，$\text{PDA}$返回状态$q_1$
> > 3. $(q_1,\underline{0}\text{010},Z_0){\vdash}(q_2,\text{010},Z_0)$
> >    - 解释：读入$0$，根据$q_1{\to}{0,Z_0/Z_0}q_2$，栈顶$Z_0$被$Z_0$替换
> >    - 新的第一个$0$块的第一个$0$($0_c$)被处理
> > 4. $(q_2,\underline{0}\text{10},Z_0){\vdash}(q_3,\text{10},0Z_0)$
> >    - 解释：读入$0$，根据$q_2{\to}{0,\varepsilon/0}q_3$，将$0$压栈
> >    - 当前处理的第一个$0$块为$0_c0_d$(长度为2)，为其第二个$0$($0_d$)压入了一个$0$，栈变为$0Z_0$
> > 5. $(q_3,\underline{1}\text{0},0Z_0){\vdash}(q_4,\text{0},0Z_0)$
> >    - 解释：读入$1$，根据$q_3{\to}{1,\varepsilon/\varepsilon}q_4$栈无变化
> >    - 第一个$0$块$0_c0_d$结束，遇到分隔符$1$($1_e$)
> > 6. $(q_4,\underline{0},0Z_0){\vdash}(q_5,\varepsilon,0Z_0)$
> >    - 解释：读入$0$，根据$q_4{\to}{0,\varepsilon/\varepsilon}q_5$，栈无变化
> >    - 第二个$0$块的第一个$0$($0_f$)被处理
> > 7. $(q_5,\varepsilon,0Z_0)$
> >    - 解释：输入串已耗尽
> >    - 检查从$q_5$出发的$\varepsilon$-转移：$q_5{\to}{\varepsilon,Z_0/\varepsilon}q_6$，此转移要求栈顶必须是$Z_0$
> >    - 当前栈顶是$0$，而不是$Z_0$，因此该转移无法进行
> >    - $\text{PDA}$在此配置停机，由于$q_5$不是接受状态，该路径失败
> > 8. 总结：存在唯一的移动线索，该线索如下
> >    - $\small(q_1,\text{010010},Z_0){\vdash}(q_2,\text{10010},Z_0){\vdash}(q_1,\text{0010},Z_0){\vdash}(q_2,\text{010},Z_0){\vdash}(q_3,\text{10},0Z_0){\vdash}(q_4,\text{0},0Z_0){\vdash}(q_5,\varepsilon,0Z_0)$
> >    - 因为最终状态$q_5$不是接受状态，且无法通过$\varepsilon$-转移到达接受状态$q_6$，故输入串$010010$不被此$\text{PDA}$接受
> >
> > :two:$100101001$
> >
> > 1.  $\text{ID}$：$(q_1,100101001,Z_0)$
> >     - 读入：$1$
> >     - 转移：$q_1\xrightarrow{1,\varepsilon/\varepsilon}q_1$
> >     - 下一$\text{ID}$：$(q_1,00101001,Z_0)$
> > 2.  $\text{ID}$：$(q_1,00101001,Z_0)$
> >     - 读入：$0$
> >     - 栈顶：$Z_0$
> >     - 转移：$q_1\xrightarrow{0,Z_0/Z_0}q_2$(弹出$Z_0$,压入$Z_0$)
> >     - 下一$\text{ID}$：$(q_2,0101001,Z_0)$
> >     - 备注：第一个$0$块($00$)的首个$0$被处理
> > 3.  $\text{ID}$：$(q_2,0101001,Z_0)$
> >     - 读入：$0$
> >     - 转移：$q_2\xrightarrow{0,\varepsilon/0}q_3$(压入$0$)
> >     - 下一$\text{ID}$：$(q_3,101001,0Z_0)$
> >     - 备注：第一个$0$块($00$)的第二个$0$被处理，块长为2，栈中存入$2-1=1$个$0$
> > 4.  $\text{ID}$：$(q_3,101001,0Z_0)$
> >     - 读入：$1$
> >     - 转移：$q_3\xrightarrow{1,\varepsilon/\varepsilon}q_4$
> >     - 下一$\text{ID}$：$(q_4,01001,0Z_0)$
> >     - 备注：第一个$0$块结束，遇到分隔符$1$
> > 5.  $\text{ID}$：$(q_4,01001,0Z_0)$
> >     - 读入：$0$
> >     - 转移：$q_4\xrightarrow{0,\varepsilon/\varepsilon}q_5$
> >     - 下一$\text{ID}$：$(q_5,1001,0Z_0)$
> >     - 备注：第二个$0$块($0$)的首个$0$被处理，此块长度为1
> > 6.  $\text{ID}$：$(q_5,1001,0Z_0)$
> >     - 当前需读入：$1$
> >     - 栈顶：$0$
> >     - 可用转移:
> >         - $q_5\xrightarrow{0,0/\varepsilon}q_5$：需要读入$0$，不适用
> >         - $q_5\xrightarrow{\varepsilon,Z_0/\varepsilon}q_6$：$\varepsilon$转移，但要求栈顶为$Z_0$，当前为$0$，不适用
> >     - 结果：无可用转移计算停止，$\text{PDA}$未到达接受状态$q_6$
> > 7.  结论：输入串 $w = 100101001$，从初始化 $\text{ID}(q_1, 100101001, Z_0)$ 开始，该 $\text{PDA}$ 的完整移动线索
> >     - $\small(q_1, 100101001, Z_0){\vdash}(q_1, 00101001, Z_0){\vdash}(q_2, 0101001, Z_0){\vdash}(q_3, 101001, 0Z_0){\vdash}(q_4, 01001, 0Z_0){\vdash}(q_5, 1001, 0Z_0)$ 
> >     - 在此之后，$\text{PDA}$ 在状态$q_5$无法继续进行任何转移
> >     - 因此对于输入串$w{=}100101001$从指定的初始配置开始，不存在成功的移动线索 
>
> ## ✅习题$\textbf{7.2}$
>
> > :zero:设计$\text{PDA}$来接受下列语言，简要比较两种接受方式($P$或$N$)的设计结果
> >
> > - 所有$0$的个数是$1$的个数$2$倍的$0{-}1$串的集合
> >
> > :bulb:该语言可以形式化表示为$L{=}\{w\in\{0,1\}^*|n_0(w){=}2n_1(w)\}$
> >
> > 1. 其中$n_0(w)$是串$w$中$0$的个数，$n_1(w)$是串$w$中$1$的个数
> > 2. 这个条件等价于$n_0(w){-}2n_1(w){=}0$
> >
> > :one:解题思路
> >
> > 1. 我们将使用栈来追踪$n_0(w){-}2n_1(w)$的平衡
> >    - 栈顶符号$Z_0$：表示初始空栈，也代表当前平衡为$0$
> >    - 栈符号$X$：代表一个"净余的$0$"，即对$n_0(w){-}2n_1(w)$的贡献为$+1$
> >    - 栈符号$Y$：代表一个"需一个$0$的需求"(对平衡贡献${-}1$)，因此一个$1$的输入(对平衡贡献${-}2$)将对应两个$Y$
> > 2. $\text{PDA}$核心逻辑：读入$0$时$n_0{-}2n_1$的值增加$1$
> >    - 若栈顶为$Y$(当前有欠账)，则消耗一个$Y$(弹出$Y$)
> >    - 若栈顶为$X$或$Z_0$(当前无欠账或有盈余)，则压入一个$X$
> > 3. $\text{PDA}$核心逻辑：读入$1$时$n_0{-}2n_1$的值减少$2$
> >    * 若栈顶为$Z_0$，压入$YY$(产生两个单位的欠账)
> >    * 若栈顶为$Y$，再压入$YY$(欠账增加两个单位)
> >    * 若栈顶为$X$(一个盈余的$0$)，消耗它(弹出$X$)使得$n_0{-}2n_1$减少$1$，还需再减少$1$(通过一中间态$q_1$)：
> >      * 若在$q_1$时栈顶仍为$X$，则再弹出一个$X$
> >      * 若在$q_1$时栈顶为$Z_0$(说明之前只有一个$X$)，则将$Z_0$替换为$YZ_0$(产生一个单位的欠账)
> >
> > :two:$\text{PDA}$设计结果：$\text{PDA-}M_P$(通过最终状态接受${-}P$)
> >
> > 1. 五元组定义：$M_P{=}(Q_P,\Sigma,\Gamma_P,\delta_P,q_0,Z_0,F_P)$ 
> > 2. 状态集合$Q_P$：$\{q_0,q_1,q_f\}$
> >    * $q_0$：主要处理状态和初始状态
> >    * $q_1$：处理输入$1$时消耗栈中$X$的中间状态
> >    * $q_f$：唯一的最终接受状态
> > 3. 输入字母表$\Sigma$：$\{0,1\}$
> > 4. 栈字母表$\Gamma_P$：$\{X,Y,Z_0\}$($X$：$n_0{-}2n_1$贡献$+1$；$Y$：$n_0{-}2n_1$贡献${-}1$；$Z_0$：栈底/初始符号)
> > 5. 初始状态：$q_0$
> > 6. 初始栈符号：$Z_0$
> > 7. 最终状态集合$F_P$：$\{q_f\}$
> > 8. 转移函数$\delta_P$:
> >    - $(q_0,0,Z_0){\rightarrow}(q_0,XZ_0)$
> >    - $(q_0,0,X){\rightarrow}(q_0,XX)$
> >    - $(q_0,0,Y){\rightarrow}(q_0,\varepsilon)$(弹出$Y$，$\varepsilon$表示空串)
> >    - $(q_0,1,Z_0){\rightarrow}(q_0,YYZ_0)$
> >    - $(q_0,1,Y){\rightarrow}(q_0,YYY)$(弹出$Y$，压入$YYY$，净效果是压入$YY$)
> >    - $(q_0,1,X){\rightarrow}(q_1,\varepsilon)$(弹出$X$，进入$q_1$处理剩余的${-}1$效果)
> >    - $(q_1,\varepsilon,X){\rightarrow}(q_0,\varepsilon)$(在$q_1$弹出第二个$X$，返回$q_0$)
> >    - $(q_1,\varepsilon,Z_0){\rightarrow}(q_0,YZ_0)$(在$q_1$时栈顶为$Z_0$，说明原栈为$XZ_0$；$1{-}2{=}{-}1$，变为$YZ_0$，返回$q_0$)
> >    - $(q_0,\varepsilon,Z_0){\rightarrow}(q_f,Z_0)$(当输入串处理完毕且栈为$Z_0$时，进入接受状态$q_f$)
> >
> > :three:$\text{PDA}$设计结果：$\text{PDA-}M_N$(通过空栈接受${-}N$) 
> >
> > 1. 五元组定义：$M_N{=}(Q_N,\Sigma,\Gamma_N,\delta_N,q_0,Z_0)$
> > 2. 状态集合$Q_N$：$\{q_0,q_1\}$
> >    * $q_0$：主要处理状态和初始状态
> >    * $q_1$：处理输入$1$时消耗栈中$X$的中间状态
> > 3. 输入字母表$\Sigma$：$\{0,1\}$
> > 4. 栈字母表$\Gamma_N$：$\{X,Y,Z_0\}$
> > 5. 初始状态：$q_0$
> > 6. 初始栈符号：$Z_0$
> > 7. 最终状态集合：$\emptyset$(空栈接受不使用最终状态集合)
> > 8. 转移函数$\delta_N$:
> >    - $(q_0,0,Z_0){\rightarrow}(q_0,XZ_0)$
> >    - $(q_0,0,X){\rightarrow}(q_0,XX)$
> >    - $(q_0,0,Y){\rightarrow}(q_0,\varepsilon)$
> >    - $(q_0,1,Z_0){\rightarrow}(q_0,YYZ_0)$
> >    - $(q_0,1,Y){\rightarrow}(q_0,YYY)$
> >    - $(q_0,1,X){\rightarrow}(q_1,\varepsilon)$
> >    - $(q_1,\varepsilon,X){\rightarrow}(q_0,\varepsilon)$
> >    - $(q_1,\varepsilon,Z_0){\rightarrow}(q_0,YZ_0)$
> >    - $(q_0,\varepsilon,Z_0){\rightarrow}(q_0,\varepsilon)$(当输入串处理完毕且栈为$Z_0$时，弹出$Z_0$使栈为空，实现接受) 
> >
> > :four:两种接受方式的简要比较
> >
> > 1.  核心处理逻辑相同：
> >     - 两者使用相同的状态($q_0,q_1$)和转移规则来处理输入符号$0$和$1$
> >     - 并以相同的方式(使用栈符号$X,Y,Z_0$)追踪$n_0(w){-}2n_1(w)$的平衡
> > 2.  主要区别在于接受机制和最终步骤：
> >     * $M_P$(最终状态)：
> >         * 需要一个额外的最终状态$q_f$，状态集为$\{q_0,q_1,q_f\}$
> >         * 通过转移$(q_0,\varepsilon,Z_0){\to}(q_f,Z_0)$实现接受：当输入结束且栈为$Z_0$时，进入最终状态$q_f$而栈中仍保留$Z_0$
> >     * $M_N$(空栈)：
> >         * 不需要额外的最终状态，状态集为$\{q_0,q_1\}$
> >         * 通过转移$(q_0,\varepsilon,Z_0){\to}(q_0,\varepsilon)$实现接受：当输入结束且栈为$Z_0$时，弹出$Z_0$使栈变空
> > 3.  简洁性：$M_N$在状态数量上略微简洁一些(少一个状态$q_f$)
>
>
> ## ✅习题$\textbf{7.7}$
>
> > :one:此$\text{PDA}$是确定型吗
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250605235020094.png" alt="image-20250605235020094" style="zoom:50%;" /> 
> >
> > 1. 一个$\text{PDA}$是确定型的，其核心要求之一是
> >    - 如果在某个状态对某个栈顶符号存在$\varepsilon$-输入转换，则对同一状态和同一栈顶符号，不能存在消耗实际输入符号的转换
> >    - 简而言之，不能在“不读输入就换状态”和“读了输入才换状态”之间有选择
> > 2. 在状态$q_0$，存在以下关键转换(其中栈顶符号不影响弹出，用$\varepsilon$表示)：
> >    - 转换$(a)$-消耗输入$0$：$q_0{\xrightarrow{0,\varepsilon/0}}q_0$
> >    - 转换$(b)$-消耗输入$1$：$q_0{\xrightarrow{1,\varepsilon/1}}q_0$
> >    - 转换$(c)$-$\varepsilon$-输入：$q_0{\xrightarrow{\varepsilon,\varepsilon/\varepsilon}}q_1$
> > 3. 确定性检查
> >    - 在状态$q_0$：
> >      - 存在不消耗输入符号的$\varepsilon$-转换$(c)$到$q_1$
> >      - 同时，也存在消耗实际输入符号$0$的转换$(a)$到$q_0$，以及消耗$1$的转换$(b)$到$q_0$
> >    - 这意味着，当$\text{PDA}$处于状态$q_0$时，如果下一个输入符号是(例如)$0$：
> >      - 它可以选择执行转换(a)：消耗'0'，留在$q_0$
> >      - 它也可以选择执行转换(c)：不消耗'0'，转换到$q_1$
> >    - 这种选择的存在直接违反了确定型$\text{PDA}$的定义，此$\text{PDA}$不是确定型

---

# 第七次作业

> ## ✅习题$\textbf{8.1}$
>
> > :zero:对于文法$P{\to}\check{D}\check{S}$及$\check{D}{\to}\varepsilon|\check{D}D;$及$D{\to}\operatorname{int}d$及$\check{S}{\to}\varepsilon|S;\check{S}$及$S{\to}d{=}EE{\to}d|E{+}i$
> >
> > - 验证符号串$\check{D}D;d{=}E;\check{S}$是句子$\operatorname{int}\mathrm{x};\mathrm{x}{=}\mathrm{x}{+}1;$的一个句型，判断其是否为规范句型，另外指出这个句型的所有短语、直接短语和句柄
> >
> > :one:验证句型：一个字符串是某文法的句型则可从文法的开始符导出，可通过一最左推导来证明$\alpha$是一句型：
> >
> > 1.  $P$
> > 2.  ${\Rightarrow}\check{D}\check{S}$(使用规则$P{\to}\check{D}\check{S}$)
> > 3.  ${\Rightarrow}\check{D}D;\check{S}$(使用规则$\check{D}{\to}\check{D}D;$)
> > 4.  ${\Rightarrow}\check{D}D;S;\check{S}$(使用规则$\check{S}{\to}S;\check{S}$)
> > 5.  ${\Rightarrow}\check{D}D;d{=}E;\check{S}$(使用规则$S{\to}d{=}E$)
> > 6.   由于符号串$\check{D}D;d{=}E;\check{S}$可以从开始符号$P$推导出来，故其是该文法的一个句型
> >
> > :two:判断是否为规范句型：让我们构造目标句子的一个最右推导
> >
> > 1.  $P$
> > 2.  ${\Rightarrow}\check{D}\check{S}$(最右非终结符是$\check{S}$)
> > 3.  ${\Rightarrow}\check{D}S;\check{S}$(最右非终结符是$\check{S}$)
> > 4.  ${\Rightarrow}\check{D}S;{\varepsilon}{=}\check{D}S;$(最右非终结符是$S$)
> > 5.  ${\Rightarrow}\check{D}d{=}E;$(最右非终结符是$E$)
> > 6.  ${\Rightarrow}\check{D}d{=}E{+}i;$(最右非终结符是$E$)
> > 7.  ${\Rightarrow}\check{D}d{=}d{+}i;$(最右非终结符是$\check{D}$)
> > 8.  ${\Rightarrow}\check{D}D;d{=}d{+}i;$(继续展开最右的$\check{D}$)
> > 9.  ${\Rightarrow}{\varepsilon}D;d{=}d{+}i;{=}D;d{=}d{+}i;$(最右非终结符是$D$)
> > 10.  ${\Rightarrow}\operatorname{int}d;d{=}d{+}i;$
> > 11.  上述过程中并未出现$\check{D}D;d{=}E;\check{S}$，要得到该句型必须先对左侧的$\check{D}$进行推导，故不是一个规范句型
> >
> > :three:分析短语$/$直接短语$/$句柄
> >
> > 0. 我们可以构建出如下的语法树
> >    ```txt
> >             P
> >           /   \
> >          Ď₁    Š₁
> >         /|\   /|\
> >        Ď₂ D ; S₄ ; Š₅
> >               /|\
> >              d = E₇
> >    ```
> > 1.  短语:
> >     - 以$P$为根的子树，叶节点序列：$\check{D}D;d{=}E;\check{S}$
> >     - 以$\check{D}_1$为根的子树(产生式$\check{D}_1{\to}\check{D}_2D_3$；)，叶节点序列：$\check{D}D$；(其中$\check{D}$来自$\check{D}_2$，$D$来自$D_3$)
> >     - 以$\breve{S}_1$为根的子树(产生式$\breve{S}_1{\to}S_4;\breve{S}_5$)，叶节点序列：$d{=}E;\breve{S}$(其中$d{=}E$来自$S_4$，$\breve{S}$来自$\breve{S}_5$)
> >     - 以$S_4$为根的子树(产生式$S_4{\to}d_6{=}E_7$)，叶节点序列：$d{=}E$(其中$E$来自$E_7$)
> >     - 以$\check{D}_2$(句型中的$\check{D}$)为根的子树，叶节点序列：$\check{D}$
> >     - 以$D_3$(句型中的$D$)为根的子树，叶节点序列：$D$
> >     - 以$E_7$(句型中的$E$)为根的子树，叶节点序列：$E$
> >     - 以$\breve{S}_5$(句型中的$\breve{S}$)为根的子树，叶节点序列：$\breve{S}$
> >     - 短语集合：${\check{D},E,D,\check{S},d{=}E,\check{D}D;,d{=}E;\check{S},\check{D}D;d{=}E;\check{S}}$
> > 2.  直接短语:
> >     - $\check{D}D;$：直接由产生式$\check{D}{\to}\check{D}D;$得到
> >     - $d{=}E$：直接由产生式$S{\to}d{=}E$得到
> >     - 直接短语集合：${\check{D}D;,d{=}E}$
> > 3.  句柄:
> >     - 在句型$\check{D}D;d{=}E;\check{S}$中，最左边的直接短语是$\check{D}D;$
> >     - 句柄：$\check{D}D;$
> >
> > :four:结论：对于句型$\check{D}D;d{=}E;\check{S}$：
> >
> > 1. 是否为句型：是
> > 2. 是否为规范句型：否
> > 3. 所有短语：$\check{D},E,D,\check{S},d{=}E,\check{D}D;,d{=}E;\check{S},\check{D}D;d{=}E;\check{S}$
> > 4. 所有直接短语：$\check{D}D;,d{=}E$
> > 5. 句柄：$\check{D}D;$
>
> ## ✅习题$\textbf{8.2}$
>
> > :one:考虑文法$S{\rightarrow}a|{\wedge}|(T)$及$T{\rightarrow}T,S|S$，写出$(((a,a),{\wedge},(a)),a)$的规范归约及每一步的句柄
> >
> > | 步骤 | 句型                | 句柄  |   使用的产生式   | 说明                       |
> > | :--: | ------------------- | ----- | :--------------: | -------------------------- |
> > | 初始 | `(((a,a),^,(a)),a)` |       |                  | 初始输入串                 |
> > | $0$  | `(((a,a),^,(a)),a)` | `a`   |    $S{\to}a$     | 归约最左边的`a`            |
> > | $1$  | `(((S,a),^,(a)),a)` | `a`   |    $S{\to}a$     | 归约下一个最左边的`a`      |
> > | $2$  | `(((S,S),^,(a)),a)` | `S`   |    $T{\to}S$     | 归约最左边的`S`为`T`       |
> > | $3$  | `(((T,S),^,(a)),a)` | `T,S` |   $T{\to}T,S$    | 归约最左边的`T,S`为`T`     |
> > | $4$  | `(((T),^,(a)),a)`   | `(T)` |   $S{\to}(T)$    | 归约`(T)`为`S`             |
> > | $5$  | `((S,^,(a)),a)`     | `^`   | $S{\to}{\wedge}$ | 归约`^`(即${\wedge}$)为`S` |
> > | $6$  | `((S,S,(a)),a)`     | `a`   |    $S{\to}a$     | 归约括号内的`a`            |
> > | $7$  | `((S,S,(S)),a)`     | `S`   |    $T{\to}S$     | 归约括号内的`S`为`T`       |
> > | $8$  | `((S,S,(T)),a)`     | `(T)` |   $S{\to}(T)$    | 归约`(T)`为`S`             |
> > | $9$  | `((S,S,S),a)`       | `S`   |    $T{\to}S$     | 归约三个`S`中的第一个为`T` |
> > | $10$ | `((T,S,S),a)`       | `T,S` |   $T{\to}T,S$    | 归约最左边的`T,S`为`T`     |
> > | $11$ | `((T,S),a)`         | `T,S` |   $T{\to}T,S$    | 归约`T,S`为`T`             |
> > | $12$ | `((T),a)`           | `(T)` |   $S{\to}(T)$    | 归约`(T)`为`S`             |
> > | $13$ | `(S,a)`             | `a`   |    $S{\to}a$     | 归约末尾的`a`              |
> > | $14$ | `(S,S)`             | `S`   |    $T{\to}S$     | 归约最左边的`S`为`T`       |
> > | $15$ | `(T,S)`             | `T,S` |   $T{\to}T,S$    | 归约`T,S`为`T`             |
> > | $16$ | `(T)`               | `(T)` |   $S{\to}(T)$    | 归约`(T)`为`S`             |
> > | $17$ | `S`                 | -     |     归约完成     | 成功归约到开始符号         |
>
> ## ✅习题$\textbf{8.3}$
>
> > :zero:证明：文法$S{\to}A$及$A{\to}Ab|bBa$及$B{\to}aAc|a|aAb$是$\text{SLR(1)}$文法但不是$\mathrm{LR}(0)$文法
> >
> > :one:增广文法$G'$ 
> >
> > 0.  $S'{\to}S$
> > 1.  $S{\to}A$
> > 2.  $A{\to}Ab$
> > 3.  $A{\to}bBa$
> > 4.  $B{\to}aAc$
> > 5.  $B{\to}a$
> > 6.  $B{\to}aAb$
> > 7.  证明不是$\mathrm{LR}(0)$文法
> >
> > :two:证明不是$\mathrm{LR}(0)$文法
> >
> > 1. 在构造$\text{LR(0)}$项目集规范族时，我们得到项目集$\text{I6}$：
> >    - $B{\to}a{\cdot}Ac$
> >    - $B{\to}a{\cdot}$(规约项目)
> >    - $B{\to}a{\cdot}Ab$
> >    - $A{\to}{\cdot}Ab$
> >    - $A{\to}{\cdot}bBa$(若下一输入为$b$则移入)
> > 2. 在项目集$\text{I6}$中：
> >    - 项目$B{\to}a{\cdot}$是一个规约项目
> >    - 项目$A{\to}{\cdot}bBa$暗示如果下一个输入符号是$b$，则可以移入
> >    - 由于存在规约动作和移入动作，而$\mathrm{LR}(0)$分析器不使用向前看符号，因此产生移入${-}$规约冲突
> >    - 故该文法不是$\mathrm{LR}(0)$文法
> >
> > :two:证明是$\text{SLR(1)}$文法
> >
> > 1. 首先计算必要的$\text{FOLLOW}$集：
> >    - $\text{FOLLOW}(A){=}\{\$,b,c\}$
> >    - $\text{FOLLOW}(B){=}\{a\}$
> > 2. 分析冲突状态$\text{I6}$的$\text{SLR(1)}$情况：
> >    - 对于规约项目$B{\to}a{\cdot}$：仅当下一个输入符号属于$\text{FOLLOW}(B){=}\{a\}$时才规约
> >    - 对于移入情况：项目$A{\to}{\cdot}bBa$(或$A{\to}{\cdot}Ab$等导致$\text{FIRST}(A)$的情况)表明，当下一输入符号是$b$时移入
> >    - 在状态$\text{I6}$中，规约$/$移入动作的展望符{$a$}$/${$b$}，由于$\{a\}{\cap}\{b\}{=}\emptyset$，故在状态$\text{I6}$中不存在$\text{SLR(1)}$冲突
> > 3. 检查其他潜在冲突状态(例如包含多个规约项目的情况)：
> >    - 考虑状态$I_{11}{=}\text{GOTO}(\text{GOTO}(\text{$\text{I6}$},A),b)$其核心项目为：
> >      - $B{\to}aAb{\cdot}$
> >      - $A{\to}Ab{\cdot}$
> >    - 对于$B{\to}aAb{\cdot}$：规约的展望符为$\text{FOLLOW}(B){=}\{a\}$
> >    - 对于$A{\to}Ab{\cdot}$：规约的展望符为$\text{FOLLOW}(A){=}\{\$,b,c\}$
> >    - 由于$\{a\}{\cap}\{\$,b,c\}{=}\emptyset$，这两个规约动作的展望符集合不相交，因此不存在规约${-}$规约冲突
> >    - 对所有其他$\text{LR(0)}$项目集状态进行类似的$\text{SLR(1)}$分析，均未发现冲突
> >
> > :three:结论
> >
> > 1. 文法在状态$\text{I6}$存在$\mathrm{LR}(0)$移入${-}$规约冲突，故不是$\mathrm{LR}(0)$文法
> > 2. 通过使用$\text{FOLLOW}$集，状态$\text{I6}$的冲突在$\text{SLR(1)}$分析中得到解决，其他状态也通过$\text{SLR(1)}$规则得到解决
> > 3. 因此该文法是$\text{SLR(1)}$文法

---

# 第八次作业

> ## ✅习题$\textbf{9.1}$
>
> > :zero:给定文法$G_{(\mathrm{e})}{:}S{\to}e|(S)|SS$，计算次序默认为从左往右
> >
> > :one:试写出$\operatorname{att}\left(G_{(\mathrm{e})}\right)$能够计算句子的括号嵌套深度
> >
> > 0. 我们定义如下的属性文法：这是一个$\text{S-}$属性文法，所有属性均为综合属性
> > 1. 属性定义：
> >    - 文法符号：非终结符为$S$，终结符为`e`及`(`及`)`
> >    - 属性：为$S$定义一个综合属性`d`(记为$S.d$)，表示由$S$推导出的子句(字符串)的最大括号嵌套深度
> > 2. 语义规则：将语义规则与产生式关联起来，形成如下表格
> >    | 产生式         | 语义规则                  | 规则释义                                       |
> >    | :------------- | ------------------------- | ---------------------------------------------- |
> >    | $S{\to}e$      | $S.d{=}0$                 | 符号`e`本身不含任何括号，深度为$0$             |
> >    | $S{\to}(S_1)$  | $S.d{=}S_1.d{+}1$         | 在子句$S_1$的基础上向外包裹一层括号，深度加$1$ |
> >    | $S{\to}S_1S_2$ | $S.d{=}\max(S_1.d,S_2.d)$ | 两个子句并列连接，总深度等于两者深度的最大值   |
> >
> > :two:写出句子$e(e(e))(e)$的带注释语法树和语法制导的属性求
> >
> > 1. 语法分析树：为了区分产生式右部的多个相同非终结符，我们使用下标进行标记(例如$S_0,S_1,...$)
> >    ```txt
> >    S₀
> >    ├── S₁
> >    │   ├── S₃ -> e
> >    │   └── S₄ -> (S₅)
> >    │       └── S₅
> >    │           ├── S₆ -> e
> >    │           └── S₇ -> (S₈)
> >    │               └── S₈ -> e
> >    └── S₂ -> (S₉)
> >        └── S₉ -> e
> >    ```
> > 2. 带注释的语法树：标注其属性`d`的计算结果
> >    ```txt
> >    S₀ [d=2]
> >        ├── S₁ [d=2]
> >        │   ├── S₃ [d=0] -> e
> >        │   └── S₄ [d=2] -> (S₅)
> >        │       └── S₅ [d=1]
> >        │           ├── S₆ [d=0] -> e
> >        │           └── S₇ [d=1] -> (S₈)
> >        │               └── S₈ [d=0] -> e
> >        └── S₂ [d=1] -> (S₉)
> >            └── S₉ [d=0] -> e
> >    ```
> > 3. 语法制导的属性求值过程：属性的计算遵循对语法树的后序遍历(自底向上)顺序
> >    - 叶节点层面：
> >      - 应用$S{\to}e$规则：$S_3.d{=}0/S_6.d{=}0/S_8.d{=}0/S_9.d{=}0$
> >    - 向上计算第一层：
> >      - 应用$S{\to}(S_1)$规则：$S_7.d{=}S_8.d{+}1{=}0{+}1{=}1$
> >      - 用$S{\to}(S_1)$规则：$S_2.d{=}S_9.d{+}1{=}0{+}1{=}1$
> >    - 向上计算第二层:
> >      - 应用$S{\to}S_1S_2$规则：$S_5.d{=}\max(S_6.d,S_7.d){=}\max(0,1){=}1$
> >    - 向上计算第三层:
> >      - 应用$S{\to}(S_1)$规则：$S_4.d{=}S_5.d{+}1{=}1{+}1{=}2$
> >    - 向上计算第四层:
> >      - 应用$S{\to}S_1S_2$规则：$S_1.d{=}\max(S_3.d,S_4.d){=}\max(0,2){=}2$
> >    - 根节点计算:
> >      - 应用$S{\to}S_1S_2$规则：$S_0.d{=}\max(S_1.d,S_2.d){=}\max(2,1){=}2$
> >    - 最终句子`e(e(e))(e)`的根节点属性值为$2$，即其最大括号嵌套深度为$2$
> >
> > :three:观察第:two:步结果，试归纳对于$L\left(G_{(e)}\right)$的任意句子，二者之间的对应关系
> >
> > 1. 对于文法$G_{(e)}$生成的语言$L(G_{(e)})$中的任意一个句子$w$：
> >    - 其真实的物理最大括号嵌套深度，与通过上述属性文法$\operatorname{att}(G_{(\mathrm{e})})$对其语法分析树进行属性计算后
> >    - 在根节点(起始符号$S$)上得到的综合属性值$S.d$完全相等
> > 2. 这种对应关系是必然的，因为：
> >    - 在数学上精确地模拟了“无括号”、“增加嵌套”和“并列取最大”这三种物理操作
> >    - 本例中，我们成功地为$G_{(e)}$的语法结构赋予了“计算嵌套深度”的语义
>
> ## ✅习题$\textbf{9.3}$
>
> > :zero:(编译原理)按特定模式翻译下列声明为符号表表示，并写出翻译后的符号表的属性表表示
> >
> > ```C++
> > (1) int x ; float b[3,6]; int foo(int x){int y; Š}; Š
> > (2) int h(int f(); int y;) {int g(int c[];){Š}; Š}; Š
> > ```
> >
> > :one:$(1)$的全局符号表
> >
> > 1. 全局符号表：
> >    ```C
> >    @table:(
> >        outer:NULL
> >        width:80  // x占4字节 + b数组72字节 (3*6*4) + 对齐填充(可选)
> >        argc:0    // 全局无参数
> >        arglist:NIL
> >        level:0   // 全局层级
> >        code[...] // 全局代码占位(如初始化代码)
> >        entry:(   // 假设偏移从4开始(0可能为保留地址)
> >           name:X  
> >           type:INT  
> >           offset:4
> >        )  
> >        entry:(   // 基地址8(x后对齐)
> >           name:b  
> >           type:ARRAY  
> >           base:8  
> >           etype:FLOAT  
> >           dims:2  
> >           dim[0]:3  
> >           dim[1]:6
> >        )  
> >        entry:(   // 函数入口点从80开始
> >           name:foo  
> >           type:FUNC  
> >           offset:80  
> >           mytab:foo@table
> >        )  
> >    )
> >    ```
> > 2. `foo`的局部符号表：
> >    ```C
> >    foo@table:(
> >        outer:@table    // 正确引用全局
> >        width:8         // 参数x(4字节) + 局部y(4字节)
> >        argc:1          // 一个参数
> >        arglist:list(X) // 参数列表
> >        rtype:INT       // 返回类型int(函数特有)
> >        code:[...]      // 函数代码
> >        level:1         // 函数内层级
> >        entry:(
> >           name:X  
> >           type:INT  
> >           offset:4
> >        )               // 参数x(栈帧偏移)
> >        entry:(
> >           name:y  
> >           type:INT  
> >           offset:8
> >        )             // 局部变量y
> >    )
> >    ```
> >
> > :two:$(2)$的全局符号表
> >
> > 1. 全局符号表 
> >    ```C++
> >    @table:(
> >        outer: NULL,
> >        width: 0,       // 全局作用域没有变量，宽度为0
> >        level: 0,       // 全局作用域为第0层
> >        entry:(
> >            name: h,
> >            type: FUNC,
> >            mytab: h@table  // 链接到函数h自己的符号表
> >        )
> >    )
> >    ```
> > 2. 函数`h`的符号表
> >    ```C
> >    h@table:(
> >        outer: @table,      // 外部作用域是全局符号表
> >        width: 8,           // 参数f(函数指针,4字节) + 参数y(int,4字节)
> >        level: 1,           // 第1层嵌套
> >        rtype: INT,         // h的返回类型
> >        argc: 2,
> >        entry:(
> >            name: f,
> >            type: FUNC,      // 类型为函数(或函数指针)
> >            offset: 4,       // 在h栈帧中的偏移
> >            rtype: INT,      // f自身的返回类型
> >            argc: 0          // f自身的参数个数
> >        ),
> >        entry:(
> >            name: y,
> >            type: INT,
> >            offset: 8        // 在h栈帧中的偏移
> >        ),
> >        entry:(
> >            name: g,
> >            type: FUNC,
> >            mytab: g@table   // 链接到函数g自己的符号表
> >        )
> >    )
> >    ```
> > 3.  函数`g`的符号表
> >    ```C++
> >    g@table:(
> >        outer: h@table,     // 关键：外部作用域是h的符号表，不是全局表
> >        width: 4,           // 参数c(指针,4字节)
> >        level: 2,           // 第2层嵌套
> >        rtype: INT,         // g的返回类型
> >        argc: 1,
> >        entry:(
> >            name: c,
> >            type: PTR,       // 类型为指针
> >            etype: INT,      // 指向的元素类型为int
> >            offset: 4        // 在g栈帧中的偏移
> >        )
> >    )
> >    ```

---

# 第九次作业

> ## ✅习题$\textbf{10.2}$
>
> > :one:翻译下列高级语言语句，写出翻译成的三地址代码段，并给出带注释的语法树
> >
> > ```C++
> > while(1<x && y>1)
> > if(-n+2 < x*y)a =100
> > else b = a
> > ```
> > 1. 三地址代码序列：
> >    ```assembly
> >    L1: t1 = 1 < x          // 计算条件 1 < x，结果存入 t1 (布尔值)
> >        if t1 == false goto L4 // 若 1 < x 为假，则跳转到循环结束 (L4)
> >        t2 = y > 1          // 计算条件 y > 1，结果存入 t2 (布尔值)
> >        if t2 == false goto L4 // 若 y > 1 为假，则跳转到循环结束 (L4)
> >        t3 = -n             // 计算 -n，结果存入 t3
> >        t4 = t3 + 2         // 计算 -n + 2，结果存入 t4
> >        t5 = x * y          // 计算 x * y，结果存入 t5
> >        t6 = t4 < t5        // 计算 -n+2 < x*y，结果存入 t6 (布尔值)
> >        if t6 == true goto L3 // 若条件为真，则跳转到 then 部分 (L3)
> >        b = a               // else 部分：执行 b = a
> >        goto L1             // 跳回循环条件检查 (L1)
> >    L3: a = 100            // then 部分：执行 a = 100
> >        goto L1             // 跳回循环条件检查 (L1)
> >    L4:                     // 循环结束标签 (后续代码)
> >    ```
> >    - `L1`: 循环条件检查起点，计算 `1 < x`，如果为假，则短路跳转到循环结束 (`L4`)
> >    - 如果 `1 < x` 为真，继续计算 `y > 1`，如果为假，跳转到 `L4`
> >    - 循环体：计算 if 条件 `-n+2 < x*y`：
> >      - `t3 = -n`: 一元负操作
> >      - `t4 = t3 + 2`: 加法操作
> >      - `t5 = x * y`: 乘法操作
> >      - `t6 = t4 < t5`: 比较操作
> >    - 基于 `t6` 分支：
> >      - 如果为真，跳转到 `L3` 执行 `a = 100`
> >      - 如果为假，执行 `b = a`，然后跳回 `L1`
> >    - `L3` 和 else 部分后都跳回 `L1`，重新检查循环条件
> >    - `L4`: 循环结束点(无后续代码时，此为终点)
> > 2. 带注释的语法树
> >    ```bash
> >    WhileStmt (while 语句)
> >    ├── Cond: LogicalAndExpr (逻辑与表达式: &&)
> >    │   ├── Left: RelationalExpr (关系表达式: <)
> >    │   │   ├── LeftOperand: Constant (常量: 1)
> >    │   │   └── RightOperand: Variable (变量: x)
> >    │   └── Right: RelationalExpr (关系表达式: >)
> >    │       ├── LeftOperand: Variable (变量: y)
> >    │       └── RightOperand: Constant (常量: 1)
> >    └── Body: IfStmt (if 语句)
> >        ├── Cond: RelationalExpr (关系表达式: <)
> >        │   ├── LeftOperand: AdditiveExpr (加法表达式: +)
> >        │   │   ├── LeftOperand: UnaryExpr (一元表达式: -)
> >        │   │   │   └── Operand: Variable (变量: n)
> >        │   │   └── RightOperand: Constant (常量: 2)
> >        │   └── RightOperand: MultiplicativeExpr (乘法表达式: *)
> >        │       ├── LeftOperand: Variable (变量: x)
> >        │       └── RightOperand: Variable (变量: y)
> >        ├── ThenPart: AssignmentStmt (赋值语句)
> >        │   ├── LValue: Variable (变量: a)
> >        │   └── RValue: Constant (常量: 100)
> >        └── ElsePart: AssignmentStmt (赋值语句)
> >            ├── LValue: Variable (变量: b)
> >            └── RValue: Variable (变量: a)
> >    ```
> >    - `WhileStmt`: 表示 `while` 循环，包含两个子节点：`Cond`(条件表达式)和 `Body`(循环体语句)
> >    - `LogicalAndExpr`: 逻辑与操作 (`&&`)，短路求值：先求值左操作数，若为假则跳过右操作数
> >    - `RelationalExpr`: 关系比较操作 (`<` 或 `>`)，返回布尔值
> >    - `AdditiveExpr`: 加法操作 (`+`)，操作数为表达式结果
> >    - `UnaryExp`r: 一元负操作 (`-`)，优先级最高
> >    - `MultiplicativeExpr`: 乘法操作 (`*`)，优先级高于加法
> >    - `AssignmentStmt`: 赋值操作 (`=`)，`LValue` 为左值(赋值目标)，`RValue` 为右值(表达式或常量)
> >    - `Variable`: 变量标识符(如 `x`, `y`, `n`, `a`, `b`)
> >    - `Constant`: 常量值(如 `1`, `2`, `100`)
>
> ## ✅习题$\textbf{10.3}$
>
> > :zero:$\text{C}$语言的$\text{for}$语句的文法$S{\to}\mathrm{for}(S;B;S)S$ 的含义如下：
> >
> > ```C
> > S[1].code
> > while(B.code) {
> >  	S[3].code
> >  	S[2].code
> > }
> > ```
> >
> > :bulb:语句语义说明：给定文法$S{\to}\mathrm{for}(S;B;S)S$，语义等价于以下代码结构
> >
> > ```C++
> > S[1].code;          // 初始化语句
> > while(B.code) {     // 条件判断
> >  	S[3].code;      // 循环体语句
> >  	S[2].code;      // 更新语句
> > }
> > ```
> >
> > :one:设计属性文法把$\text{C}$语言的$\text{for}$语句翻译为三地址代码
> >
> > 1. 属性定义：
> >    - 合成属性：
> >      - `S.code`：生成的完整三地址代码序列
> >      - `S_1.code`, `S_2.code`, `S_3.code`, `B.code`：子节点生成的代码
> >    - 继承属性：
> >      - `B.false`：当条件为假时跳转的目标标签
> >    - 辅助函数：
> >      - `new_label()`：生成唯一标签(如`L1, L2`)
> >      - `label(L)`：生成标签定义代码(如`L1:`)
> >      - `goto(L)`：生成无条件跳转指令(如`goto L1`)
> >      - `if_false(t, L)`：生成条件跳转指令(如 `if_false t1 goto L2`)
> > 2. 语义规则：
> >    - 生成标签：
> >      - $L_{\text{begin}}{=}\text{new\_label}()$(循环开始标签)
> >      - $L_{\text{end}}{=}\text{new\_label}()$(循环结束标签)
> >    - 设置继承属性：
> >      - $B.\text{false}{=}L_{\text{end}}$(条件假时跳转至结束)
> >    - 合成代码：
> >      - $S.\text{code}{=}S_1.\text{code}$ 
> >      -  $\text{label}(L_{\text{begin}})$  
> >      - $B.\text{code}$  
> >      - $S_3.\text{code}$  
> >      - $S_2.\text{code}$  
> >      - $\text{goto}(L_{\text{begin}})$  
> >      - $\text{label}(L_{\text{end}})$
> > 3. 控制流解释：
> >    ```txt
> >    初始化代码 (S1)
> >    循环开始标签 (L_begin)
> >    条件判断代码 (B) -> 包含条件跳转(若假则跳至L_end)
> >    循环体代码 (S3)
> >    更新语句代码 (S2)
> >    跳回循环开始 (goto L_begin)
> >    循环结束标签 (L_end)
> >    ```
> >
> > :two:把语句`for (i=0; i<100; i=i+1) print i`翻译为三地址代码段
> >
> > 1. 输入语句：`for (i=0; i<100; i=i+1) print i`
> > 2. 三地址代码：
> >    ```assembly
> >    1: i = 0          ; 初始化 (S1)
> >    2: L1:            ; 循环开始标签
> >    3:   t1 = i < 100 ; 条件求值 (B)
> >    4:   if_false t1 goto L2 ; 条件假时跳转
> >    5:   print i      ; 循环体 (S3)
> >    6:   i = i + 1    ; 更新语句 (S2)
> >    7:   goto L1      ; 跳回循环开始
> >    8: L2:            ; 循环结束标签
> >    ```
> > 3. 执行流程：
> >    - 初始化 `i=0`(仅执行一次)
> >    - 检查条件 `i<100`：
> >      - 若真：执行循环体(打印$i$)$\to$更新($i{=}i{+}1$)$\to$返回步骤$2$
> >      - 若假：跳转至$\text{L2}$结束循环
> >    - 循环结束后继续后续代码
> >
> > :three:给出带注释的语法树作为对翻译过程和结果的解释
> >
> > ```mermaid
> > graph TD
> >     S["S: for(S₁; B; S₂) S₃
> >     <br>合成属性：
> >     <br>code = S₁.code + 'L1:' + B.code + S₃.code + S₂.code + 'goto L1' + 'L2:'
> >     <br>生成代码：
> >     <br>1: i=0
> >     <br>2: L1:
> >     <br>3:   t1=i&lt;100
> >     <br>4:   if_false t1 goto L2
> >     <br>5:   print i
> >     <br>6:   i=i+1
> >     <br>7:   goto L1
> >     <br>8: L2:"]
> > 
> >     L["标签生成
> >     <br>L_begin = L1
> >     <br>L_end = L2"]
> > 
> >     S1["S₁: i=0
> >     <br>合成属性：
> >     <br>code = 'i=0'"]
> > 
> >     B["B: i&lt;100
> >     <br>继承属性：false = L2
> >     <br>合成属性：
> >     <br>code = 't1=i&lt;100' + 'if_false t1 goto L2'"]
> > 
> >     S2["S₂: i=i+1
> >     <br>合成属性：
> >     <br>code = 'i=i+1'"]
> > 
> >     S3["S₃: print i
> >     <br>合成属性：
> >     <br>code = 'print i'"]
> > 
> >     S --> L
> >     S --> S1
> >     S --> B
> >     S --> S2
> >     S --> S3
> >     B -. 继承属性 .-> L
> > ```
> >
> > 1. 自顶向下传递继承属性：
> >    - 根节点 S 生成标签$\text{L1}$和$\text{L2}$
> >    - 将 `B.false = L2` 传递给布尔表达式节点
> > 2. 自底向上合成代码属性：
> >    - 叶节点生成基础指令：
> >      - `S₁ -> i=0`
> >      - `B  -> t1=i<100 + if_false t1 goto L2`(使用继承属性$\text{L2}$)
> >      - `S₃ -> print i`
> >      - `S₂ -> i=i+1`
> > 3. 根节点最终合成：
> >    ```asm
> >    i=0        ; S₁.code
> >    L1:        ; label(L_begin)
> >    t1=i<100   ; B.code (第1部分)
> >    if_false t1 goto$\text{L2}$ ; B.code (第2部分)
> >    print i    ; S₃.code
> >    i=i+1      ; S₂.code
> >    goto$\text{L1}$   ; goto(L_begin)
> >    L2:        ; label(L_end)
> >    ```
> > 4. 语法树解释：
> >    - 标签节点：动态生成唯一标签 L1(循环开始)和$\text{L2}$(循环结束)
> >    - 初始化节点 `S₁`：生成赋值指令 `i=0`(仅执行一次)
> >    - 条件节点`B`：
> >      - 使用继承属性 `false=L2`(假时跳转目标)
> >      - 生成条件求值 `t1=i<100` 和跳转指令 `if_false t1 goto L2`
> >    - 循环体节点`S₃`：生成打印指令 `print i`
> >    - 更新节点`S₂`：生成更新指令 `i=i+1`
> >    - 根节点`S`：整合所有子节点代码，插入标签和跳转指令，形成完整循环结构
>
>
> ## ✅习题$\textbf{10.5}$
>
> > :zero:对如下程序声明：采用全局名的翻译样例写出以下内容
> >
> > - `＠table`，`＠code`，`bar＠table`，` bar＠code`，`foo＠table`，`foo＠code`
> > ```C++
> > int x; float z;
> > int a[10, 20], b[6];
> > float bar(int brr[6];) {
> >     float x;
> >     x = brr[0]+brr[5];
> >     return x};
> > float foo(int x; float boo0; int arr[10, 10];) {
> >     if(x==0) z = sqrt(boo(arr[0, 0],),)
> >     else return boo(arr[x, x],)};
> > ```
> > 0. 符号表层级
> >    ```C++
> >    符号表层级结构
> >    └── @table (全局作用域)
> >        ├── bar@table (bar函数作用域)
> >        └── foo@table (foo函数作用域)
> >    ```
> > 1. 全局符号表(`@table`)
> >    ```C++
> >    @table:(
> >        outer: NULL,           // 全局作用域，没有外部作用域
> >        width: 832,            // 数据区总宽度: x(4)+z(4)+a(800)+b(24) = 832字节
> >        level: 0,              // 全局作用域层级为0
> >        argc: 0,               // 全局作用域没有参数
> >        arglist: NIL,
> >        entry:(
> >            name: x,
> >            type: INT,
> >            offset: 0          // 偏移量从0开始
> >        ),
> >        entry:(
> >            name: z,
> >            type: FLOAT,
> >            offset: 4          // x之后，偏移量为4
> >        ),
> >        entry:(
> >            name: a,
> >            type: ARRAY,
> >            base: 8,           // z之后，基地址为8
> >            etype: INT,        // 元素类型为int
> >            dims: 2,           // 2个维度
> >            dim[0]: 10,
> >            dim[1]: 20         // 数组大小 = 10 * 20 * 4 = 800字节
> >        ),
> >        entry:(
> >            name: b,
> >            type: ARRAY,
> >            base: 808,         // a之后，基地址为 8 + 800 = 808
> >            etype: INT,
> >            dims: 1,           // 1个维度
> >            dim[0]: 6          // 数组大小 = 6 * 4 = 24字节
> >        ),
> >        entry:(
> >            name: bar,
> >            type: FUNC,
> >            offset: 832,       // 假设bar函数的代码区入口地址紧随数据区之后
> >            rtype: FLOAT,                           // 返回类型
> >            mytab: bar@table                        // 指向其自身的符号表
> >        ),
> >        entry:(
> >            name: foo,
> >            type: FUNC,
> >            offset: 836,       // 假设foo函数的代码区入口地址在bar之后（地址为示意）
> >            rtype: FLOAT,                           // 返回类型
> >            mytab: foo@table                        // 指向其自身的符号表
> >        )
> >    )
> >    ```
> > 2. `bar`的局部符号表 (`bar@table`)
> >    ```C++
> >    bar@table:(
> >        outer: @table,         // 外部作用域是全局符号表
> >        width: 8,              // 栈帧宽度: 参数brr_ptr(4) + 局部变量x(4) = 8字节
> >        level: 1,              // 层级为1
> >        rtype: FLOAT,          // 函数返回类型
> >        argc: 1,               // 1个参数
> >        arglist: list(brr),
> >        entry:(                // 参数 brr (int brr[6];)
> >            name: brr,
> >            type: PTR,         // 数组作为参数，实际传递的是指针
> >            etype: INT,        // 指向整数的指针
> >            offset: 4          // 指针在栈帧中的偏移量（示意）
> >        ),
> >        entry:(                // 局部变量 x
> >            name: x,
> >            type: FLOAT,
> >            offset: 8          // 局部变量x在brr指针之后的偏移量（示意）
> >        )
> >    )
> >    ```
> > 3. `foo`的局部符号表 (`foo@table`)
> >    ```C++
> >    foo@table:(
> >        outer: @table,         // 外部作用域是全局符号表
> >        width: 12,             // 栈帧宽度: 参数x(4) + boo0(4) + arr_ptr(4) = 12字节
> >        level: 1,              // 层级为1
> >        rtype: FLOAT,          // 函数返回类型
> >        argc: 3,               // 3个参数
> >        arglist: list(x, boo0, arr),
> >        entry:(                // 参数 x (int x;)
> >            name: x,
> >            type: INT,
> >            offset: 4          // 参数x在栈帧中的偏移量（示意）
> >        ),
> >        entry:(                // 参数 boo0 (float boo0;)
> >            name: boo0,
> >            type: FLOAT,
> >            offset: 8          // 参数boo0的偏移量（示意）
> >        ),
> >        entry:(                // 参数 arr (int arr[10, 10];)
> >            name: arr,
> >            type: PTR,         // 数组作为参数，实际传递的是指针
> >            etype: INT,        // 指向整数的指针
> >            offset: 12         // 指针arr的偏移量（示意）
> >        )
> >    )
> >    ```
> > 4. 全局代码 (`@code`)
> >    ```C++
> >    @code:(
> >        // 全局变量的初始化（如有，否则默认为零或未初始化）
> >        // 程序执行的入口点（例如，调用main函数，如果已定义）
> >        // 对于此代码段，主要是数据定义，没有可执行的全局代码
> >        label global_data_definitions_end
> >    )
> >    ```
> > 5. `bar`函数代码 (`bar@code`)
> >    ```C++
> >    bar@code:(
> >        label bar_entry:
> >            // 源代码: x = brr[0] + brr[5];
> >            // brr 是一个指针参数 (在bar@table中偏移量为4)
> >            // local_x 是一个浮点型局部变量 (在bar@table中偏移量为8)
> >          
> >            // t1 = brr[0]
> >            addr_brr = load_param_addr brr       // 获取指针brr的值
> >            idx0 = const_0
> >            offset0 = mul idx0, 4                // 元素大小为4字节
> >            addr_brr_0 = add addr_brr, offset0
> >            t1 = load_indirect addr_brr_0        // 解引用以获取brr[0]的值
> >          
> >            // t2 = brr[5]
> >            idx5 = const_5
> >            offset5 = mul idx5, 4                // 元素大小为4字节
> >            addr_brr_5 = add addr_brr, offset5
> >            t2 = load_indirect addr_brr_5        // 解引用以获取brr[5]的值
> >          
> >            // t3 = t1 + t2
> >            t3 = add t1, t2                      // 执行整数加法
> >            // 因为局部变量x是float，而brr数组是int，所以和需要从int转换为float
> >            t3_float = int_to_float t3           // 将整数结果转换为浮点数
> >          
> >            // x = t3_float (赋值给局部变量x)
> >            addr_local_x = get_local_addr x      // 获取局部变量x的地址
> >            store_indirect addr_local_x, t3_float // 将浮点数结果存入x
> >          
> >            // 源代码: return x;
> >            val_to_return = load_indirect addr_local_x // 加载x的值用于返回
> >            return val_to_return
> >        label bar_exit:
> >    )
> >    ```
> > 6. `foo`函数代码 (`foo@code`)
> >
> >    ```C++
> >    foo@code:(
> >        label foo_entry:
> >            // param_x 是参数x (在foo@table中偏移量为4)
> >            // global_z 是全局变量z (在@table中偏移量为4)
> >            // param_arr 是参数arr (在foo@table中偏移量为12)
> >          
> >            // 源代码: if(x==0)
> >            val_param_x = load_param x
> >            const0_int = const_0
> >            condition = eq val_param_x, const0_int
> >            if_false_goto L_ELSE, condition      // 如果x不等于0，则跳转到L_ELSE
> >          
> >        L_THEN: // x == 0 分支
> >            // 源代码: z = sqrt(boo(arr[0, 0]))
> >          
> >            // t1 = arr[0,0]
> >            addr_param_arr = load_param_addr arr // 获取指针arr的值
> >            row_idx0 = const_0
> >            col_idx0 = const_0
> >            // 地址计算公式(行主序): offset = (行索引 * 列数 + 列索引) * 元素大小
> >            // 对于arr[10, 10]，列数(NUM_COLS)为10，元素大小为4
> >            temp1_arr = mul row_idx0, 10
> >            temp2_arr = add temp1_arr, col_idx0
> >            offset_arr00 = mul temp2_arr, 4
> >            addr_arr_0_0 = add addr_param_arr, offset_arr00
> >            t1 = load_indirect addr_arr_0_0      // 解引用以获取arr[0][0]的值
> >          
> >            // t2 = boo(t1)
> >            param_for_boo1 = t1
> >            t2 = call_external boo, param_for_boo1 // 调用外部函数boo
> >          
> >            // t3 = sqrt(t2)
> >            param_for_sqrt = t2
> >            t3 = call_external sqrt, param_for_sqrt // 调用外部函数sqrt
> >          
> >            // z = t3 (赋值给全局变量z)
> >            addr_global_z = get_global_addr z    // 获取全局变量z的地址
> >            store_indirect addr_global_z, t3     // 将结果存入z
> >            goto L_ENDIF                         // 跳转到if语句结束处
> >          
> >        L_ELSE: // x != 0 分支
> >            // 源代码: return boo(arr[x, x])
> >          
> >            // t4 = arr[x,x]
> >            addr_param_arr_else = load_param_addr arr
> >            row_idx_x = val_param_x              // 使用参数x的值作为行索引
> >            col_idx_x = val_param_x              // 使用参数x的值作为列索引
> >            // 地址计算公式: offset = (x * 10 + x) * 4
> >            temp1_arr_else = mul row_idx_x, 10
> >            temp2_arr_else = add temp1_arr_else, col_idx_x
> >            offset_arr_xx = mul temp2_arr_else, 4
> >            addr_arr_x_x = add addr_param_arr_else, offset_arr_xx
> >            t4 = load_indirect addr_arr_x_x      // 解引用以获取arr[x][x]的值
> >          
> >            // t5 = boo(t4)
> >            param_for_boo2 = t4
> >            t5 = call_external boo, param_for_boo2 // 调用外部函数boo
> >          
> >            return t5       // 返回boo函数调用的结果
> >          
> >        L_ENDIF:
> >            // 如果 x == 0，控制流会到达这里。
> >            // 源函数被声明为返回float，但这个分支没有返回值，这是一个语义错误。
> >            // 编译器可能会插入一个默认返回值（例如0.0f）或者报告一个编译错误。
> >            // 在代码翻译中，我们仅表示此路径的控制流结束。
> >            nop                                  
> >            // 空操作，表示"then"分支的结束
> >        label foo_exit:
> >    )
> >    ```

# 第十次作业

> # 第十次作业
>
> ## ✅习题$\textbf{11.2}$
>
> > :zero:对于下列程序
> >
> > ```C++
> > intraw(intx;){
> > 	y=x+5;
> > 	returny;
> > voidfoo(inty;){
> > 	intz;
> > 	voidbar(intx;intsoo();){
> > 	if(x>3)bar(x/3,soo(),)elsez=soo(x);
> > 	printz};
> > 	bar(y,raw(),)};
> > foo(6,)
> > ```
> >
> > 1. 写出当执行到第$8$行的`return`语句时的栈快照，假定栈快照的起始单元地址为$500$
> > 2. 额外包括写出符号表、活动树、各活动记录
> >
> > :bulb:程序分析
> >
> > 1. 程序行为：
> >    - `raw`函数：接受一个整数参数`x`，计算`y=x+5`(`y`为局部变量)，并返回`y`
> >    - `foo`函数：接受一个整数参数`y`，定义局部变量`z`，并定义嵌套函数`bar`
> >    - `bar`函数：嵌套在`foo`内
> >      - 接受整数参数`x`和函数指针参数`soo`(返回整数)如果`x>3`，则递归调用`bar(x/3,soo)`；
> >      - 否则，调用`soo(x)`并将结果赋给`foo`的局部变量`z`，然后打印`z`
> >    - 程序入口：调用`foo(6)`
> >
> > 2. 执行流程：
> >    - 调用`foo(6)`：`y=6`
> >    - `foo`调用`bar(6,raw)`：`x=6`,`soo=raw`(函数指针)
> >    - `bar(6,raw)`：`x=6>3`，递归调用`bar(6/3,raw)=bar(2,raw)`
> >    - `bar(2,raw)`：`x=2<=3`，执行`else`分支：调用`soo(x)=raw(2)`
> >    - `raw(2)`：计算`y=2+5=7`，执行第8行`returny;`
> > 3. 当执行到`raw`函数第8行的`return`语句时，栈上有以下活动记录：
> >    - `foo`的AR(调用`foo(6)`时创建)
> >    - 第一次`bar`调用的AR(参数`x=6`,`soo=raw`)
> >    - 第二次`bar`调用的AR(参数`x=2`,`soo=raw`)
> >    - `raw`的AR(参数`x=2`)
> >
> > :one:执行到第$8$行`return`语句时的栈快照
> >
> > 1. 每个字段占一个内存单元，大小为$4$字节，但值以十进制表示
> >
> > 2. 栈快照起始地址为$500$，栈向低地址增长(地址递减)每个活动记录(`RA`)包含以下字段：
> >
> >    - 返回地址`(RA)`：调用返回地址(使用虚拟地址)
> >    - 控制链接`(CL)`：指向调用者活动记录的起始地址
> >    - 访问链接`(AL)`：用于静态作用域，指向定义作用域的活动记录`raw`和`foo`定义在全局
> >      - `AL`为`0`(全局无`AR`)，`bar`嵌套在`foo`内，`AL`指向`foo`的`AR`
> >    - 参数和局部变量：按函数声明顺序存储
> >
> > 3. 栈快照(地址从`500`开始递减)：
> >
> >    | 地址  | 内容          | 说明                                               |
> >    | ----- | ------------- | -------------------------------------------------- |
> >    | `500` | `1000`        | `foo`的`CL`(返回全局)                              |
> >    | `499` | `0`           | `foo`的`CL`(全局调用，无调用者)                    |
> >    | `498` | `0`           | `foo`的`AL`(全局作用域)                            |
> >    | `497` | `6`           | `foo`的参数`y`                                     |
> >    | `496` | 未定义        | `foo`的局部变量`z`(未初始化)                       |
> >    | `495` | `200`         | 第一次`bar`调用的`CL`(返回`foo`)                   |
> >    | `494` | `500`         | 第一次`bar`调用的`CL`(调用者`foo`AR起始地址)       |
> >    | `493` | `500`         | 第一次`bar`调用的`AL`(定义作用域`foo`AR起始地址)   |
> >    | `492` | `6`           | 第一次`bar`的参数`x`                               |
> >    | `491` | `raw`函数地址 | 第一次`bar`的参数`soo`(函数指针)                   |
> >    | `490` | `300`         | 第二次`bar`调用的`CL`(返回第一次`bar`)             |
> >    | `489` | `495`         | 第二次`bar`调用的`CL`(调用者第一次`bar`AR起始地址) |
> >    | `488` | `500`         | 第二次`bar`调用的`AL`(定义作用域`foo`AR起始地址)   |
> >    | `487` | `2`           | 第二次`bar`的参数`x`                               |
> >    | `486` | `raw`函数地址 | 第二次`bar`的参数`soo`(函数指针)                   |
> >    | `485` | `400`         | `raw`的`CL`(返回第二次`bar`)                       |
> >    | `484` | `490`         | `raw`的`CL`(调用者第二次`bar`AR起始地址)           |
> >    | `483` | `0`           | `raw`的`AL`(全局作用域)                            |
> >    | `482` | `2`           | `raw`的参数`x`                                     |
> >    | `481` | `7`           | `raw`的局部变量`y`(已计算为7)                      |
> >
> >    - 栈地址范围：`500`(最高地址)到`481`(最低地址)，共`20`个单元
> >    - `foo`的`z`未初始化，因为`bar(2,raw)`尚未执行`z=soo(x)`(在`raw`返回后赋值)
> >    - `soo`字段存储`raw`函数的地址(函数指针)，具体值未指定，以标签表示
> >    - 返回地址(RA)为虚拟值：`foo`返回全局(1000)
> >      - 第一次`bar`返回`foo`(200)
> >      - 第二次`bar`返回第一次`bar`(300)，`raw`返回第二次`bar`(400)
> >
> > :two:符号表
> >
> > | 作用域 | 符号  | 类型     | 描述                                            |
> > | ------ | ----- | -------- | ----------------------------------------------- |
> > | 全局   | `raw` | 函数     | 参数：`intx`；局部变量：`inty`                  |
> > | 全局   | `foo` | 函数     | 参数：`inty`；局部变量：`intz`；嵌套函数：`bar` |
> > | `foo`  | `bar` | 嵌套函数 | 参数：`intx`,`int(*soo)()`；访问外部`z`         |
> > | `foo`  | `z`   | 变量     | `foo`的局部变量，`int`类型                      |
> >
> > - 全局作用域：
> >   - `raw`：函数，参数`intx`，局部变量`inty`
> >   - `foo`：函数，参数`inty`，局部变量`intz`，嵌套函数`bar`
> > - `foo`作用域(嵌套)：
> >   - `bar`：函数，参数`intx`,`int(*soo)()`(函数指针，接受整数返回整数)
> >     - 访问外部变量`z`(来自`foo`)
> >
> > :three:活动树
> >
> > ```bash
> > 全局
> >   |
> >   |-- foo(6)
> >         |
> >         |-- bar(6, raw)  // 第一次调用
> >               |
> >               |-- bar(2, raw)  // 第二次调用
> >                     |
> >                     |-- raw(2)  // 执行到 return y
> > ```
> >
> > - 每个节点表示一个函数活动
> > - 边表示调用关系
> > - `raw(2)`是当前执行点(叶子节点)
> >
> > :four:各活动记录布局
> >
> > 1. `foo`的`AR`布局：
> >    - `AR`：返回地址
> >    - `CL`：控制链接(调用者`AR`地址)
> >    - `AL`：访问链接(全局作用域，`0`)
> >    - 参数`y`：`int`
> >    - 局部变量`z`：`int`
> >
> > - `bar`的`AR`布局(适用于所有调用)：
> >   - `AR`：返回地址
> >   - `CL`：控制链接(调用者`AR`地址)
> >   - `AL`：访问链接(指向`foo`的`AR`，因为`bar`定义在`foo`内)
> >   - 参数`x`：`int`
> >   - 参数`soo`：函数指针(`int(*)()`类型)
> >
> > - `RAR`的`AR`布局：
> >   - `AR`：返回地址
> >   - `CL`：控制链接(调用者`AR`地址)
> >   - `AL`：访问链接(全局作用域，`0`)
> >   - 参数`x`：`int`
> >   - 局部变量`y`：`int`
>
> ## ✅第二题
>
> > :one:参照以下代码，写出面向`ARM32`的指令模板
> >
> > 1. 指令模板(模式替换对)
> >
> >    ```asm
> >    t =  r_s + k        | lw r_t, k(r_s)
> >    r_t = M[t^last]     | 
> >
> >    r_t = M[r_s]        | lw r_t, 0(r_s)
> >
> >    r_t = M[k]          | lw r_t, k(R0)
> >
> >    t = r_s + k         | sw r_t, k(r_s)
> >    M[t^last] = r_t     | 
> >
> >    M[r_s] = r_t        | sw r_t, 0(r_s)
> >
> >    M[k] = r_t          | sw r_t, k(r_s)
> >
> >    r_d = r_s + r_t     | add r_d, r_s, r_t
> >
> >    r_d = r_t           | add r_d, R0, r_t
> >
> >    r_d = r_s + k       | addi r_d, r_s, k
> >
> >    r_d = k             | addi r_d, R0, k
> >
> >    GOTL l              | j l
> >
> >    LABEL l             | l:
> >    ```
> >
> > 2. 条件语句转换
> >
> >    ```assembly
> >    IF r_s = r_t THEN l_1 ELSE l_2      | beq  r_s,  r_t, l_1
> >    LABEL l_2                           | l_2:
> >    
> >    IF r_s = r_t THEN l_1 ELSE l_2      | bne  r_s,  r_t, l_2
> >    LABEL l_1                           | l_1:
> >    
> >    IF r_s = r_t THEN l_1 ELSE l_2      | beq  r_s,  r_t, l_1
> >                                        | J l_2
> >    
> >    IF r_s < r_t THEN l_1 ELSE l_2      | slt r_d,  r_s,  r_t
> >    LABEL l_2                           | bne r_d, R0, l_1
> >                                        | l_2:
> >    
> >    IF r_s < r_t THEN l_1 ELSE l_2      | slt r_d,  r_s,  r_t
> >    LABEL l_1                           | beq r_d, R0, l_2
> >                                        | l_1:
> >    
> >    IF r_s < r_t THEN l_1 ELSE l_2      | slt r_d,  r_s,  r_t
> >                                        | bne r_d, R0, l_1
> >                                        | j l_2:
> >    ```
> >
> > :two:解答：
> >
> > 1. 指令模板(模式替换对)
> >
> >    ```asm
> >    /* 寄存器使用规范：
> >    * r0-r3   : 调用者保存(临时值/参数)，优先用于指令模板中的 t
> >    * r4-r11  : 被调用者保存(长期变量)，用于跨基本块的值
> >    * r12 (ip): 临时寄存器(过程间调用暂存)
> >    * r13 (sp): 栈指针(绝对不用作通用)
> >    * r14 (lr): 链接寄存器
> >    * r15 (pc): 程序计数器
> >    */
> >    # 内存访问指令
> >    t = r_s + k         | add r_temp, r_s, #k       ; 显式临时寄存器
> >    r_t = M[t^last]     | ldr r_t, [r_temp]         ; 使用复合寻址优化↓
> >                        | // 或直接: ldr r_t, [r_s, #k] ; 单指令完成地址计算+加载
> >
> >    r_t = M[r_s]        | ldr r_t, [r_s]            ; 直接基址加载
> >
> >    r_t = M[k]          | ldr r_temp, =k            ; 显式临时寄存器
> >                        | ldr r_t, [r_temp]         ; 避免目标寄存器冲突
> >
> >    t = r_s + k         | add r_temp, r_s, #k       ; 显式临时寄存器
> >    M[t^last] = r_t     | str r_t, [r_temp]         ; 使用复合寻址优化↓
> >                        | // 或直接: str r_t, [r_s, #k] ; 单指令完成地址计算+存储
> >
> >    M[r_s] = r_t        | str r_t, [r_s]            ; 直接基址存储
> >
> >    M[k] = r_t          | ldr r_temp, =k            ; 显式临时寄存器
> >                        | str r_t, [r_temp]         ; 避免目标寄存器冲突
> >
> >    # 算术运算指令
> >    r_d = r_s + r_t     | add r_d, r_s, r_t         ; 寄存器加法
> >
> >    r_d = r_t           | mov r_d, r_t              ; 寄存器拷贝(比add更高效)
> >
> >    r_d = r_s + k       | adds r_d, r_s, #k         ; 加立即数(保留标志位)
> >                        | // 或: add r_d, r_s, #k   ; 不保留标志位
> >
> >    r_d = k             | movs r_d, #k              ; 小立即数(保留标志位)
> >                        | // 或: ldr r_d, =k        ; 大立即数(伪指令)
> >
> >    # 跳转指令
> >    GOTL l              | b l                       ; 无条件跳转
> >
> >    LABEL l             | l:                        ; 标签定义
> >    ```
> >
> > 2. 条件语句转换(消除冗余分支)
> >
> >    ```asm
> >    /* 寄存器使用规范：
> >    * r0-r3   : 调用者保存(临时值/参数)，优先用于指令模板中的 t
> >    * r4-r11  : 被调用者保存(长期变量)，用于跨基本块的值
> >    * r12 (ip): 临时寄存器(过程间调用暂存)
> >    * r13 (sp): 栈指针(绝对不用作通用)
> >    * r14 (lr): 链接寄存器
> >    * r15 (pc): 程序计数器
> >    */
> >    # 相等比较(优化冗余跳转)
> >    IF r_s = r_t THEN l_1 ELSE l_2 | cmp r_s, r_t
> >                                   | beq l_1        ; 等于跳l_1
> >                                   | l_2:           ; 否则顺序执行l_2
> >    
> >    IF r_s = r_t THEN l_1 ELSE l_2 | cmp r_s, r_t
> >                                   | bne l_2        ; 不等跳l_2
> >                                   | l_1:           ; 否则顺序执行l_1
> >    
> >    IF r_s = r_t THEN l_1 ELSE l_2 | cmp r_s, r_t
> >                                   | beq l_1        ; 等于跳l_1
> >                                   | b l_2          ; 否则跳l_2(l_2非紧邻时)
> >    
> >    # 有符号小于比较(直接使用条件码)
> >    IF r_s < r_t THEN l_1 ELSE l_2 | cmp r_s, r_t
> >                                   | blt l_1        ; 小于跳l_1
> >                                   | l_2:           ; 否则顺序执行l_2
> >    
> >    IF r_s < r_t THEN l_1 ELSE l_2 | cmp r_s, r_t
> >                                   | bge l_2        ; ≥跳l_2(反向条件)
> >                                   | l_1:           ; 否则顺序执行l_1
> >    
> >    IF r_s < r_t THEN l_1 ELSE l_2 | cmp r_s, r_t
> >                                   | blt l_1        ; 小于跳l_1
> >                                   | b l_2          ; 否则跳l_2(l_2非紧邻时)
> >    ```
>
> ## ✅第三题
>
> > :zero:对以下程序：写出所生成的可执行程序使用`MIPS`或`ARM`指令
> >
> > ```C
> > int x; float z;
> > int a[10,20]; //初始化值为a[i,j]=i+j
> > float bar(int y;){
> > 	float x;
> > 	x=y*PI;
> > 	return x};
> > float foo(int x; float boo(); int arr[];){
> > 	if (x==0)z=boo(arr[1],)
> > 	else return boo(arr[6*x],)};
> > print foo(2, bar(), a[],)
> > ```
> >
> > :bulb:重写源程序
> >
> > ```C++
> > #include <stdio.h>
> > #define PI 3.1415926
> > 
> > int x;
> > float z;
> > int a[10][20]; // 全局数组
> > 
> > float bar(int y) {
> >  float x;
> >  x = y * PI;
> >  return x;
> > }
> > 
> > float foo(int x, float (*boo)(int), int *arr) {
> >  if (x == 0) {
> >      z = boo(arr[1]);
> >      return 0.0;
> >  } else {
> >      return boo(arr[6 * x]);
> >  }
> > }
> > 
> > int main() {
> >  // 初始化数组 a[i][j] = i+j (简化处理)
> >  for (int i = 0; i < 10; i++) {
> >      for (int j = 0; j < 20; j++) {
> >          a[i][j] = i + j;
> >      }
> >  }
> > 
> >  float result = foo(2, bar, (int *)a);
> >  printf("Result: %f\n", result);
> >  return 0;
> > }
> > ```
> >
> > :one:`MIPS`版本
> >
> > ```asm
> > .data
> > x:          .word 0
> > z:          .float 0.0
> > a:          .space 800       # 10x20x4 = 800 bytes
> > PI:         .float 3.1415926
> > newline:    .asciiz "\n"
> > result_str: .asciiz "Result: "
> > 
> > .text
> > .globl main
> > 
> > # float bar(int y)
> > bar:
> >  mtc1 $a0, $f0
> >  cvt.s.w $f0, $f0        # $f0 = (float)y
> >  l.s $f1, PI             # $f1 = PI
> >  mul.s $f0, $f0, $f1     # $f0 = y * PI
> >  jr $ra
> > 
> > # float foo(int x, float (*boo)(int), int *arr)
> > foo:
> >  addi $sp, $sp, -12
> >  sw $ra, 8($sp)
> >  sw $a0, 4($sp)          # 保存 x
> >  sw $a1, 0($sp)          # 保存 boo
> > 
> >  bne $a0, $zero, else
> > 
> >  # x == 0: z = boo(arr[1])
> >  lw $t0, 4($a2)          # $t0 = arr[1]
> >  move $a0, $t0           # 参数: y = arr[1]
> >  jalr $a1                # 调用 boo
> >  s.s $f0, z              # z = 返回值
> > 
> >  # 返回0.0
> >  mtc1 $zero, $f0         # 将整数0移到浮点寄存器
> >  cvt.s.w $f0, $f0        # 转换为浮点数0.0
> >  j return
> > 
> > else:
> >  # 计算 arr[6*x]
> >  li $t0, 6
> >  mul $t1, $a0, $t0       # 6*x
> >  sll $t1, $t1, 2         # 字节偏移
> >  add $t1, $a2, $t1       # &arr[6*x]
> >  lw $a0, 0($t1)          # 参数: y = arr[6*x]
> >  jalr $a1                # 调用 boo
> >  # 返回值在 $f0
> > 
> > return:
> >  lw $ra, 8($sp)
> >  addi $sp, $sp, 12
> >  jr $ra
> > 
> > main:
> >  # 初始化数组 a[i][j] = i+j
> >  la $s0, a               # 数组基地址
> >  li $s1, 0               # i = 0
> >  li $s2, 10              # 外层循环上限
> > 
> > outer_loop:
> >  li $s3, 0               # j = 0
> >  li $s4, 20              # 内层循环上限
> > 
> > inner_loop:
> >  add $t0, $s1, $s3       # t0 = i+j
> > 
> >  # 计算数组索引: (i * 20 + j) * 4
> >  mul $t1, $s1, 20        # i*20
> >  add $t1, $t1, $s3       # i*20 + j
> >  sll $t1, $t1, 2         # 乘以4（字节偏移）
> >  add $t1, $s0, $t1       # 当前元素地址
> >  sw $t0, 0($t1)          # a[i][j] = i+j
> > 
> >  addi $s3, $s3, 1        # j++
> >  blt $s3, $s4, inner_loop # 内层循环
> > 
> >  addi $s1, $s1, 1        # i++
> >  blt $s1, $s2, outer_loop # 外层循环
> > 
> >  # 调用 foo(2, bar, a)
> >  li $a0, 2               # 第一个参数: x = 2
> >  la $a1, bar             # 第二个参数: boo = bar
> >  la $a2, a               # 第三个参数: arr = a
> >  jal foo                 # 调用 foo
> > 
> >  # 打印结果
> >  mov.s $f12, $f0         # 浮点数参数
> >  li $v0, 2               # 系统调用: 打印浮点数
> >  syscall
> > 
> >  li $v0, 4
> >  la $a0, newline
> >  syscall
> > 
> >  li $v0, 10             # 退出
> >  syscall
> > ```
> >
> > :two:`ARM`版本(使用`ARMv7-A`)
> >
> > ```asm
> > .data
> > x:          .word 0
> > z:          .float 0.0
> > a:          .space 800       @ 10*20*4 = 800 bytes
> > PI_val:     .float 3.1415926
> > result_fmt: .asciz "Result: %f\n"
> > 
> > .text
> > .global main
> > .global printf
> > 
> > @ float bar(int y)
> > bar:
> >  push {r11, lr}
> >  vmov s0, r0             @ 将整数参数移到浮点寄存器
> >  vcvt.f32.s32 s0, s0     @ 整数转浮点: (float)y
> >  vldr s1, PI_val         @ 加载PI值
> >  vmul.f32 s0, s0, s1     @ s0 = y * PI
> >  pop {r11, pc}
> > 
> > @ float foo(int x, float (*boo)(int), int *arr)
> > foo:
> >  push {r4-r5, r11, lr}   @ 保存寄存器
> >  mov r4, r0              @ r4 = x
> >  mov r5, r2              @ r5 = arr (保存数组指针)
> >  cmp r4, #0
> >  bne .Lelse
> > 
> >  @ if (x == 0)
> >  ldr r0, [r5, #4]        @ 加载arr[1] (偏移4字节)
> >  blx r1                  @ 调用boo(参数在r0)
> >  @ 将返回值存储到全局变量z
> >  ldr r3, =z              @ 加载z的地址到r3
> >  vstr s0, [r3]           @ z = 返回值
> >  vmov.f32 s0, #0.0       @ 返回0.0
> >  b .Lreturn
> > 
> > .Lelse:
> >  mov r0, #6
> >  mul r0, r4, r0          @ 计算6*x
> >  ldr r0, [r5, r0, LSL #2] @ 加载arr[6*x] (偏移量为6*x*4)
> >  blx r1                  @ 调用boo(参数在r0)
> >  @ 返回值在s0中
> > 
> > .Lreturn:
> >  pop {r4-r5, r11, pc}    @ 恢复寄存器并返回
> > 
> > main:
> >  push {r4-r8, r10, r11, lr}
> >  ldr r4, =a              @ r4 = 数组基地址
> >  mov r5, #0              @ i = 0
> >  mov r6, #10             @ 外层循环次数
> > 
> > .Louter_loop:
> >  mov r7, #0              @ j = 0
> >  mov r8, #20             @ 内层循环次数
> > 
> > .Linner_loop:
> >  add r0, r5, r7          @ r0 = i + j
> >  mov r1, #20             @ 每行20个元素
> >  mla r1, r5, r1, r7      @ 偏移 = i*20 + j
> >  str r0, [r4, r1, LSL #2] @ a[i][j] = i+j (偏移量乘以4)
> > 
> >  add r7, r7, #1          @ j++
> >  cmp r7, r8
> >  blt .Linner_loop
> > 
> >  add r5, r5, #1          @ i++
> >  cmp r5, r6
> >  blt .Louter_loop
> > 
> >  @ 调用foo(2, bar, a) - 修正参数顺序
> >  mov r0, #2              @ 第一个参数: x = 2
> >  ldr r1, =bar            @ 第二个参数: boo = bar
> >  ldr r2, =a              @ 第三个参数: arr = a
> >  bl foo                  @ 调用foo
> > 
> >  @ 打印结果
> >  vcvt.f64.f32 d0, s0     @ 单精度转双精度
> >  vmov r2, r3, d0         @ 拆分双精度到r2:r3
> >  ldr r0, =result_fmt     @ 格式字符串
> >  bl printf               @ 调用printf
> > 
> >  mov r0, #0              @ 返回0
> >  pop {r4-r8, r10, r11, lr}
> >  bx lr
> > ```

