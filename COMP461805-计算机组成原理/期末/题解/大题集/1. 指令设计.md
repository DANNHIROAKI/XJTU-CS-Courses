# 操作码扩展

:one:条件：某机器的指令设计满足以下条件

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240128201401020.png" alt="image-20240128201401020" width=400 />  

1. 指令格式：有二地址$/$一地址$/$零地址三种指令(二地址指令格式如上图)，`<OP_Code>`扩展前为$8$位
2. 前提条件：已设计出$m$条二地址指令$\text{+}n$条零地址指令

:two:求解：一地址指令数$h$的最大值

1. 扩展的情形：

   <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250127015901340.png" alt="image-20250127014906782" width=850 />   

2. 三类指令数量分析：

   |    指令类型    |    假设中的数量     | 实际已设计数量 |
   | :------------: | :-----------------: | :------------: |
   | 二地址指令数量 |         $x$         |      $m$       |
   | 一地址指令数量 |     $(2^8–x)y$      |  $h$(待求解)   |
   | 零地址指令数量 | $(2^8–x)(2^8–y)2^8$ |      $n$       |

3. 求解以上方程得到$h$即可

   - 代入$x\text{=}m$：其余几行变为

     |    指令类型    |    假设中的数量     | 实际已设计数量 |
     | :------------: | :-----------------: | :------------: |
     | 一地址指令数量 |     $(2^8–m)y$      |  $h$(待求解)   |
     | 零地址指令数量 | $(2^8–m)(2^8–y)2^8$ |      $n$       |

   - 处理最后一行：$[(2^8–m)2^8–h]2^8\text{=}n$，即可解得$h\text{=}(2^8–m)2^8–\left[\cfrac{n}{2^8}\right]$ 

# 指令寻址

:one:条件

1. 机器字长为$\text{16}$位，主存大小为$\text{128KB}$且为按字编址

2. 指令长度与字长相当，各字段内容为

   <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240129135321582.png" alt="image-20240129135321582" width=450 /> 

3. 寻址方式如下表，另外转移指令采用相对寻址，以及相对偏移采用补码表示

   | $\text{Ms/Md}$ | 指令格式         | 助记符         | 含义                                                |
   | :------------: | ---------------- | -------------- | --------------------------------------------------- |
   | $\text{000B}$  | 寄存器直接       | $\text{Rn}$    | 操作数$\text{=(Rn)}$                                |
   | $\text{001B}$  | 寄存器间接       | $\text{(Rn)}$  | 操作数$\text{=((Rn))}$                              |
   | $\text{010B}$  | 寄存器间接、自增 | $\text{(Rn+)}$ | 操作数$\text{=((Rn)), Rn}\leftarrow{}\text{(Rn)+1}$ |
   | $\text{011B}$  | 相对寻址         | $\text{D(Rn)}$ | 转移目标地址$\text{=(PC)+(Rn)}$                     |

:two:第一题

1. 第一问：该指令系统最多可能有多少条指令

   - 假设$\text{OP\_Code}$全部用于设计指令，则最多有$2^4\text{=}16$条指令

2. 第二问：该计算机最多有多少个通用寄存器

   - 当$\text{Ms/Md}$指示用于寄存器寻址时，$\text{Rs/Rd}$用于编码所有的通用寄存器，而由于$\text{Rs/Rd}$皆为$3$位，所以至多$2^3\text{=}8$个通用寄存器

3. 第三问：$\text{MAR/MDR}$各自需要多少位

   | $\textbf{CPU}$寄存器 |       含义       |              功能              |
   | :------------------: | :--------------: | :----------------------------: |
   |     $\text{MAR}$     | 存储器地址寄存器 | 和$\text{CPU}$互相传输**地址** |
   |     $\text{MDR}$     | 存储器数据寄存器 | 和$\text{CPU}$互相传输**数据** |

   - 主存是按字编址的且大小为$\text{128KB}$，所以可以写作$\text{64K×16bit}$，即主存中一共有$\text{64K}$个单元$\text{+}$每个主存单元的大小为$\text{16}$位
   - $\text{MAR}$存储的内容为主存单元的地址编码，对于$\text{64K=64×1024=}2^{16}$个主存单元，一共需要$\text{16}$位来编码，即$\text{MAR}$需要$\text{16}$位
   - $\text{MDR}$存储的内容为主存单元的具体数据，所以应该与主存单元的大小对齐，即也为$\text{16}$位

:three:第二题：转移指令的目标地址范围是多少

1. 对于$\text{EA=(PC)+(Rn)}$，$\text{EA}$的范围可由公式$\text{PC}–2^{k–1}\to{}\text{PC+}2^{k–1}–1$
2. $\text{Rn}$的位数等于$\text{CPU}$字长，即代入$k\text{=}16$即可

:four:补充的一些前提

1. $\text{OP\_Code=0010B}$表示加法操作，用助记符$\text{ADD}$表示

2. 对于寄存器$\text{R4,R5}$

   |   寄存器    |  寄存器编号   |     寄存器内容      |                 地址单元的内容                  |
   | :---------: | :-----------: | :-----------------: | :---------------------------------------------: |
   | $\text{R4}$ | $\text{100B}$ | $\text{(R4)=1234H}$ | 地址$\text{1234H}$存储内容$\text{((R4))=5678H}$ |
   | $\text{R5}$ | $\text{101B}$ | $\text{(R5)=5678H}$ | 地址$\text{5678H}$存储内容$\text{((R5))=1234H}$ |

3. 给定汇编指令$\text{ADD (R4),(R5+)}$，逗号前表示表示源操作数，逗号后表示目的操作数

:five:第三题

1. 第一问：求解汇编指令$\text{ADD (R4),(R5+)}$的$\text{16}$进制机器码

   <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240129135321582.png" alt="image-20240129135321582" width=450 /> 

   |    指令的部分     |          功能          |     内容      | 解析                                                         |
   | :---------------: | :--------------------: | :-----------: | ------------------------------------------------------------ |
   | $\text{OP\_Code}$ |      指示指令类型      | $\text{0010}$ | 正如题中条件所说，用$\text{OP\_Code=0010}$表示加法$\text{ADD}$ |
   |    $\text{Ms}$    |  指示源操作数寻址方式  | $\text{001}$  | 源操作数对应的是$\text{(R4)}$助记符，即执行寄存器间接寻址    |
   |    $\text{Rs}$    |  指示源操作数的寄存器  | $\text{100}$  | $\text{R4}$的寄存器编号是$\text{100}$                        |
   |    $\text{Md}$    | 指示目的操作数寻址方式 | $\text{010}$  | 目的操作数对应的是$\text{(R5+)}$助记符，即执行寄存器间接$\text{+}$自增寻址 |
   |    $\text{Rd}$    | 指示目的操作数的寄存器 | $\text{101}$  | $\text{R5}$的寄存器编号是$\text{101}$                        |

   - 所以合起来是$\text{0010 0011 0001 0101B=2315H}$

2. 第二问：执行该指令$\text{ADD (R4),(R5+)}$后，给出寄存器$/$内存单元改变后的内容

   - 源操作数的寻址：指令中$\text{Rs=100}\xrightarrow{找到}$寄存器$\text{(R4)=1234H}\xrightarrow{找到}$主存单元$\text{((R4))=5678H}$，所以源操作数$\text{=5678H}$
   - 目的操作数寻址：指令中$\text{Rd=101}\xrightarrow{找到}$寄存器$\text{(R5)=5678H}\xrightarrow{找到}$主存单元$\text{((R5))=1234H}$，所以目的操作数$\text{=1234H}$
   - 除此之外$\text{R5}$寄存器内的值还需要$\text{+1}$(类似于$\text{PC}$指针)，所以目的操作数寻址完成后$\text{(R5)=5678H+1=5679H}$ 
   - 执行相加，目的操作数所在处即$\text{5678H}$主存单元，相加后值变成$\text{1234H+5678H=68ACH}$

# 操作码扩展$\textbf{+}$指令寻址结合(搞定这道考试包过)

# 操作码扩展$\textbf{+}$指令寻址结合

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250219002508833.png" alt="image-20250219002508833" width=700 /> 

:one:第一问：由于操作码固定，所以至多至多也就只有$\text{64}$个指令，所以单操作数最多为$64-m-n$个

:two:第二问：

1. 二地址指令：`<OP_Code中x个用于二地址操作码>`
2. 一地址指令：`<OP_Code中64-x个用于扩展标志> <地址1中y个用于一地址操作码>`
3. 零地址指令：`<OP_Code中64-x个用于扩展标志> <地址1中32-y个用于扩展标志> <地址2中32个全用于零地址操作码>` 
4. 所以$x=m,(64-x)(32-y)32=n$于是$(64-x)y=(64-m)32-\cfrac{n}{32}$，最后别忘了后一项向下取整

:three:第三问：

1. 每个操作数占用$\text{5bit}$，一般情况下需要分配若干位指定寻址方式，剩下若干位用于指定寄存器
   - 极端情况下，默认之采取一种寻址方式，然后所有位都用于指定寄存器，便得到了最多$2^5=32$个通用寄存器
2. 采用直接寻址的情况下，$\text{5bit}$最多寻找到$\text{32}$个内存单元，每个存储单元为$\text{1Byte}$，所以最大寻址空间大小为$\text{32Byte}$

:four:第四问：

1. 首先前$6$位用于表示操作码
2. 后$10$位全部用于表示操作数
   - 首先需要指定寻址方式，变址或者相对，二选一，所以此处消耗$\text{1bit}$
   - 然后需要选择寄存器，共$\text{8}$个寄存器，所以此处消耗$\text{3bit}$
   - 最后还剩$\text{6bit}$，全部用作偏移量
3. 当采用相对寻址时，会默认指定$\text{PC}$寄存器为基地址，无需再指定寄存器
   - $\text{3+6bit}$的偏移量可以全部用于寻址，因此范围为$\text{(PC)}-2^{9-1}→\text{(PC)}+2^{9-1}-1$
4. 当采用变址寻址时，需要在$8$个通用寄存器中指定一个寄存器作为基地址
   - $\text{5bit}$的偏移量可以全部用于寻址，因此范围为$\text{(Rx)}-2^{5-1}→\text{(Rx)}+2^{5-1}-1$

