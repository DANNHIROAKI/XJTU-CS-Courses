# $\text{I/O}$​系统

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/66666.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/66666.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/66666.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/66666.html)==**

# 1. $\text{I/O}$系统概述

> ## 1.1. $\text{I/O}$系统组成
>
> > **1️⃣**$\text{I/O}$硬件：$\text{I/O}$设备$+$接口电路
> >
> > **2️⃣**$\text{I/O}$软件：用$\text{I/O}$指令编写，管理$\text{I/O}$电路和$\text{I/O}$接口，aka$\text{I/O}$​驱动
>
> ## 1.2. $\text{I/O}$编址：给每台$\text{I/O}$一个唯一编号
>
> > |         编址         |          本质特征           |            有关名词             | $\text{CPU}$对二者访问 |
> > | :------------------: | :-------------------------: | :-----------------------------: | :--------------------: |
> > | $\text{I/O-MM}$编址  | $\text{I/O+MM}$地址空间统一 |  总线空间$=\text{I/O+MM}$地址   |         不区分         |
> > | $\text{I/O}$独立编址 |      二者地址空间分开       | 设备号$=$独立的$\text{I/O}$地址 |          区分          |
>
> ## 1.3. $\text{I/O}$指令
>
> > **1️⃣**隐式$\text{I/O}$指令：适用于$\text{I/O-MM}$编址机器，所有访存指令都可以直接访问$\text{I/O}$
> >
> > **2️⃣**显式$\text{I/O}$指令：指令系统中有专门的$\text{I/O}$指令，格式如下
> >
> > |                操作码                |          命令码          |              设备码              |
> > | :----------------------------------: | :----------------------: | :------------------------------: |
> > | 告诉$\text{CPU}$这是$\text{I/O}$指令 | 执行何种$\text{I/O}$操作 | 执行指令的是哪个$\text{I/O}$设备 |
> >
> > ➕$\text{I/O}$寻址过程：$\text{I/O}$指令$\xrightarrow{要访问的\text{I/O}地址}$$\text{I/O}$接口$\xrightarrow[设备选择电路]{选中目标地址}\text{CPU}$开始读写操作

# 2. $\text{I/O}$设备(aka外设)

> ## 2.1. 外设概述
>
> > **1️⃣**基本组成
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/1yUAlJHmexgYhN8.png" alt="image-2024020520285099" style="zoom:50%;" /> 
> >
> > 1. 设备控制器：由电子电路实现，控制设备具体行为
> > 2. 设备的物理结构：由光磁等实现，和主机迥异
> >
> > **2️⃣**类型
> >
> > |   类型   |                   含义                   |          示例           |
> > | :------: | :--------------------------------------: | :---------------------: |
> > | 人机交互 | 操作者$\xleftrightarrow{信息交流}$计算机 | 键盘/鼠标/打印机/显示器 |
> > | 信息驻留 |                 保存信息                 |     磁盘/磁带/光盘      |
> > | 机机通信 |        实现计算机系统间通信的设备        | 调制解调器/直流交流转换 |
>
> ## 2.2. 键盘
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240205210214223.png" alt="image-20240205210214223" style="zoom: 80%;" /> 
> >
> > **1️⃣**结构：键盘以阵列方式排布，横竖交叉处放置一个键开关
> >
> > **2️⃣**键开关：位于键盘表面之下，用于将键盘敲击转化为电信号
>
> ## 2.3. 阴极射线管$\text{CRT}$显示器
>
> > ### 2.3.1. 概述
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240205211539933.png" alt="image-20240205211539933" style="zoom: 70%;" /> 
> > >
> > > **1️⃣**技术指标
> > >
> > > |   技术指标   |       含义       |          格式           |
> > > | :----------: | :--------------: | :---------------------: |
> > > |     像素     |    显示的亮点    |          $\#$           |
> > > |    分辨率    |     总像素数     | 每行像素数$×$每列像素数 |
> > > | 灰度级(黑白) | 像素点的亮暗级差 |          $\#$           |
> > > | 灰度级(彩色) | 像素点的颜色种数 |          $\#$           |
> > >
> > > **2️⃣**光栅扫描
> > >
> > > | 扫描方式 |               含义               |               特点               |
> > > | :------: | :------------------------------: | :------------------------------: |
> > > | 随机扫描 |      图像和字符在哪，就扫哪      |        显示快速，驱动复杂        |
> > > | 光栅扫描 | 周期性全屏扫描，分逐行和隔行两种 | 旧式电视普遍采用，但显示质量不佳 |
> > >
> > > **3️⃣**刷新：周期性地对屏幕重复进行扫描，有赖于刷新存储器/视频存储器/$\text{VRAM}$​
> >
> > ### 2.3.2. 字符显示
> >
> > > #### 2.3.2.1. 字符显示的点阵结构
> > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240206135003343.png" alt="image-20240206135003343" style="zoom: 60%;" /> 
> > > >
> > > > **1️⃣**字符窗口：如上图中$8×9$的范围
> > > >
> > > > **2️⃣**光栅地址：就第几行
> > > >
> > > > **3️⃣**字形码：把每行八位分为两个四位，点阵占用为1，例如第三行为$\text{0010 1000B=28H}$
> > >
> > > #### 2.3.2.2. $\text{CRT}$字符显示器构造
> > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240206190506091.png" alt="image-20240206190506091" style="zoom: 25%;" /> 
> > > >
> > > > **1️⃣**:显示存储器$\text{VRAM}$：
> > > >
> > > > 1. 功能：存放了一屏中所有字符的==$\text{ASCII}$信息==
> > > >
> > > > 2. $\text{VRAM}$字符地址：注意在这里，**排代表字符层面的行，行代表像素层面的行**
> > > >
> > > >    |     高位地址     |     低位地址     |             $\text{VRAM}$字符地址             |
> > > >    | :--------------: | :--------------: | :-------------------------------------------: |
> > > >    | 字符在屏幕中的排 | 字符在屏幕中的列 | 字符所在行$\times$一行有多少字符$+$字符所在列 |
> > > >
> > > > **2️⃣**字符发生器$\text{ROM}$ 
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240206134913453.png" alt="image-20240206134913453" style="zoom: 60%;" /> 
> > > >
> > > > 1. 功能：存放字符点阵的二进制编码矩阵，根据字符的$\text{ASCII}$读出字符点阵
> > > >
> > > > 2. $\text{ROM}$地址
> > > >
> > > >    | 地址 |        高位地址        | 低位地址/光栅地址  |
> > > >    | :--: | :--------------------: | :----------------: |
> > > >    | 含义 | 字符的$\text{ASCII}$码 |   字符点阵的行号   |
> > > >    | 来源 |   $\text{VRAM}$输出    | 光栅地址计数器输出 |
> > >
> > > #### 2.3.2.3. 字符显示的定时控制
> > >
> > > > **1️⃣**各个计数器简介
> > > >
> > > > |            部件             | 功能                                                        |                 模长                  |                             输出                             |
> > > > | :-------------------------: | :---------------------------------------------------------- | :-----------------------------------: | :----------------------------------------------------------: |
> > > > |          点振荡器           | 1. 产生点时钟，频率$\propto$辨率/帧率                       |                  $1$                  |                $\xrightarrow{点时钟}$点计数器                |
> > > > |          点计数器           | 1. 计算==窗口每行多少像素==<br/>2. 计完一行输出一个字符时钟 |             字符窗口宽度              | $\xrightarrow{字符时钟}$字计数器<br/>$\xrightarrow[加载]{字符时钟}$移位寄存 |
> > > > | 字计数器<br/>水平地址计数器 | 1. 计算==屏幕每行多少字符==<br/>2. 计完一行输出一个行时钟   |  一排字符数<br/>$+$<br/>水平回扫时间  | $\xrightarrow{行时钟}$行计数器<br/>$\xrightarrow{计数值}$$\text{VRAM}$低址 |
> > > > | 行计数器<br/>光栅地址计数器 | 1. 计算==窗口多少行像素==<br/>2. 计完一个窗口输出一个排时钟 |             字符窗口高度              | $\xrightarrow{排时钟}$排计数器<br/>$\xrightarrow[计数值]{排时钟}$$\text{ROM}$低址 |
> > > > | 排计数器<br/>垂直地址计数器 | 1. 计算==屏幕多少行字符==<br/>2. 计完一次垂直扫一次(帧时钟) | 屏幕字符行数<br/>$+$<br/>垂直回扫时间 |          $\xrightarrow[]{计数值}$$\text{VRAM}$高址           |
> > > >
> > > > **2️⃣**图示计数器工作过程
> > > >
> > > > 1. 点振荡器(左)$\&$点计数器(右)
> > > >
> > > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240206182100108.png" alt="image-20240206182100108" style="zoom: 38%;" />  
> > > >
> > > > 2. 字计数器$\&$行计数器(最右边1改成n)
> > > >
> > > > <img src="https://s2.loli.net/2024/02/06/KOAHJYqep5vs8ZL.png" alt="image-20240206175703984" style="zoom: 41%;" /> 
> > > >
> > > > 3. 排计数器
> > > >
> > > > <img src="https://s2.loli.net/2024/02/06/bl1LecC5qdUQSaR.png" alt="image-20240206180144256" style="zoom: 47%;" /> 
> > > >
> > > > **3️⃣**各个工作频率的关系
> > > >
> > > > | 频率 |        含义        | 大小                                                     |
> > > > | :--: | :----------------: | :------------------------------------------------------- |
> > > > | 帧频 |   扫完所有排耗时   | 帧频                                                     |
> > > > | 排频 |    扫完单排耗时    | 帧频$×$排计数器模                                        |
> > > > | 行频 |    扫描单行耗时    | 帧频$×$排计数器模$×$行计数器模                           |
> > > > | 字频 | 扫描窗口内一行耗时 | 帧频$×$排计数器模$×$行计数器模$×$字计数器模              |
> > > > | 点频 |  扫描完一像素耗时  | 帧频$×$排计数器模$×$行计数器模$×$字计数器模$×$点计数器模 |
> > >
> > > #### 2.3.2.4. 字符显示例题
> > >
> > > > **0️⃣**条件
> > > >
> > > > 1. 某$\text{CRT}$显示器可显示$\text{64}$种$\text{ASCII}$字符
> > > > 2. 每帧可显示64字$\text{×}$25排
> > > > 3. 每个字符字形采用7$\text{×}$8点阵
> > > >    - 横向7点，字间间隔1点，这一点间隔也一起存在$\text{ROM}$中
> > > >    - 纵向8点，排间间隔6点
> > > > 4. 采用逐行扫描：帧频$\text{50Hz/}$行频$\text{24.5KHz/}$点频$\text{14.896MHz}$​
> > > >
> > > > **1️⃣**$\text{VRAM}$​至少有多大？
> > > >
> > > > 1. ==$\text{VRAM}$缓存了一屏中所有字符的$\text{ASCII}$信息==，$\text{VRAM}$也就是所谓的缓存
> > > > 2. 64字$\text{×}$25排的意思是，一共有25每行有64个字，一屏最多64$\text{×}$25个字符
> > > > 3. 而字符使用$\text{ASCII}$编码，故一个字符需要8位，故大小至少为$\text{64×25×8bit = 1600B}$​
> > > >
> > > > **2️⃣**$\text{ROM}$​至少有多大？
> > > >
> > > > 1. ==$\text{ROM}$​存放了字符的所有点阵==
> > > > 2. 一共有64中字符，每个字符点阵大小(加上间隔)为8$\text{×}$8，所以大小为$\text{64×8×8bit = 512B}$​
> > > >
> > > > **3️⃣**$\text{VRAM}$​缓存地址与屏幕显示位置如何对应
> > > >
> > > > | 显示字符 |          左$\to$右          |                   上$\to$下                   |
> > > > | :------: | :-------------------------: | :-------------------------------------------: |
> > > > | 缓存地址 | 小$\xrightarrow{步长为1}$大 | 小$\xrightarrow{步长为1行所显示字符的数量}$大 |
> > > >
> > > > **4️⃣**计算各个计数器分频
> > > >
> > > > 1. 首先：分频是指通过模长将频率降低多少倍，==$\text{模=k}\iff{}\text{k:1分频}$​==
> > > > 2. 其次：根据模大小定义，先算出连个计数器的分频
> > > >
> > > > |  计数器  |            模大小             |          模值          |  分频  |
> > > > | :------: | :---------------------------: | :--------------------: | :----: |
> > > > | 点计数器 |         字符窗口宽度          |       8(点阵宽)        | $8:1$  |
> > > > | 字计数器 | 屏幕一行字符数$+$水平回扫时间 |   水平回扫时间不可知   |  $\#$  |
> > > > | 行计数器 |         字符窗口高度          | 8$+$6(点阵高$+$排间距) | $14:1$ |
> > > > | 排计数器 |  屏幕字符行数$+$垂直回扫时间  |   竖直回扫时间不可知   |  $\#$  |
> > > >
> > > > 3. 再代入如下式子
> > > >
> > > > |        点频        |   $=$   |     帧频      |   $×$   |   排模   |   $×$   |   行模   | $×$  | 字模 | $×$  | 点模 |
> > > > | :----------------: | :-----: | :-----------: | :-----: | :------: | :-----: | :------: | :--: | :--: | :--: | :--: |
> > > > | $\text{14.896MHz}$ |   $=$   | $\text{50Hz}$ |   $×$   |   $X$    |   $×$   |    14    | $×$  | $Y$  | $×$  |  8   |
> > > > |      **行频**      | **$=$** |   **帧频**    | **$×$** | **排模** | **$×$** | **行模** |      |      |      |      |
> > > > |  $\text{24.5KHz}$  |   $=$   | $\text{50Hz}$ |   $×$   |   $X$    |   $×$   |    14    |      |      |      |      |
> > > >
> > > > 解得$\begin{cases}X=35\\\\Y=76\end{cases}$
> >
> > ### 2.3.3. 图像显示
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240206185340912.png" alt="image-20240206185340912" style="zoom:67%;" /> 
> > >
> > > **1️⃣**==$刷新存储器容量=像素数*\log_2{(灰度级\text{aka}像素颜色数)}$​==
> > >
> > > **2️⃣**客观图像/摄像机取景$\xrightarrow[算法]{画出点线阴影等}$主观图像/计算机图像​
>
> ## 2.4. 点阵打印机
>
> > **1️⃣**总体结构
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240206210541544.png" alt="image-20240206210541544" style="zoom: 80%;" /> 
> >
> > **2️⃣**控制电路结构：和$\text{CRT}$字符显示器都采用点阵，所以结构相似
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240206210355790.png" alt="image-20240206210355790" style="zoom: 80%;" /> 

# 3. $\text{I/O}$接口：$\text{I/O}$设备$\xleftrightarrow{\text{I/O}接口}$$\text{CPU}$$\text{}$

> ## 3.1. $\text{I/O}$接口作用
>
> > |                             功能                             |         技术基础          |
> > | :----------------------------------------------------------: | :-----------------------: |
> > | $\text{CPU}\xleftrightarrow[\text{I/O}接口]{速度匹配}\text{I/O设备}$ |         数据缓冲          |
> > | $\text{CPU}\xleftrightarrow[\text{I/O}接口]{数据格式转换} \text{I/O设备}$ |       串并转换电路        |
> > | $\text{CPU}\xleftrightarrow[\text{I/O}接口]{电气转换}\text{I/O设备}$ |         电平匹配          |
> > | $\text{CPU}\xrightarrow[ \text{I/O}接口]{单向控制}\text{I/O设备}$ |     接收/传达控制命令     |
> > | $\text{CPU}\xrightarrow[\text{I/O}接口]{单向查询}\text{I/O设备}$ | 保存/传送$\text{I/O}$状态 |
> > | $\text{CPU}\xrightarrow[\text{I/O}接口]{\text{I/O}寻址}\text{I/O设备}$ |       设备选择电路        |
>
> ## 3.2. $\text{I/O}$接口结构：双连界面 
>
> > **1️⃣**接口内部总线与部件
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240206213421113.png" alt="image-20240206213421113" style="zoom: 60%;" />  
> >
> > | $\text{I/O}$接口有关总线 |                功能                 |          连接部件          |
> > | :----------------------: | :---------------------------------: | :------------------------: |
> > |          数据线          |      传输数据，以字/字节为单位      | 数据缓冲寄存器$\text{DBR}$ |
> > |    地址线/设备选择线     | 传送设备地址，位数等于设备地址位数  |        设备选择电路        |
> > |          命令线          | 传输控制命令，如外设读/写/启动/清除 |      命令寄存/译码器       |
> > |          状态线          |        传输设备状态，如忙/闲        |    设备状态标记(触发器)    |
> >
> > :eggplant:一条指令/地址通路
> > 
> > $$
> > \text{I/O}设备完成相应操作
> > \xleftarrow{识别命令}
> > 命令寄存器\xleftarrow[命令]{\text{SEL}}
> > \begin{cases}
> > \xleftarrow[匹配后]{发出\text{SEL}信号}设备选择电路\xleftarrow{给出地址}\text{CPU}\\\\
> > \xleftarrow{给出命令}\text{CPU}
> > \end{cases}
> > $$
> >
> > **2️⃣**接口的外部连接
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/7n4KYSZ3PMEkJ8X.png" alt="image-2024020219383575" style="zoom: 80%;" /> 
> >
> > 1. $\text{I/O}$接口$\xleftrightarrow{}$​主机($\text{CPU}$)：总线结构
> > 2. $\text{I/O}$接口$\xleftrightarrow{}$$\text{I/O}$​设备：一字/一字节的多位同时并行传输，或者一位一位串行传输
> >
>
> ## 3.3. $\text{I/O}$接口$\xleftrightarrow{通讯}$$\text{I/O}$设备
>
> > **1️⃣**同步通信：由时钟同步(框定啥时候互相要干啥)，通讯双方无需应答信号
> >
> > 1. 串行/并行的连接方式：区别在于一次传一字/还是一位
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240206233837842.png" alt="image-20240206233837842" style="zoom: 91%;" /> 
> >
> > 2. 同步串行数据格式：先传送两$\text{SYN}$作为起始标志，然后一数据块一数据块传数据，最后校验
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240206234317605.png" alt="image-20240206234317605" style="zoom:100%;" />  
> >
> > **2️⃣**异步通信：二者间用应答方式联络
> >
> > 1. 连接方式：去掉时钟，但加上状态线(用于将$\text{I/O}$设备状态发往$\text{I/O}$接口和$\text{CPU}$​​)
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240206235609009.png" alt="image-20240206235609009" style="zoom:80%;" /> 
> >
> > 2. 数据格式：没有同步时钟后，需要在格式里加入同步信息(起始位/终止位)
> >
> > <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240206235218193.png" alt="image-20240206235218193" style="zoom: 45%;" /> 

# 4. $\text{I/O}$数据传送方式

> ## 4.1. 程序查询方式
>
> > ### 4.1.1. 基本思想
> >
> > > **1️⃣**原理：$\text{CPU}$要执行$\text{I/O}$时，往现行程序里塞一段$\text{I/O}$指令编制的程序，运行塞入程序以$\text{I/O}$ 
> > >
> > > **2️⃣**处理流程：$\text{CPU}$干瞪眼
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240207002840311.png" alt="image-20240207002840311" style="zoom: 60%;" /> 
> >
>
> ## 4.2. 中断程序方式
>
> > ### 4.2.1. 中断概念
> >
> > > **1️⃣**中断/程序中断：计算机执行被紧急事件打断，$\text{CPU}$​暂停程序去处理事件，处理完后继续执行
> > >
> > > **2️⃣**中断技术：软硬件结合
> > >
> > > **3️⃣**$\text{I/O}$中断：由$\text{I/O}$操作引发的中断
> >
> > ### 4.2.2. 中断处理流程
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240208003537704.png" alt="image-20240208003537704" style="zoom: 33%;" />  
> > >
> > > | 步骤 |                             描述                             |
> > > | :--: | :----------------------------------------------------------: |
> > > | 请求 | 外设($\text{INTR}$触发器)$\xrightarrow[储存/发出]{请求信号}\text{CPU}$($\text{EINT}$触发器)$\xrightarrow{允许信号}\text{CPU}$决定理不理这个中断 |
> > > | 判优 | $\text{INTR1/INTR2...INTRn(请求队列)}\xrightarrow[串行/并行排队器]{得到优先队列}\text{INTP1/INTP2...INTPn}$ |
> > > | 响应 | $\text{CPU}$完成：关中断，==入栈==程序断点和$\text{PSW}$，找到中断服务入口(软件查询/硬件向量) |
> > > | 服务 |            保护现场，中断处理(数据交换)，现场恢复            |
> > > | 返回 |     $\text{CPU}$完成：==出栈==断点和$\text{PSW}$，开中断     |
> >
> > ### 4.2.3. 中断向量
> >
> > > 向量编码器$\xrightarrow{中断向量地址}$找到主存单元$\xrightarrow{根据主存单元中的内容}$找到中断服务程序入口
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240207144727644.png" alt="image-20240207144727644" style="zoom: 86%;" /> 
> >
> > ### 4.2.4. 多重中断
> >
> > >  **1️⃣**单重/多重中断：在处理当前$\text{A}$中断时，新的$\text{B}$中断来临，该如何处理
> > >
> > > | 中断类型 | 优先级                   | 执行操作                                                     |
> > > | -------- | ------------------------ | ------------------------------------------------------------ |
> > > | 单重中断 | $\text{B}\leq{}\text{A}$ | 执行完$\text{A}$中断后再去执行$\text{B}$中断                 |
> > > | 多重中断 | $\text{B}>\text{A}$      | 中断$\text{A}$中断的处理，转而处理$\text{B}$中断，处理完后再回到$\text{A}$中断 |
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240207190834729.png" alt="image-20240207190834729" style="zoom: 35%;" />    
> > >
> > > **2️⃣**多重中断实现的条件：中断服务中插入中断的开关操作
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240207191807392.png" alt="image-20240207191807392" style="zoom: 80%;" /> 
> >
> > ### 4.2.5. 中断嵌套
> >
> > > **1️⃣**嵌套规则：优先级低的中断，可以嵌套执行高的，如下图→是嵌套方向($\text{A}$套$\text{B}$套$\text{C}$)
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240207215303153.png" alt="image-20240207215303153" style="zoom:55%;" /> 
> > >
> > > **2️⃣**实现技术：
> > >
> > > |  技术  |   决定了说明   |
> > > | :----: | :------------: |
> > > | 优先级 | 中断的响应次序 |
> > > | 屏蔽字 | 中断的处理次序 |
> > >
> > > **3️⃣**==屏蔽字设置==：假设预想的中断处理次序为$\text{A}\to\text{B}\to\text{C}\to\text{D}\to\text{E}$则屏蔽字为
> > >
> > > |   中断源   | $\text{E}$ | $\text{D}$ | $\text{C}$ | $\text{B}$ | $\text{A}$ |
> > > | :--------: | :--------: | :--------: | :--------: | :--------: | :--------: |
> > > | $\text{A}$ | $\text{1}$ | $\text{1}$ | $\text{1}$ | $\text{1}$ | $\text{1}$ |
> > > | $\text{B}$ | $\text{1}$ | $\text{1}$ | $\text{1}$ | $\text{1}$ | $\text{0}$ |
> > > | $\text{C}$ | $\text{1}$ | $\text{1}$ | $\text{1}$ | $\text{0}$ | $\text{0}$ |
> > > | $\text{D}$ | $\text{1}$ | $\text{1}$ | $\text{0}$ | $\text{0}$ | $\text{0}$ |
> > > | $\text{E}$ | $\text{1}$ | $\text{0}$ | $\text{0}$ | $\text{0}$ | $\text{0}$ |
> > > |  现行程序  | $\text{0}$ | $\text{0}$ | $\text{0}$ | $\text{0}$ | $\text{0}$ |
> > >
> > > 1. 规则$1$：$\text{X→Y}$表示$\text{X}$优先级高于$\text{Y}$，则有下表(为$1$表示可以屏蔽/默认自己可以屏蔽自己)
> > >
> > >    |   中断源   | $\text{X}$ | $\text{Y}$ |
> > >    | :--------: | :--------: | :--------: |
> > >    | $\text{X}$ | $\text{1}$ | $\text{1}$ |
> > >
> > > 2. 规则$2$：$\text{Y→Z}$表示$\text{Z}$优先级下于$\text{Y}$，则有下表(为$0$表示不可以屏蔽)
> > >
> > >    |   中断源   | $\text{Y}$ | $\text{Z}$ |
> > >    | :--------: | :--------: | :--------: |
> > >    | $\text{Z}$ | $\text{0}$ | $\text{1}$ |
> > >
> > > 3. 总的来说就是以处理次序为准，左边的都记$0$，右边的都记$1$，自己记$1$​
> > >
> > > **4️⃣**==嵌套实例==：优先级$\text{ABCDE}$，处理次序$\text{BECAD}$
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240208013444738.png" alt="image-20240208013444738" style="zoom:50%;" />  
> > >
> > > | 阶段 |   正在运行的程序   | 正在请求的中断(按优先级排序) |  被屏蔽的中断  | 响应的中断 |
> > > | :--: | :----------------: | :--------------------------: | :------------: | :--------: |
> > > |  ①   |      现有程序      |        $\text{ABCDE}$        |      $\#$      | $\text{A}$ |
> > > |  ②   | $\text{A}$中断处理 |        $\text{BCDE}$         |  $\text{DA}$   | $\text{B}$ |
> > > |  ③   | $\text{B}$中断处理 |        $\text{BCDE}$         | $\text{EDCBA}$ |    $\#$    |
> > > |  ④   | $\text{A}$中断处理 |         $\text{CDE}$         |  $\text{DA}$   | $\text{C}$ |
> > > |  ⑤   | $\text{C}$中断处理 |         $\text{DE}$          |  $\text{DCA}$  | $\text{E}$ |
> > > |  ⑥   | $\text{E}$中断处理 |          $\text{D}$          | $\text{EDCA}$  |    $\#$    |
> > > |  ⑦   | $\text{C}$中断处理 |          $\text{D}$          |  $\text{DCA}$  |    $\#$    |
> > > |  ⑧   | $\text{A}$中断处理 |          $\text{D}$          |  $\text{DA}$   |    $\#$    |
> > > |  ⑨   |      现有程序      |          $\text{D}$          |      $\#$      | $\text{D}$ |
> >
>
> ## 4.3. $\text{DMA}$(直接存储器访问)方式
>
> > ### 4.3.1. $\text{DMA}$功能：$\text{I/O}\xleftrightarrow[\text{DMA}]{直接/自动/横批地传输数据}$主存
> >
> > > **1️⃣**目的：而减少$\text{CPU}$干预
> > >
> > > **2️⃣**和中断方式结构对比如下
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240208004836702.png" alt="image-20240208004836702" style="zoom:45%;" /> 
> >
> > ### 4.3.2. $\text{DMA}$​数据交换流程
> >
> > > |   阶段   | 操作                                                         |
> > > | :------: | ------------------------------------------------------------ |
> > > |  预处理  | $\text{CPU}\xrightarrow[]{初始参数(主存地址/传送字数)}\text{DMA控制器}$，==然后$\text{CPU}$回去执行原程序== |
> > > | 数据传输 | 1. $\text{I/O}$备好数据$+\text{CPU}$给出总线权<br/>2. ==主存$\xleftrightarrow[一个个地]{传输数据}\text{DMA}$==，传输过程无$\text{CPU}$参与<br/>3. 传完一批后$\text{DMA控制器}\xrightarrow[]{中断}\text{CPU}$ |
> > > |  后处理  | $\text{CPU}$响应中断，执行中断程序以结束$\text{I/O}$         |
> > >
> > > ==高亮部分==可能会发生$\text{DMA}$接口和$\text{CPU}$同时访问主存的情况，冲突消解见下
> >
> > ### 4.3.3. $\text{DMA}$接口和$\text{CPU}$的访存冲突消解
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240208140244799.png" alt="image-20240208140244799" style="zoom: 50%;" /> 
> > >
> > > |         方式         | 操作                    |
> > > | :------------------: | ------------------------------------------------------------ |
> > > | 停止$\text{CPU}$访存 | $\text{DMA}$接口要用主存时，直接暂停$\text{CPU}$现有的程序，让其踏步等待 |
> > > |    周期挪用/窃取     | $\text{CPU}$先不停，外设备好数据后发$\text{DMA}$请求，$\text{DMA}$接口然后才偷占小段周期 |
> > > |            交替访存          |将$\text{CPU}$工作周期划为两个主存周期，一个给$\text{CPU}$一个给$\text{DMA}$|
> >
> > ### 4.3.4. $\text{DMA}$接口
> >
> > > **1️⃣**结构：相当于$\text{DMA}$控制器$+$$\text{I/O}$接口，同时向下兼容了查询和中断接口的功能
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240208141744284.png" alt="image-20240208141744284" style="zoom: 67%;" /> 
> > >
> > > **2️⃣**种类：
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240208142536331.png" alt="image-20240208142536331" style="zoom:50%;" /> 
> > >
> > > |     种类     | 物理上       | 逻辑上                   |
> > > | :----------: | ------------ | ------------------------ |
> > > | 选择型(上图) | 直连多个设备 | 同一时刻只为一个设备服务 |
> > > | 多路型(下图) | 直连多个设备 | 同一时刻可为多个设备服务 |
>
> ## 4.4. $\text{I/O}$方式例题
>
> > ### 4.4.0. 大前提
> >
> > > **1️⃣**$\text{CPU: }$主频$\text{50MHz}$​，执行每条指令需要5个时钟周期
> > >
> > > **2️⃣**$\text{I/O: }$​外设只有**键盘**和**硬盘**
> > >
> > > 1. 用户敲击键盘速度时一秒五遍
> > > 2. 硬盘传输速率为$\text{5MBbs}$
> >
> > ### 4.4.1. 当外设都采用程序查询
> >
> > > **1️⃣**$\text{CPU}$一秒执行的时钟数：$\text{50M}$
> > >
> > > **2️⃣**$\text{CPU}$​每秒查询键盘所耗时钟
> > >
> > > 1. 键盘一共101键，每键查询一次要经历三个指令：读状态→判断是否按下→回送状态
> > > 2. 一秒内执行指令数$101键×3指令×5遍$，占用周期数$101键×3指令×5遍×5时钟每条指令$​
> > > 3. 比率$\cfrac{101×3×5×5}{\text{50M}}=0.01515\%$​
> > >
> > > **3️⃣**硬盘每秒查询所耗指令
> > >
> > > 1. 一秒要传输$\text{5MB}$大小也就是$\text{5M}$个存储单元，对每个单元需要执行两指令：命中→读出
> > >
> > > 2. 一秒内执行指令数$\text{5M存储单元×2指令}$，占用周期数$\text{5M存储单元×2指令×5时钟每条指令}$
> > >
> > > 3. 比率$\cfrac{5\text{M}×2×5}{\text{50M}}=100\%$​​，所以就不该采用软件查询
> >
> > ### 4.4.2. 当外设都采用中断方式
> >
> > > **1️⃣**新前提
> > >
> > > 1. 中断服务：有9条指令，其他开销占1条指令时间
> > > 2. 硬盘：硬盘$\xleftrightarrow{记录块}$主存，传输速率$\text{5MBbs}$，中断$\text{CPU}$​一次交换一字节
> > >
> > > **2️⃣**求：$\cfrac{\text{CPU键盘数据传送时间}}{键盘准备数据时间}$​
> > >
> > > 1. 处理一次中断，就是执行一次中断服务程序，耗时$\text{(9指令+1间隔)×5时钟每指令=50时钟}$
> > > 2. 键盘一秒敲击5次，也就是每次敲的准备时间为$\text{0.2s=10M时钟}$
> > > 3. 比率为$50/10^{7}=0.0005\%$​
> > >
> > > **3️⃣**求：$\cfrac{\text{CPU硬盘数据传送时间}}{硬盘准备数据时间}$
> > >
> > > 1. 照样中断服务一次耗时$50$​时钟
> > > 2. 一次交换一字节所以一秒钟要交换$\text{5M}$次，交换一次要准备$1/\text{5M}$秒也就是$10$时钟
> > > 3. 比率为$50/10=5$​​​，所以硬盘处理不能用中断
> >
> > ### 4.4.3. 当外设都采用$\text{DMA}$方式
> >
> > > **1️⃣**新前提：只考虑硬盘
> > >
> > > 1. 每次$\text{DMA}$传送的数据为$\text{500B}$
> > > 2. $\text{DMA}$​预处理和后处理一次，总开销为500个时钟
> > >
> > > **2️⃣**求$\text{CPU}$用于硬盘时间的占比
> > >
> > > 1. 将预处理→传输数据→后处理视为一次完整$\text{DMA}$传输，其中数据传输是不需要$\text{CPU}$插手的
> > > 2. 数据传输耗时：$\text{500B/5MBps=100us}$，无需$\text{CPU}$
> > > 3. 前后处理耗时：$\text{500时钟/50MHz=10us}$，需要$\text{CPU}$
> > > 4. 所以占比为$\text{10us/(10us+100us)=9.09\%}$







