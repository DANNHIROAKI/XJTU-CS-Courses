# 指令系统

**==笔记源文件：[Markdown](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/22222.md)，[长图](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/22222.png)，[PDF](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/22222.pdf)，[HTML](https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/22222.html)==**

# 1. 指令的一般格式

> ## 1.1. 概述
>
> > **1️⃣**指令所需要实现的功能
> >
> > 1. 指明要实现何种操作(操作码)
> > 2. 指明参与操作的数据类型(操作码)，以及该数据在哪(地址码)
> > 3. 指明接下来执行什么指令(地址码)
> >
> > **2️⃣**一般格式：`<操作码OP_Code> <地址码Addr_Code>`
> >
> > **3️⃣**操作码：提供以下信息
> >
> > 1. 指令的操作类型：是加减乘除，还是其余逻辑运算，指明一个
> > 2. 操作数类型：
> >    - 存储设备(Reg/MM/IO)中存放的是纯数据，纯数据可以解释为不同类型/字长/进制
> >    - 如何解释，就是操作码说了算
> >
> > **4️⃣**地址码
> >
> > 1. 涉及：IO设备地址—主存单元地址—寄存器地址
> > 2. 三者对应：CPU结构—指令系统结构—地址码形式
>
> ## 1.2. CPU结构
>
> > ### 1.2.1. 古早结构
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240128164912002.png" alt="image-20240128164912002" style="zoom:50%;" /> 
> > >
> > > ==灰色代表源操作数，给色代表目的操作数==
> > >
> > > |            | 栈式结构                        | 累加器结构                                            |
> > > | :--------: | ------------------------------- | ----------------------------------------------------- |
> > > |  源操作数  | 栈顶**(隐式)**+栈次顶**(隐式)** | 累加器AC**(隐式)**+存储器**(显式，即指令中明确指定)** |
> > > | 目的操作数 | 栈顶                            | 累加器AC                                              |
> > > |    优点    | 指令较短，程序空间小            | 指令较短，程序空间小                                  |
> > > |    缺点    | 无法随意访问堆栈                | 只有AC用于暂存中间结果，将频繁访问AC                  |
> > >
> >
> > ### 1.2.2. 通用寄存器结构
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240128164948813.png" alt="image-20240128164948813" style="zoom:50%;" /> 
> > >
> > > ==灰色代表源操作数，给色代表目的操作数== 
> > >
> > > |                    | RR                     | RS             | **SS**         |
> > > | :----------------: | :--------------------: | :------------: | :------------: |
> > > | 源操作数(全部显式) | 寄存器+寄存器          | 寄存器+存储器  | 存储器+存储器  |
> > > | 目的操作数         | 寄存器                 | 寄存器         | 寄存器         |
> > > | 优点               | 指令字长固定，结构简单 | 目标代码紧凑   | 目标代码最紧凑 |
> > > | 缺点               | 指令条数多             | 两操作数不对称 |两操作数最不对称  |

# 2. 地址场结构

> **1️⃣**格式：注意$\text{A1,A2,A3}$是通用寄存器，涉及的专用寄存器如累加器$\text{AC}$
>
> | 类型       | `OP_Code` | `A1`                            | `A2`              | `A3`               |
> | ---------- | --------- | ------------------------------- | ----------------- | ------------------ |
> | 三地址指令 | 操作码    | **源**操作数1地址               | **源**操作数2地址 | **目的**操作数地址 |
> | 二地址指令 | 操作码    | **源**操作数+**目的**操作数地址 | **源**操作数地址  | $\text{N/A}$       |
> | 一地址指令 | 操作码    | **源**操作数地址                | $\text{N/A}$      | $\text{N/A}$       |
> | 零地址指令 | 操作码    | $\text{N/A}$                    | $\text{N/A}$      | $\text{N/A}$       |
>
> **2️⃣**功能
>
> | 类型       | 功能                                               | 特点                                         |
> | ---------- | -------------------------------------------------- | -------------------------------------------- |
> | 三地址指令 | $\text{A3}\leftarrow{}\text{(A1) OP (A2)}$         | 两个源操作数内容不变；指令字长太长           |
> | 二地址指令 | $\text{A1}\leftarrow{}\text{(A1) OP (A2)}$         | 砍掉一个地址码字段后寻址范围增大，扩展性增强 |
> | 一地址指令 | $\text{AC}\leftarrow{}\text{(AC) OP (A)}$          | 隐式默认一个操作数在特定位置，如$\text{AC}$  |
> | 零地址指令 | $\text{堆顶}\leftarrow{}\text{(堆顶) OP (堆次顶)}$ | 出左边所说，还可用于停机/空操作/隐式单操作数 |

# 3. 操作码扩展技术

> ## 3.1. 定长/变长操作码
>
> > | 操作码类型 | 本质特征                 | 特点                             | 举例   |
> > | ---------- | ------------------------ | -------------------------------- | ------ |
> > | 定长操作码 | 操作码长度不变，位置不变 | 硬件设计方便，译码简单           | MIPS32 |
> > | 变长操作码 | 操作码长度可变，位置可变 | 控制器设计复杂，译码复杂，可扩展 | IA-32  |
>
> ## 3.2. 扩展技术
>
> > **1️⃣**核心思想：地址码较少时，操作码占用更多位
> >
> > **2️⃣**等长扩展：典型如操作码按照4位/8位/12位依次扩展
> >
> > **3️⃣**两种4-8-12扩展：
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240128200602174.png" alt="image-20240128200602174" style="zoom: 43%;" /> 
>
> ## 3.3. 例题
>
> >  **1️⃣**条件
> >
> >  <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240128201401020.png" alt="image-20240128201401020" style="zoom: 67%;" /> 
> >
> >  1. 某机器二地址格式为：`<OP_Code_8位><A1_8位><A2_8位>`
> >  2. 该机器只有三种指令：二地址/一地址/零地址
> >  3. 扩展前操作码(基本操作码)为8位
> >  4. 目前已设计出：$m$条二地址指令，$n$条零地址指令
> >
> >  **2️⃣**计算：一地址指令数$h$的最大值
> >
> >  1. 画出扩展的图谱
> >
> >  <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240128211214411.png" alt="image-20240128211214411" style="zoom:39%;" /> 
> >
> >  2. $m$条二地址指令：
> >     - OP_Code有$m$个用作操作码，$2^8-m$个用作扩展标志
> >     - 前16位用于零地址/一地址，共有$(2^8-m)\times{}2^8$种可能
> >  3. $n$条零地址指令：
> >     - 前16位中一种扩展标志$\xleftrightarrow{对应}$$\text{A2}$中$2^8$种操作码$\xleftrightarrow{对应}$$2^8$种零地址操作码
> >     - 所以前16位中共抽离了$[\cfrac{n}{2^8}]$种可能作为零地址操作的标志，剩下的就是用作一地址的了
> >  4. 所以$h=(2^8-m)\times{}2^8-[\cfrac{n}{2^8}]$
> >

# 4. 寻址方式

> ## 4.1. 两种寻址
>
> > **1️⃣**指令寻址
> >
> > 1. 目的：确定下个执行的指令，所在主存单元的地址
> > 2. 方式：顺序PC+1，跳跃JMP
> >
> > **2️⃣**数据寻址
> >
> > 1. 格式：`<操作码> <寻址方式码> <形式地址1><形式地址2>.....<形式地址n>`
> > 2. 目的：$形式地址(符号地址)\xrightarrow{寻址方式}{有效地址(逻辑地址)}$
> > 3. 种类：立即寻址、寄存器寻址、存储器寻址、堆栈寻址
>
> ## 4.2. 立即寻址：$\text{EA=Imme Data}$
>
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20230918134235212.png" alt="image-20230918134235212" style="zoom: 50%;" />  
> >
> > $\text{Des/目的操作数}\xleftarrow{赋值}\text{Imme Data/源操作数}$
> >
> > ```assembly
> > mov eax,100
> > ```
>
> ## 4.3. 寄存器寻址：$\text{EA=Ri}$
>
> > **1️⃣**寄存器直接寻址
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/d33c34bb-da24-4c33-901d-c21faf6d4aa3-19142746.jpg" alt="image" style="zoom:50%;" /> 
> >
> > - $\text{R}_i\text{/通用寄存器号}\xrightarrow{找到}\text{Data/通用寄存器组/源操作数}$
> >
> > - $\text{Des/目的操作数}\xleftarrow{赋值}\text{Data/通用寄存器组/源操作数 }$
> >
> > ```assembly
> > mov eax ebx
> > ```
> > 
> > **2️⃣**寄存器间接寻址：这实质上是一种存储器寻址，见下
>
> ## 4.4. 存储器(主存)寻址
>
> > **1️⃣**直接寻址：$\text{EA=A}$
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20230918135259136.png" alt="image-20230918135259136" style="zoom:50%;" /> 
> >
> > - $\text{A/主存单元号}\xrightarrow{找到}\text{Data/主存单元/源操作数}$
> > - $\text{Des/目的操作数}\xleftarrow{赋值}\text{Data/主存单元/源操作数}$
> >
> > ```assembly
> > mov eax [100]
> > ```
> >
> > **2️⃣**一次存储器间接寻址：$\text{EA=(A1)}$
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20230918140156561.png" alt="image-20230918140156561" style="zoom:50%;" /> 
> >
> > - $\text{A1/主存单元号}\xrightarrow{找到}\text{A2/主存中/另一个主存单元号}\xrightarrow{找到}\text{Data/主存中/源操作数}$
> > - $\text{Des/目的操作数}\xleftarrow{赋值}\text{Data/主存中/源操作数}$
> >
> > **3️⃣**二次存储器间接寻址：$\text{EA=((A1))}$
> >
> > 1. 寻址范围：
> >
> >    - $\text{A1}$主存单元：主存字长为$m$，可寻址$2^m$个单元
> >
> >    - $\text{A2}$及以后主存单元：主存字长为$m$，但首尾为间址标志位，可再寻址$2^{m-1}$个单元
> >    - 一次可间址$2^m$个单元，$n$次可间址$2^m\times{}(n-1)2^{m-1}$个单元
> >
> > 2. 间址过程：不断在主存单元跳，跳到主存单元的间址标志位为0时，停止间址取出$\text{Data}$
> >
> > 3. 严禁套娃：否则执行速度巨慢
> >
> > **4️⃣**寄存器间接寻址：$\text{EA=(Ri)}$
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20230918141352316.png" alt="image-20230918141352316" style="zoom:50%;" /> 
> >
> > - $\text{R}_i\text{/通用寄存器号}\xrightarrow{找到}\text{A/通用寄存器}\xrightarrow{找到}\text{Data/存储器/源操作数}$
> > - $\text{Des/目的操作数}\xleftarrow{赋值}\text{Data/存储器/源操作数}$
> >
> > ```assembly
> > mov eax [ebx]
> > ```
> >
> > **5️⃣**偏移寻址：$\text{EA=B(基地址)+A(偏移量)}$
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20230918142047579.png" alt="image-20230918142047579" style="zoom:50%;" /> 
> >
> > 1. 寻址过程：
> >    - $\text{R}_i\text{/通用寄存器号}\xrightarrow{找到}\text{B/通用寄存器/基地址}\xrightarrow[加上A/偏移量]{找到}\text{Data/主存单元/源操作数}$
> >    - $\text{Des/目的操作数}\xleftarrow{赋值}\text{Data/主存单元/源操作数}$
> > 2. 类型
> >
> > | 类型      | 操作数EA        | 偏移量        | 基地址        | 特性                                        | 用途          |
> > | --------- | --------------- | ------------- | ------------- | ------------------------------------------- | ------------- |
> > | 相对寻址  | $\text{(PC)+A}$ | $\text{A}$    | $\text{(PC)}$ | 用专门$\text{PC}$指针，指令只给出$\text{A}$ | 处理跳转      |
> > | 变址寻址1 | $\text{(Rx)+A}$ | $\text{(Rx)}$ | $\text{A}$    | 引用专用变址寄存器，为默认                  | 处理数组      |
> > | 变址寻址2 | $\text{(Ri)+A}$ | $\text{(Ri)}$ | $\text{A}$    | 引用通用变址寄存器，需指定                  | 同上          |
> > | 基址寻址  | $\text{(Rb)+A}$ | $\text{A}$    | $\text{(Rb)}$ | 引用基址寄存器                              | 逻辑→物理地址 |
> >
> > 3. 寻址范围：由偏移量决定
> >
> >    - 相对寻址：$\text{A}$共$k$位时，$\text{PC}-2^{k-1}\to{}\text{PC}+2^{k-1}-1$
> >
> >    - 变址寻址：$\text{(Rx)}$为$n$位时，寻址大小为$2^n$字
> >    - 基址寻址：$\text{A}$共$k$位时，$\text{Rb}-2^{k-1}\to{}\text{Rb}+2^{k-1}-1$
> >
> > 4. 补充：基址寄存器设定基址后，不可改变
> >
> > **6️⃣**段寻址：$\text{EA=N+A }\text{ 物理地址=DS}\times{}\text{16+EA}$
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/PicGo-Typora-GitHub-Picture-bed/main/img/image-20230918152302427.png" alt="image-20230918152302427" style="zoom:50%;" /> 
> >
> > 1. 核心思想：
> >    - 将主存化为多个逻辑段，一个程序可以横跨多个段
> >    - 访问操作数时，先指定在哪个段，再在对应段内偏移
> > 2. 寻址过程
> >    - $\text{Rb/寄存器号}\xrightarrow{找到}\text{N/通用寄存器}\xrightarrow[加上A]{找到}\text{EA/有效地址/段内偏移}$
> >    - $\text{DS/段寄存器}\xrightarrow{左移4位}\text{DS}\times16\text{/段基地址}$
> >    - $\text{DS}\times16\text{/段基地址0 + }\text{EA/有效地址/段内偏移}\xrightarrow{找到}\text{Data/主存单元/物理地址/源操作数}$
> >    - $\text{Des/目的操作数}\xleftarrow{赋值}\text{Data/主存单元/源操作数}$
> > 3. 补充：整个过程硬件自动完成，对用户透明
>
> ## 4.5. 外设寻址：关注两种编址方式
>
> > **1️⃣**独立编址：主存，寄存器，IO的地址的开头都是0，如8086(左)
> >
> > **2️⃣**统一编制：寄存器从0开始，主存从64开始，IO从128开始
> >
> > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240129134405654.png" alt="image-20240129134405654" style="zoom: 67%;" /> 
>
> ## 4.6. 堆栈寻址
>
> > ### 4.6.1. 关于堆栈
> >
> > > **1️⃣**两种堆栈
> > >
> > > 1. 硬堆栈/寄存器堆栈
> > > 2. 软堆栈/存储器堆栈：主存中开辟一块地，栈底固定，栈顶通过$\text{SP}$指针浮动
> > >
> > > **2️⃣**堆栈顶/底的设定
> > >
> > > 1. 栈底在低地址，栈顶在高地址，栈向上生长
> > > 2. 栈底在高地址，栈顶在低地址，栈向下生长 
> > >
> > > **3️⃣**栈顶的确认
> > >
> > > 1. $\text{SP}$指向栈顶+1处的空单元
> > > 2. $\text{SP}$指向栈顶处的非空单元
> >
> > ### 4.6.2. 两种堆栈寻址
> >
> > > **1️⃣**$\text{SP}$指向栈顶+1处的空单元
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240129123702988.png" alt="image-20240129123702988" style="zoom: 70%;" /> 
> > >
> > > 1. 空栈：栈底和栈顶为同一单元
> > > 2. 入栈
> > >
> > > ```RTL
> > > (SP)⬅数据
> > > SP⬅(SP)+1(向上生长)
> > > SP⬅(SP)-1(向下生长)
> > > ```
> > >
> > > 3. 出栈
> > >
> > > ```RTL
> > > SP⬅(SP)-1(向上生长)
> > > SP⬅(SP)+1(向下生长)
> > > [(SP)]清空出栈
> > > ```
> > >
> > > **2️⃣**$\text{SP}$指向栈顶处的非空单元
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240129124258374.png" alt="image-20240129124258374" style="zoom:70%;" /> 
> > >
> > > 1. 空栈：栈底和栈顶为同一单元
> > > 2. 入栈
> > >
> > > ```RTL
> > > SP⬅(SP)+1(向上生长)
> > > SP⬅(SP)-1(向下生长)
> > > (SP)⬅数据
> > > ```
> > >
> > > 3. 出栈
> > >
> > > ```RTL
> > > [(SP)]清空出栈
> > > SP⬅(SP)-1(向上生长)
> > > SP⬅(SP)+1(向下生长)
> > > ```
> > > 
>
> ## 4.6. 例题
>
> > ### 4.6.1. 条件
> >
> > > **1️⃣**机器字长16位，主存大小128KB，但是按字编址(即$\text{64K}\times{}\text{16位}$)
> > >
> > > **2️⃣**采用字长指令格式，各字段为
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240129135321582.png" alt="image-20240129135321582" style="zoom:50%;" /> 
> > >
> > > **3️⃣**寻址方法
> > >
> > > | $\text{Ms/Md}$ | 指令格式         | 助记符         | 含义                                                |
> > > | -------------- | ---------------- | -------------- | --------------------------------------------------- |
> > > | $\text{000B}$  | 寄存器直接       | $\text{Rn}$    | 操作数$\text{=(Rn)}$                                |
> > > | $\text{001B}$  | 寄存器间接       | $\text{(Rn)}$  | 操作数$\text{=((Rn))}$                              |
> > > | $\text{010B}$  | 寄存器间接、自增 | $\text{(Rn+)}$ | 操作数$\text{=((Rn)), Rn}\leftarrow{}\text{(Rn)+1}$ |
> > > | $\text{011B}$  | 相对             | $\text{D(Rn)}$ | 转移目标地址$\text{=(PC)+(Rn)}$                     |
> > >
> > > 补充：转移指令采用相对寻址，相对偏移采用补码表示
> >
> > ### 4.6.2. 第一问
> >
> > > ❓问题
> > >
> > > 1. 该指令系统最多可有多少条指
> > > 2. 该计算机最多有多少个通用寄存器
> > > 3. 存储器地址寄存器$\text{(MAR)}$需要多少位，$\text{(MAR)}$用于接收$\text{CPU}$传输的地址信号
> > > 4. 存储器数据寄存器$\text{(MDR)}$需要多少位，$\text{(MDR)}$用于和$\text{CPU}$交互数据
> > >
> > > 👉解答
> > >
> > > 1. 假设$\text{OP\_Code}$全部用于设计指令，最多有$2^4=16$条
> > > 2. $\text{Rs, Rd}$是用于寄存器寻址的，故最多有$2^3=8$个寄存器
> > > 3. 思路如下
> > >    - 主存128K用字编址就是64K×16位，每16位一字/一字一个存储单元
> > >    - 主存中一共64K=$2^{16}$个单元，所以需要16位才能编址主存单元
> > >    - 所以$\text{CPU}$传输的地址信号是16位的，也就是$\text{(MAR)}$是16位的
> > > 4. $\text{CPU}$一次性能处理16位数据(机器字长)，所以$\text{(MDR)}$也需要16位
> >
> > ### 4.6.3. 第二问
> >
> > > ❓问题：转移指令的目标地址范围是多少？
> > >
> > > 👉解答：
> > >
> > > 1. 相对寻址：$\text{EA=(PC)+(Rn)}$，$\text{(Rn)}$用补码表示且共$k$位时，$\text{PC}-2^{k-1}\to{}\text{PC}+2^{k-1}-1$
> > > 2. 代入即可得：$-2^{k-1}\to{}+2^{k-1}-1$，$\text{Rn}$的位数等于$\text{CPU}$字长，代入$k=16$即可
> >
> > ### 4.6.4. 第三问
> >
> > > ⬅️​前提
> > >
> > > 1. $\text{OP\_Code=0010B}$表示加法操作，用助记符$\text{ADD}$表示
> > > 2. 对于寄存器$\text{R4,R5}$
> > >
> > > | 寄存器      | 寄存器编号    | 寄存器内容          | 地址单元的内容                                  |
> > > | ----------- | ------------- | ------------------- | ----------------------------------------------- |
> > > | $\text{R4}$ | $\text{100B}$ | $\text{(R4)=1234H}$ | 地址$\text{1234H}$存储内容$\text{((R4))=5678H}$ |
> > > | $\text{R5}$ | $\text{101B}$ | $\text{(R5)=5678H}$ | 地址$\text{5678H}$存储内容$\text{((R5))=1234H}$ |
> > >
> > > 3. 给定汇编指令：$\text{ADD (R4),(R5+) }$逗号前表示表示源操作数，逗号后表示目的操作数
> > >
> > > ❓问题：
> > >
> > > 1. 求出给出汇编指令的16进制机器码
> > > 2. 执行该指令后，有哪些寄存器/内存单元会改变？给出改变后的内容
> > >
> > > 👉解答：
> > >
> > > 1. 机器码：照着这个指令格式填充
> > >
> > >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240129135321582.png" alt="image-20240129135321582" style="zoom:50%;" /> 
> > >
> > >    - $\text{OP\_Code=0010B}$
> > >    - $\text{(R4)}$表示寄存器间接，所以参照寻址表$\text{Ms=001B}$
> > >    - $\text{(R4)}$对应的寄存器号是$\text{100B}$，所以$\text{Rs=100B}$
> > >    - $\text{(R5+)}$表示寄存器间接寻址切自增长，所以$\text{Md=010B}$
> > >    - $\text{(R5)}$对应的寄存器号是$\text{101B}$，所以$\text{Rd=101B}$
> > >
> > >    合并为$\text{0010 0011 0001 0101B = 2315H}$
> > >
> > > 2. 寄存器/内存单元的改变
> > >
> > >    - $\text{R4}$的寻址：
> > >
> > >      $\text{源操作数=((R4))=(1234H)=5678H}$
> > >
> > >    - $\text{R5}$的寻址：
> > >
> > >      $\text{目的操作数=((R5))=(5678H)=1234H}$，并且$\text{(R5)=(R5)+1=5679H}$
> > >
> > >    - 相加：
> > >
> > >      $\text{(5678H)单元新值=(5678H)单元旧值+(1234H)单元值=1234H+5678H=68ACH}$
> > >
> > >    所以$\text{(R5)}\xrightarrow{变成}\text{5679H}$，$\text{(5678H)}\xrightarrow{变成}\text{68ACH}$

# 5. CISC和RISC

> ## 5.1. CISC
>
> > **1️⃣**主要特征
> >
> > 1. 用一条功能复杂的指令，完成一串指令的功能，目的在于减少取指频率
> > 2. 用复杂寻址&指令，来支持高级语言的高效实现
> > 3. 向上向后兼容，新机器支持所有旧机器的指令，指令集不断扩大
> > 4. 采用微程序控制技术设计控制器
> >
> > **2️⃣**弊端
> >
> > 1. 指令和寻址太复杂，编译复杂，难以优化
> > 2. 大多指令太复杂，几个时钟周期才能执行完
> > 3. 微程序控制器影响速度
> > 4. 各种指令使用的频率悬殊很大
>
> ## 5.2. RISC
>
> > **1️⃣**相较于CISC的二元对立特征
> >
> > 1. 指令长度固定，指令格式种类少，寻址方式种类少
> > 2. 只有存取数/指令才访问寄存器(CISC种任何一条指令都可访问存储器)
> > 3. 优选CISC中使用频率高的简单指令，其他扔掉
> > 4. 控制单元以硬布线逻辑为主
> >
> > **2️⃣**其他特征
> >
> > 1. 通用寄存器相当多
> > 2. CPU采用流水线结构，CPI低
> > 3. 采用编译优化

# 6. 指令系统示例：MIPS32

> | 类型      | 31_26位                         | 25_21位                                   | 20_16位                                  | 15_11位                                  | 10_6位                               | 5_0位                            |
> | --------- | ------------------------------- | ----------------------------------------- | ---------------------------------------- | ---------------------------------------- | ------------------------------------ | -------------------------------- |
> | R         | <font color='red'>操作码</font> | <font color='orange'>源操作数1</font>(rs) | <font color='gree'>源操作数2</font>(rt)  | <font color='blue'>目的操作数</font>(rd) | <font color='purple'>移位位数</font> | 功能码                           |
> | I(立即数) | <font color='red'>操作码</font> | <font color='orange'>源操作数1</font>(rs) | <font color='blue'>目的操作数</font>(rt) | <font color='pink'>立即数</font>         | <font color='pink'>立即数</font>     | <font color='pink'>立即数</font> |
> | J(跳转)   | <font color='red'>操作码</font> | <font color='pink'>立即数</font>          | <font color='pink'>立即数</font>         | <font color='pink'>立即数</font>         | <font color='pink'>立即数</font>     | <font color='pink'>立即数</font> |
>
> **1️⃣**对于R型指令
>
> 1. 31_26位全0(special类型)，需要再根据5_0位决定指令类型
>
> 2. 对于R型指令，10_6位为移位位数，当指令不涉及位移时全部置0
>
> **2️⃣**对于I型指令：直接由5_0位决定指令类型
>
> **3️⃣**对于J型指令：
>
> 1. `j`：无条件跳转
> 2. `jal`：无条件跳转并链接
> 3. `jr`：寄存器跳转(其实这个指令是R型的)
> 4. `jalr`：寄存器跳转并链接(其实这个指令是R型的)
